var documenterSearchIndex = {"docs":
[{"location":"tut_contacts/#11-Contact-Structures","page":"11 - Contact Structures","title":"11 - Contact Structures","text":"","category":"section"},{"location":"api_individuals/#Individuals","page":"Individuals","title":"Individuals","text":"","category":"section"},{"location":"api_individuals/","page":"Individuals","title":"Individuals","text":"hier eine subsection: wie fragt man den Status der agents ab (hier alle funktionen, wie man states queried)","category":"page"},{"location":"api_individuals/#Overview-Structs","page":"Individuals","title":"Overview Structs","text":"","category":"section"},{"location":"api_individuals/","page":"Individuals","title":"Individuals","text":"Pages   = [\"api_individuals.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_individuals/#Overview-Functions","page":"Individuals","title":"Overview Functions","text":"","category":"section"},{"location":"api_individuals/","page":"Individuals","title":"Individuals","text":"Pages   = [\"api_individuals.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_individuals/#Structs","page":"Individuals","title":"Structs","text":"","category":"section"},{"location":"api_individuals/#GEMS.Agent","page":"Individuals","title":"GEMS.Agent","text":"Supertype for simulation agents\n\n\n\n\n\n","category":"type"},{"location":"api_individuals/#GEMS.Individual","page":"Individuals","title":"GEMS.Individual","text":"Individual <: Agent\n\nA type to represent individuals, that act as agents inside the simulation.\n\nFields\n\nGeneral\nid::Int32: Unique identifier of the individual\nsex::Int8: Sex  (Female (1), Male(2), Diverse (3))\nage::Int8: Age\neducation::Int8: Education class (i.e. highest degree)\noccupation::Int16: Occupation class (i.e. manual labour, office job, etc...)\nBehaviour\nsocial_factor::Float32: Parameter for the risk-willingness. Can be anywhere between   -1 and 1 with neutral state is 0.\nmandate_compliance::Float32. Paremeter which influences the probability of complying   to mandates. Can be anywhere between -1 and 1 with neutral state is 0.\nHealth Status\ncomorbidities::Vector{Bool}: Indicating prevalence of certain health conditions. True,   if the individual is preconditioned with the comorbidity associated to the array index.\ndead::Bool: Flag indicating individual's decease\nhospital_status::Int8: State in the hopsital   (0 = not hospitalized, 1 = hospitalized, 2 = ventilation, 3 = ICU)\nAssociated Settings\nhousehold::Int32: Reference to household id\noffice::Int32: Reference to office id\nschoolclass::Int32: Reference to schoolclass id\nmunicipality::Int32: Reference to municipality id\nPathogen\npathogen_id::Int8: pathogen identifier\ninfection_id::Int32: Current infection id\ndisease_state::Int8: Current State in natural disease history    (0 = not infected, 1 = Presymptomatic, 2 = Symptomatic, 3 = Severe, 4 = Critical)\nsymptom_category::Int8: Endstate in current disease progression. The numbers should align    with disease_state, but can be interpreted as the symptom category of this case   (0 = None, 1 = Asymptomatic, 2 = Mild, 3 = Severe, 4 = Critical)\ninfectiousness::Int8: an individuals infectiousness (1-127), i.e. for superspreaders\nnumber_of_infections::Int8: infection count\nNatural Disease History\nexposed_tick::Int16: Tick of most recent infection\ninfectious_tick::Int16: Tick of most recent change into \"infectious\" state (considered asymptomatic)\nonset_of_symptoms::Int16: Tick of the onset of symptoms\nonset_of_severeness::Int16: Tick of onset of severe symptoms\nhospitalized_tick::Int16: Tick of hospitalization\nventilation_tick::Int16: Tick of ventilation\nicu_tick::Int16: Tick of ICU (Intensive Care Unit)\ndeath_tick::Int16: Tick of Death\nremoved_tick::Int16: Tick of most recent removal event\nTesting\nlast_test::Int16: Tick of last test for pathogen\nlast_test_result::Bool: Flag for positivity of last test\nlast_reported_at::Int16: Tick at which this individual was last reported\nVaccination\nvaccine_id::Int8: Vaccine identifier\nnumber_of_vaccinations::Int8: Individual's vaccination counter\nvaccination_tick::Int16: Tick of most recent vaccination\nInterventions\nquarantine_status::Int8: Status to indicate quarantine    (none, household_quarantined, hospitalized, etc...)\nquarantine_tick::Int16: Start tick of quarantine\nquarantine_release_tick::Int16: End tick of quarantine\n\n\n\n\n\n","category":"type"},{"location":"api_individuals/#Constructors","page":"Individuals","title":"Constructors","text":"","category":"section"},{"location":"api_individuals/#GEMS.Individual-Tuple{Dict}","page":"Individuals","title":"GEMS.Individual","text":"Individual(properties::Dict)\n\nCreate an individual with the provided properties. Properties must have at least keys id, sex, age.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.Individual-Tuple{DataFrameRow}","page":"Individuals","title":"GEMS.Individual","text":"Individual(properties::DataFrameRow)\n\nCreate an individual with the provided properties. Properties must have at least keys id, sex, age.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#Functions","page":"Individuals","title":"Functions","text":"","category":"section"},{"location":"api_individuals/#GEMS.age","page":"Individuals","title":"GEMS.age","text":"age(individual::Individual)\n\nReturn an individual's age.\n\n\n\n\n\n","category":"function"},{"location":"api_individuals/#GEMS.class_id","page":"Individuals","title":"GEMS.class_id","text":"class_id(individual::Individual)\n\nReturns an individual's associated class's ID.\n\n\n\n\n\n","category":"function"},{"location":"api_individuals/#GEMS.comorbidities","page":"Individuals","title":"GEMS.comorbidities","text":"comorbidities(individual::Individual)\n\nReturns an individual's comorbidities.\n\n\n\n\n\n","category":"function"},{"location":"api_individuals/#GEMS.critical!-Tuple{Individual}","page":"Individuals","title":"GEMS.critical!","text":"critical!(individual::Individual)\n\nMarks the individual's condition as critical.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.critical-Tuple{Individual}","page":"Individuals","title":"GEMS.critical","text":"critical(individual::Individual)\n\nReturns wether the individual's condition is critical.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.dead-Tuple{Individual}","page":"Individuals","title":"GEMS.dead","text":"dead(individual::Individual)\n\nReturns an individual's death flag.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.death_tick!-Tuple{Individual, Int16}","page":"Individuals","title":"GEMS.death_tick!","text":"death_tick!(individual::Individual, tick::Int16)\n\nSets an individual's death tick.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.death_tick-Tuple{Individual}","page":"Individuals","title":"GEMS.death_tick","text":"death_tick(individual::Individual)\n\nReturns an individual's death tick.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.disease_state-Tuple{Individual}","page":"Individuals","title":"GEMS.disease_state","text":"disease_state(individual::Individual)\n\nReturns an individual's disease status (currently infected).\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.education-Tuple{Individual}","page":"Individuals","title":"GEMS.education","text":"education(individual::Individual)\n\nReturn an individual's education class\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.end_quarantine!-Tuple{Individual}","page":"Individuals","title":"GEMS.end_quarantine!","text":"end_quarantine!(individual::Individual)\n\nEnds an individuals quarantine.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.exposed-Tuple{Individual}","page":"Individuals","title":"GEMS.exposed","text":"exposed(individual::Individual)\n\nReturns wether the individual is exposed (infected, but not yet infectious).\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.exposed_tick!-Tuple{Individual, Int16}","page":"Individuals","title":"GEMS.exposed_tick!","text":"exposed_tick!(individual::Individual, tick::Int16)\n\nSets an individual's exposed tick.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.exposed_tick-Tuple{Individual}","page":"Individuals","title":"GEMS.exposed_tick","text":"exposed_tick(individual::Individual)\n\nReturns an individual's exposed tick (currently infected).\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.has_municipality-Tuple{Individual}","page":"Individuals","title":"GEMS.has_municipality","text":"has_municipality(individual::Individual)\n\nReturns true if individual is assigned to an instance of type Municipality.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.home_quarantine!-Tuple{Individual}","page":"Individuals","title":"GEMS.home_quarantine!","text":"home_quarantine!(individual::Individual)\n\nQuarantines an individual in their household.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.hospital_status-Tuple{Individual}","page":"Individuals","title":"GEMS.hospital_status","text":"hospital_status(individual::Individual)\n\nReturns the hospital_status of the individual.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.hospitalize!-Tuple{Individual}","page":"Individuals","title":"GEMS.hospitalize!","text":"hospitalize!(individual::Individual)\n\nHospitalizes the individual.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.hospitalized-Tuple{Individual}","page":"Individuals","title":"GEMS.hospitalized","text":"hospitalized(individual::Individual)\n\nReturns wether the individual is hospitalized.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.hospitalized_tick!-Tuple{Individual, Int16}","page":"Individuals","title":"GEMS.hospitalized_tick!","text":"hospitalized_tick!(individual::Individual, tick::Int16)\n\nSets an individual's tick for when it gets hospitalized.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.hospitalized_tick-Tuple{Individual}","page":"Individuals","title":"GEMS.hospitalized_tick","text":"hospitalized_tick(individual::Individual)\n\nReturns an individual's tick for when it gets hospitalized.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.household_id-Tuple{Individual}","page":"Individuals","title":"GEMS.household_id","text":"household_id(individual::Individual)\n\nReturns an individual's associated household's ID.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.icu!-Tuple{Individual}","page":"Individuals","title":"GEMS.icu!","text":"icu!(individual::Individual)\n\nSets the individual to be in ICU.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.icu-Tuple{Individual}","page":"Individuals","title":"GEMS.icu","text":"icu(individual::Individual)\n\nReturns wether the individual is in ICU.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.icu_tick!-Tuple{Individual, Int16}","page":"Individuals","title":"GEMS.icu_tick!","text":"icu_tick!(individual::Individual, tick::Int16)\n\nSets an individual's tick for when it will be delivered into icu.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.icu_tick-Tuple{Individual}","page":"Individuals","title":"GEMS.icu_tick","text":"icu_tick(individual::Individual)\n\nReturns an individual's tick when it will be delivered into icu.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.id-Tuple{Individual}","page":"Individuals","title":"GEMS.id","text":"id(individual::Individual)\n\nReturn the unique identifier of the individual.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.infected-Tuple{Individual}","page":"Individuals","title":"GEMS.infected","text":"infected(individual::Individual)\n\nReturns whether an individual is currently infected.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.infection_id-Tuple{Individual}","page":"Individuals","title":"GEMS.infection_id","text":"infection_id(individual::Individual)\n\nReturns an individual's infection_id (currently infected).\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.infectious-Tuple{Individual}","page":"Individuals","title":"GEMS.infectious","text":"infectious(individual::Individual)\n\nReturns whether an individual is currently infectious.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.infectious_tick!-Tuple{Individual, Int16}","page":"Individuals","title":"GEMS.infectious_tick!","text":"infectious_tick!(individual::Individual, tick::Int16)\n\nSets an individual's infectious tick.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.infectious_tick-Tuple{Individual}","page":"Individuals","title":"GEMS.infectious_tick","text":"infectious_tick(individual::Individual)\n\nReturns an individual's infectious tick (currently infected).\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.infectiousness!-Tuple{Individual, Any}","page":"Individuals","title":"GEMS.infectiousness!","text":"infectiousness!(individual::Individual, infectiousness)\n\nAssigns a specified infectiousness (0-127) to an individual.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.infectiousness-Tuple{Individual}","page":"Individuals","title":"GEMS.infectiousness","text":"infectiousness(individual::Individual)\n\nReturns an individual's infectiousness (currently infected).\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.is_student-Tuple{Individual}","page":"Individuals","title":"GEMS.is_student","text":"is_student(individual::Individual)\n\nReturns true if individual is assigned to an  instance of type SchoolClass.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.is_working-Tuple{Individual}","page":"Individuals","title":"GEMS.is_working","text":"is_working(individual::Individual)\n\nReturns true if individual is assigned to an  instance of type Office.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.isdetected-Tuple{Individual}","page":"Individuals","title":"GEMS.isdetected","text":"isdetected(individual::Individual)\n\nReturns true if an individual was currently infected and already reported.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.isquarantined-Tuple{Individual}","page":"Individuals","title":"GEMS.isquarantined","text":"isquarantined(individual::Individual)\n\nReturns wether the individual is in quarantine or not.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.isvaccinated-Tuple{Individual}","page":"Individuals","title":"GEMS.isvaccinated","text":"isvaccinated(individual::Individual)\n\nReturns wether the individual is vaccinated.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.kill!-Tuple{Individual}","page":"Individuals","title":"GEMS.kill!","text":"kill!(individual::Individual)\n\nKills the individual.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.last_reported_at!-Tuple{Individual, Int16}","page":"Individuals","title":"GEMS.last_reported_at!","text":"last_reported_at!(individual::Individual, report_tick::Int16)\n\nSets last tick this individual was last reported.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.last_reported_at-Tuple{Individual}","page":"Individuals","title":"GEMS.last_reported_at","text":"last_reported_at(individual::Individual)\n\nReturns the last tick this individual was a reported case.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.last_test!-Tuple{Individual, Int16}","page":"Individuals","title":"GEMS.last_test!","text":"last_test!(individual::Individual, tick::Int16)\n\nSets last test date (tick).\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.last_test-Tuple{Individual}","page":"Individuals","title":"GEMS.last_test","text":"last_test(individual::Individual)\n\nReturns last test date (tick).\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.last_test_result!-Tuple{Individual, Bool}","page":"Individuals","title":"GEMS.last_test_result!","text":"last_test_result!(individual::Individual, test_result::Bool)\n\nSets last test result.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.last_test_result-Tuple{Individual}","page":"Individuals","title":"GEMS.last_test_result","text":"last_test_result(individual::Individual)\n\nReturns whether last test was positive. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.mandate_compliance!-Tuple{Individual, Float32}","page":"Individuals","title":"GEMS.mandate_compliance!","text":"mandate_compliance!(individual::Individual, val::Float32)\n\nOverwrites the individual's mandate_compliance attribute.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.mandate_compliance-Tuple{Individual}","page":"Individuals","title":"GEMS.mandate_compliance","text":"mandate_compliance(individual::Individual)\n\nReturn an individual's mandate_compliance value.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.municipality-Tuple{Individual, Simulation}","page":"Individuals","title":"GEMS.municipality","text":"municipality(i::Individual, sim::Simulation)::Municipality\n\nReturns the Municipality instance referenced in an individual. \n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.municipality_id-Tuple{Individual}","page":"Individuals","title":"GEMS.municipality_id","text":"municipality_id(individual::Individual)\n\nReturns an individual's associated municipalities ID.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.num_of_infected-Tuple{Vector{Individual}}","page":"Individuals","title":"GEMS.num_of_infected","text":"num_of_infected(individuals::Vector{Individual})\n\nTakes a vector of individuals and returns the number of infected individuals.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.number_of_infections-Tuple{Individual}","page":"Individuals","title":"GEMS.number_of_infections","text":"number_of_infections(individual::Individual)\n\nReturns an individual's number of infections (currently infected).\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.number_of_vaccinations-Tuple{Individual}","page":"Individuals","title":"GEMS.number_of_vaccinations","text":"number_of_vaccinations(individual::Individual)\n\nReturns the number of vaccinations.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.occupation-Tuple{Individual}","page":"Individuals","title":"GEMS.occupation","text":"occupation(individual::Individual)\n\nReturns an individual's occupation class.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.office-Tuple{Individual, Simulation}","page":"Individuals","title":"GEMS.office","text":"office(i::Individual, sim::Simulation)::Office\n\nReturns the Office instance referenced in an individual. \n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.office_id-Tuple{Individual}","page":"Individuals","title":"GEMS.office_id","text":"office_id(individual::Individual)\n\nReturns an individual's associated office's ID.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.onset_of_severeness!-Tuple{Individual, Int16}","page":"Individuals","title":"GEMS.onset_of_severeness!","text":"onset_of_severeness!(individual::Individual, tick::Int16)\n\nSets an individual's tick for the onset of severe symptoms, if it's a severe case.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.onset_of_severeness-Tuple{Individual}","page":"Individuals","title":"GEMS.onset_of_severeness","text":"onset_of_severeness(individual::Individual)\n\nReturns an individual's tick for the onset of severe symptoms, if it's a severe case.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.onset_of_symptoms!-Tuple{Individual, Int16}","page":"Individuals","title":"GEMS.onset_of_symptoms!","text":"onset_of_symptoms!(individual::Individual, tick::Int16)\n\nSets an individual's tick for the onset of symptoms, if symptomatic.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.onset_of_symptoms-Tuple{Individual}","page":"Individuals","title":"GEMS.onset_of_symptoms","text":"onset_of_symptoms(individual::Individual)\n\nReturns an individual's tick for the onset of symptoms, if symptomatic.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.pathogen_id-Tuple{Individual}","page":"Individuals","title":"GEMS.pathogen_id","text":"pathogen_id(individual::Individual)\n\nReturns an individual's pathogen (currently infected).\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.presymptomatic!-Tuple{Individual}","page":"Individuals","title":"GEMS.presymptomatic!","text":"presymptomatic!(individual::Individual)\n\nMarks the individual as asymptomatic, but infectious.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.presymptomatic-Tuple{Individual}","page":"Individuals","title":"GEMS.presymptomatic","text":"presymptomatic(individual::Individual)\n\nReturns if individual is asymptomatic.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.progress_disease!-Tuple{Individual, Int16, Dict}","page":"Individuals","title":"GEMS.progress_disease!","text":"progress_disease!(indiv::Individual, tick::Int16, lookup_dict::Dict = SYMPTOM_CATEGORY_DICT)\n\nProgresses the disease of the (infected) individual. The dictionary lookup_dict can be provided, if custom disease compartements were implemented. The key-value-pairs should  align with the meaning of the parameter disease_state or symptom_category. This means, that if disease_state==1 means \"Asymptomatic\", that status[1]==\"Asymptomatic\".\n\nThis function doesn't kill agents as this is handled a level higher  for the simulation to log deaths.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.quarantine_release_tick!-Tuple{Individual, Int16}","page":"Individuals","title":"GEMS.quarantine_release_tick!","text":"quarantine_release_tick!(individual::Individual, tick::Int16)\n\nSets an individual's quarantine release tick.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.quarantine_release_tick-Tuple{Individual}","page":"Individuals","title":"GEMS.quarantine_release_tick","text":"quarantine_release_tick(individual::Individual)\n\nReturns an individual's quarantine release tick.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.quarantine_status-Tuple{Individual}","page":"Individuals","title":"GEMS.quarantine_status","text":"quarantine_status(individual::Individual)\n\nReturns an individuals quarantine status.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.quarantine_tick!-Tuple{Individual, Int16}","page":"Individuals","title":"GEMS.quarantine_tick!","text":"quarantine_tick!(individual::Individual, tick::Int16)\n\nSets an individual's quarantine tick.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.quarantine_tick-Tuple{Individual}","page":"Individuals","title":"GEMS.quarantine_tick","text":"quarantine_tick(individual::Individual)\n\nReturns an individual's quarantine tick.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.recover!-Tuple{Individual}","page":"Individuals","title":"GEMS.recover!","text":"recover!(individual::Individual)\n\nRecovers the individual from its infection.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.removed_tick!-Tuple{Individual, Int16}","page":"Individuals","title":"GEMS.removed_tick!","text":"removed_tick!(individual::Individual, tick::Int16)\n\nSets an individual's removed tick (currently infected).\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.removed_tick-Tuple{Individual}","page":"Individuals","title":"GEMS.removed_tick","text":"removed_tick(individual::Individual)\n\nReturns an individual's removed tick (currently infected).\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.reset!-Tuple{Individual}","page":"Individuals","title":"GEMS.reset!","text":"reset!(individual::Individual)\n\nResets all non-static values like the disease progression timing. The individual will get back into a state where it was never infected, vaccinated, tested, etc.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.setting_id!-Tuple{Individual, DataType, Int32}","page":"Individuals","title":"GEMS.setting_id!","text":"setting_id!(individual::Individual, type::DataType, id::Int32)\n\nChanges the assigned setting id of the individual for the given type of setting to id.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.setting_id-Tuple{Individual, DataType}","page":"Individuals","title":"GEMS.setting_id","text":"setting_id(individual::Individual, type::DataType)\n\nReturns the id of the setting of type associated with the individual. If the settingtype is unknown or the agent isn't part of a setting of that type, -1 will be returned.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.settings-Tuple{Individual, Simulation}","page":"Individuals","title":"GEMS.settings","text":"settings(individual::Individual, sim::Simulation)\n\nReturn a dictionary with the assigned setting types as keys and the assigned IDs as values.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.severe!-Tuple{Individual}","page":"Individuals","title":"GEMS.severe!","text":"severe!(individual::Individual)\n\nMarks the individual's disease to be severe.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.severe-Tuple{Individual}","page":"Individuals","title":"GEMS.severe","text":"severe(individual::Individual)\n\nReturns wether the individual's disease is severe.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.sex-Tuple{Individual}","page":"Individuals","title":"GEMS.sex","text":"sex(individual::Individual)\n\nReturn an individual's sex.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.social_factor!-Tuple{Individual, Float32}","page":"Individuals","title":"GEMS.social_factor!","text":"social_factor!(individual::Individual, val::Float32)\n\nOverwrites the individual's social_factor attribute.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.social_factor-Tuple{Individual}","page":"Individuals","title":"GEMS.social_factor","text":"social_factor(individual::Individual)\n\nReturns an individual's social_factor value.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.symptom_category!-Tuple{Individual, Int8}","page":"Individuals","title":"GEMS.symptom_category!","text":"symptom_category!(individual::Individual, category::Int8)\n\nSets an infected individuals symptom_category.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.symptom_category-Tuple{Individual}","page":"Individuals","title":"GEMS.symptom_category","text":"symptom_category(individual::Individual)\n\nReturns an infected individual's symptom category.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.symptomatic!-Tuple{Individual}","page":"Individuals","title":"GEMS.symptomatic!","text":"symptomatic!(individual::Individual)\n\nMarks the individual as symptomatic.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.symptomatic-Tuple{Individual}","page":"Individuals","title":"GEMS.symptomatic","text":"symptomatic(individual::Individual)\n\nReturns wether the individual is symptomatic.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.vaccination_tick-Tuple{Individual}","page":"Individuals","title":"GEMS.vaccination_tick","text":"vaccination_tick(individual::Individual)\n\nReturns the time of last vaccination.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.vaccine_id-Tuple{Individual}","page":"Individuals","title":"GEMS.vaccine_id","text":"vaccine_id(individual::Individual)\n\nReturns the id of the vaccine the individual is vaccinated with.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.ventilate!-Tuple{Individual}","page":"Individuals","title":"GEMS.ventilate!","text":"ventilate!(individual::Individual)\n\nSets the individual to require ventilation.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.ventilated-Tuple{Individual}","page":"Individuals","title":"GEMS.ventilated","text":"ventilated(individual::Individual)\n\nReturns wether the individual needs ventilation.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.ventilation_tick!-Tuple{Individual, Int16}","page":"Individuals","title":"GEMS.ventilation_tick!","text":"ventilation_tick!(individual::Individual, tick::Int16)\n\nSets an individual's tick for when it gets ventilated.\n\n\n\n\n\n","category":"method"},{"location":"api_individuals/#GEMS.ventilation_tick-Tuple{Individual}","page":"Individuals","title":"GEMS.ventilation_tick","text":"ventilation_tick(individual::Individual)\n\nReturns an individual's tick when it gets ventilated.\n\n\n\n\n\n","category":"method"},{"location":"tut_postprocessing/#7-Logging-and-Post-Processing","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"","category":"section"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"GEMS offers a variety of options to collect data during simulation runs and process them to obtain aggregated statistics. This tutorial teaches you how to access the data and customize how data is being collected and processed.","category":"page"},{"location":"tut_postprocessing/#Internal-Loggers","page":"7 - Logging & Post-Processing","title":"Internal Loggers","text":"","category":"section"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"Accessing a simulation's internal loggers is easy. They can be accessed via infectionlogger(sim),  deathlogger(sim),  testlogger(sim),  pooltestlogger(sim),  quarantinelogger(sim),  or customlogger(sim). Here's the data that is being logged for all infections:","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"using GEMS\nsim = Simulation()\nrun!(sim)\ninf_logger = infectionlogger(sim)\ndataframe(inf_logger)","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"Output","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"[ Info: 23:40:26 | Initializing Simulation [Simulation 79] with default configuration \n[ Info: 23:40:26 | └ Creating population\n[ Info: 23:40:28 | └ Creating simulation object\n[ Info: 23:40:29 | Running Simulation Simulation 79\n100.0%┣████████████████████████████████████████┫ 365 days/365 days [00:29<00:00, 13 days/s]\n75908×19 DataFrame\n   Row │ infection_id  tick   id_a   id_b   infectious_tick  removed_tick  death_tick  ⋯\n       │ Int32         Int16  Int32  Int32  Int16            Int16         Int16       ⋯\n───────┼───────────────────────────────────────────────────────────────────────────────────\n     1 │            1      0     -1  74571                5            13          -1   ⋯         \n     2 │            2      0     -1  48307                1             7          -1   ⋯  \n   ⋮   │      ⋮          ⋮      ⋮      ⋮           ⋮              ⋮            ⋮             ⋮ \n 75907 │        75907    177   4685  36171              177           183          -1   ⋯ \n 75908 │        75908    181   4685  33557              185           191          -1   ⋯  \n                                                        10 columns and 75904 rows omitted","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"info: Where can I find out what these columns mean?\nPut a ? into the Julia REPL and call help?> dataframe(::InfectionLogger) to get an overview of the columns that are available in the InfectionLogger's dataframe. Replace the argument ::InfectionLogger with any of the other logger types to see their descriptions or look up the Logger section in the API documentation.","category":"page"},{"location":"tut_postprocessing/#The-PostProcessor","page":"7 - Logging & Post-Processing","title":"The PostProcessor","text":"","category":"section"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"The PostProcessor is the binding element between the raw data coming from the simulation's internal loggers and the ResultData object. It is instantiated with the Simulation object and performs some initial operations and joins on the raw data, and stores the results in internal dataframes (infectionsDF, populationDF, deathsDF, testsDF, pooltestsDF, quarantinesDF). An exception is the sim_infectionsDF-dataframe which only contains infections that happend during the simulation, exluding all initial, seeding infections. This example shows how the PostProcessor's internal infections-dataframe is already joined with data from the population-dataframe:","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"using GEMS\nsim = Simulation()\nrun!(sim)\npp = PostProcessor(sim)\n\ninfectionsDF(pp)","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"Output","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"[ Info: 23:41:39 | Initializing Simulation [Simulation 80] with default configuration \n[ Info: 23:41:39 | └ Creating population\n[ Info: 23:41:40 | └ Creating simulation object\n[ Info: 23:41:41 | Running Simulation Simulation 80\n100.0%┣█████████████████████████████████████████┫ 365 days/365 days [00:57<00:00, 6 days/s]\n75798×47 DataFrame\nRow │ infection_id  tick   id_a   id_b    infectious_tick  removed_tick  ⋯\n    │ Int32         Int16  Int32  Int32   Int16            Int16         ⋯\n    ┼────────────────────────────────────────────────────────────────────────\n  1 │         7180     36  61265       1               38            44  ⋯    \n  2 │        71586     88  77749       2               91            98  ⋯\n⋮     │        ⋮          ⋮      ⋮      ⋮                 ⋮              ⋮      \n75798 │        42048     60  61117  100000             64            72  ⋯      \n38 columns and 75794 rows omitted","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"You might have noticed, that this dataframe contains characteristics about the infecting and infected individuals (e.g., age or sex) or whether they were detected. It is now much easier to use this data to calculate more sophisticated statistics such as an age-age contact matrix for infections. Many processing functions are already available. Here's how you can calculate the effective reproduction rate per time unit using the PostProcessor:","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"using GEMS\nsim = Simulation()\nrun!(sim)\npp = PostProcessor(sim)\n\neffectiveR(pp)","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"Output","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"[ Info: 23:43:16 | Initializing Simulation [Simulation 81] with default configuration \n[ Info: 23:43:16 | └ Creating population\n[ Info: 23:43:18 | └ Creating simulation object\n[ Info: 23:43:19 | Running Simulation Simulation 81\n100.0%┣█████████████████████████████████████████┫ 365 days/365 days [01:25<00:00, 4 days/s]\n365×7 DataFrame\n Row │ tick   effective_R  in_hh_effective_R  out_hh_effective_R  rolling_R   ⋯  \n     │ Int64  Float64      Float64            Float64             Float64     ⋯  \n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │     1      2.21429           0.571429            1.64286     2.21429   ⋯  \n   2 │     2      1.45833           0.541667            0.916667    1.83631   ⋯  \n  ⋮  │   ⋮         ⋮               ⋮                  ⋮               ⋮           \n 364 │   364      0.0               0.0                 0.0         0.0       ⋯  \n 365 │   365      0.0               0.0                 0.0         0.0       ⋯  \n361 rows omitted","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"info: Where's the list of availble post-processing functions?\nLook up the Post-Processor section in the API documentation for a full list of available options.","category":"page"},{"location":"tut_postprocessing/#Custom-Post-Processing","page":"7 - Logging & Post-Processing","title":"Custom Post-Processing","text":"","category":"section"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"In some cases, you might want to add custom functionalities to the PostProcessor. The following example add a new post-processor function that calculates the number of infections where a older person infected a younger person:","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"using GEMS, DataFrames\n\nfunction old_infects_young(pp::PostProcessor)\n    infs = sim_infectionsDF(pp) # load the simulated infections\n    filtered = infs[infs.age_a .> infs.age_b, :] # filter for Age A > Age B\n    grouped = groupby(filtered, :tick) # group by simulation time (tick)\n    res = combine(grouped, nrow => :count) # combine count\n    return res\nend\n\nsim = Simulation()\nrun!(sim)\npp = PostProcessor(sim)\n\nold_infects_young(pp)","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"Output","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"[ Info: 23:45:19 | Initializing Simulation [Simulation 82] with default configuration \n[ Info: 23:45:19 | └ Creating population\n[ Info: 23:45:21 | └ Creating simulation object\n[ Info: 23:45:22 | Running Simulation Simulation 82\n100.0███████████████████████████████████████████┫ 365 days/365 days [00:54<00:00, 7 days/s]\n143×2 DataFrame\n Row │ tick   count \n     │ Int16  Int64\n─────┼──────────────\n   1 │     0      3\n   2 │     1      7\n   ⋮  │   ⋮      ⋮\n 142 │   155      1\n 143 │   171      1\n    139 rows omitted","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"We advise doing any post-processing via the PostProcessor infrastructure whenever possible, as this will make it very easy to forward you custom results to a custom ResultData object. These things will be explained in the subsequent sections.","category":"page"},{"location":"tut_postprocessing/#The-ResultData-object","page":"7 - Logging & Post-Processing","title":"The ResultData object","text":"","category":"section"},{"location":"tut_postprocessing/#Custom-ResultDataStyles","page":"7 - Logging & Post-Processing","title":"Custom ResultDataStyles","text":"","category":"section"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"how to get custom post-processing functions in here?","category":"page"},{"location":"tut_postprocessing/#Custom-Loggers","page":"7 - Logging & Post-Processing","title":"Custom Loggers","text":"","category":"section"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"A lot of data is recorded automatically, i.e., infections or deaths. If you want to collect data during the simulation run that is not available via the default loggers, you can add custom mechanics. The example below tracks how many infected individuals live in households that have 3 or more members. Doing so requires to set up a CustomLogger(...). It takes an arbitrary number of arguments that must be one-argument functions whereas the argument has to be the simulation object. These functions are called once every step when running a simulation.","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"using GEMS\nsim = Simulation()\n\nfunction logging_func(sim)\n    cnt = 0 # counting variable\n    inds = individuals(sim)\n    for i in inds\n        h = household(i, sim)\n        if infected(i) && size(h) >= 3\n            cnt += 1\n        end\n    end\n    return cnt\nend\n\ncl = CustomLogger(infected_in_large_households = logging_func)\ncustomlogger!(sim, cl)\n\nrun!(sim)\nrd = ResultData(sim)\n\ngemsplot(rd, type = (:TickCases, :CustomLoggerPlot))","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"Plot","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_pp_plot.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"The ResultData object now contains a dataframe that contains the collected data of the custom logger with one column per argument function that was passed to the CustomLogger(...)","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"customlogger(rd)","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"Output","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"365×2 DataFrame\n Row │ infected_in_large_households  tick \n     │ Any                           Any\n─────┼────────────────────────────────────\n   1 │ 82                            0\n   2 │ 92                            1\n  ⋮  │              ⋮                 ⋮\n 364 │ 0                             363\n 365 │ 0                             364\n                          361 rows omitted","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"You might have noticed, that loggers can severely slow down the simulation runtime if implemented inefficiently as they are executed in every step and potentially require iterations through all individuals every time. Julia provides a number of handy techniques that can speed up calculations significantly. If you feel confident using so-called lambda-functions, you can rewrite the above example to prevent unnecessary memory allocations. The code below does exactly the same as the code above, but takes a fraction of the time. ","category":"page"},{"location":"tut_postprocessing/","page":"7 - Logging & Post-Processing","title":"7 - Logging & Post-Processing","text":"using GEMS\nsim = Simulation()\n\npred_func(i, sim) = infected(i) && size(household(i, sim)) >= 3\n\ncl = CustomLogger(infected_in_large_households =\n    sim -> count(i -> pred_func(i, sim), population(sim)))\ncustomlogger!(sim, cl)\n\nrun!(sim)\nrd = ResultData(sim)\n\ngemsplot(rd, type = (:TickCases, :CustomLoggerPlot))","category":"page"},{"location":"api_postproc/#Post-processing","page":"Post Processing","title":"Post processing","text":"","category":"section"},{"location":"api_postproc/#Overview-Structs","page":"Post Processing","title":"Overview Structs","text":"","category":"section"},{"location":"api_postproc/","page":"Post Processing","title":"Post Processing","text":"Pages   = [\"api_postproc.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_postproc/#Overview-Functions","page":"Post Processing","title":"Overview Functions","text":"","category":"section"},{"location":"api_postproc/","page":"Post Processing","title":"Post Processing","text":"Pages   = [\"api_postproc.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_postproc/#Structs","page":"Post Processing","title":"Structs","text":"","category":"section"},{"location":"api_postproc/#GEMS.PostProcessor","page":"Post Processing","title":"GEMS.PostProcessor","text":"PostProcessor\n\nA type to provide data processing features supplying reports, plots, or other data analyses.\n\nInternal Fields\n\nsimulation::Simulation: Simulation object\ninfectionsDF::DataFrame: Infections (joined with popuation to get information on infeter and infectee)\npopulationDF::DataFrame: Population dataframe with one row per individual\nvaccinationsDF::DataFrame: Output of the vaccination logger \ndeathsDF::DataFrame: Output of the death logger\ntestsDF::DataFrame: Output of the test logger\npooltestsDF::DataFrame: Output of the pool test logger\nquarantinesDF::DataFrame: Output of th quarantine logger\ncache::Dict{String, Any}: Internal cache to store and retrieve intermediate results\n\n\n\n\n\n","category":"type"},{"location":"api_postproc/#Constructors","page":"Post Processing","title":"Constructors","text":"","category":"section"},{"location":"api_postproc/#GEMS.PostProcessor-Tuple{Simulation}","page":"Post Processing","title":"GEMS.PostProcessor","text":"PostProcessor(simulation::Simulation)\n\nCreate a PostProcessor object for an associated Simulation. Post Processing requires a simulation to be done.\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.PostProcessor-Tuple{Vector{Simulation}}","page":"Post Processing","title":"GEMS.PostProcessor","text":"PostProcessor(simulations::Vector{Simulation})\n\nCreate a vector of PostProcessor objects for a vector of associated Simulation objects. Post Processing requires all simulations to be done.\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.PostProcessor-Tuple{Batch}","page":"Post Processing","title":"GEMS.PostProcessor","text":"PostProcessor(batch::Batch)\n\nCreate a vector of PostProcessor objects for all Simulations in a Batch. Post Processing requires all simulations to be done.\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#Functions","page":"Post Processing","title":"Functions","text":"","category":"section"},{"location":"api_postproc/#GEMS.age_incidence","page":"Post Processing","title":"GEMS.age_incidence","text":"age_incidence(postProcessor::PostProcessor, timespan::Int64, basesize::Int64)\n\nReturns a DataFrame containing the infection incidence stratified by (10-year) age groups. The timespan parameter defines a time window in ticks and the basesize parameter defines the reference population size to calculate incidences. Assuming 1 tick to be 1 day, a timespan = 7 and basesize = 100_000 configuration results in the commonly known seven-day incidence per 100,000.\n\nThe structure assumes no individuals exceeding the age of 100.\n\nParameters\n\npostProcessor::PostProcessor: Post processor instance\ntimespan::Int64: Reference time window to calculate incidence\nbasesize::Int64: Reference population size to calculate incidence\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\ntotal Float64 Total incidence\na0_10 Float64 Incidence in age cohort 0-10\na11_20 Float64 Incidence in age cohort 11-20\na21_30 Float64 Incidence in age cohort 21-30\na31_40 Float64 Incidence in age cohort 31-40\na41_50 Float64 Incidence in age cohort 41-50\na51_60 Float64 Incidence in age cohort 51-60\na61_70 Float64 Incidence in age cohort 61-70\na71_80 Float64 Incidence in age cohort 71-80\na81_90 Float64 Incidence in age cohort 81-90\na91_100 Float64 Incidence in age cohort 91-100\n\n\n\n\n\nage_incidence(rd::ResultData)\n\nReturns a DataFrame with incidence over time stratified by age groups. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"function"},{"location":"api_postproc/#GEMS.attack_rate-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.attack_rate","text":"attack_rate(postProcessor::PostProcessor)\n\nDivides the number of individuals who have been infected one (or multiple) time(s) by the total number of individuals.\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.compartment_fill-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.compartment_fill","text":"compartment_fill(postProcessor::PostProcessor)\n\nReturns a DataFrame containing the total count of infected individuals in the respective disease states exposed, infectious, deceased and recovered.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\nexposed_cnt Int64 Total number of individuals in the exposed state\ninfectious_cnt Int64 Total number of individuals in the infectious state\nrecovered_cnt Int64 Total number of individuals in the recovered state\ndeaths_cnt Int64 Total number of individuals in the deceased state\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.compartment_periods-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.compartment_periods","text":"compartment_periods(postProcessor::PostProcessor)\n\nCalculates the durations of the disease compartments of all infections and returns a DataFrame containing all additional infectee-related information.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ninfection_id Int32 Infectee id\ntotal Int16 Total duration of infection in ticks\nexposed Int16 Duration of the exposed period in ticks\ninfectious Int16 Duration of the infectious period in ticks\npre_symptomatic Int16 Duration of the pre-symptomatic period in ticks\nasymptomatic Int16 Duration of the asymptomatic period in ticks\nsymptomatic Int16 Duration of the symptomatic period in ticks\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.cumulative_cases-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.cumulative_cases","text":"cumulative_cases(postProcessor::PostProcessor)\n\nReturns a DataFrame containing the cumulative infections count of infected individuals in the respective disease states exposed, infectious, and removed.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\nexposed_cum Int64 Total number of individuals in the exposed state\ninfectious_cum Int64 Total number of individuals in the infectious state\nremoved_cum Int64 Total number of individuals in the removed state\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.cumulative_deaths-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.cumulative_deaths","text":"cumulative_deaths(postProcessor::PostProcessor)\n\nReturns a DataFrame containing the total count of individuals that died.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\ndeaths_cum Int64 Total number of individuals that have died until now\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.cumulative_disease_progressions-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.cumulative_disease_progressions","text":"cumulative_disease_progressions(postProcessor::PostProcessor)\n\nCalculates the accumulated number of individuals in a certain disease state (latent, presymptomatic, symptomatic and asymptomatic) after the  individual has been infected. Rows indicate the number of elapsed ticks since infections.\n\nExample: Row 8 showing [20, 47, 290, 50] would mean that eight ticks after exposure, 20 individuals were latent, 47 were presymptomatic  (no symptoms yet, but will be developing), 290 had symptoms and  50 are not experiencing symptoms and won't ever do.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\nlatent Int64 Number of latent individuals X ticks after exposure\npre_symptomatic Int64 Number of pre-symptomatic individuals X ticks after exposure\nsymptomatic Int64 Number of symptomatic individuals X ticks after exposure\nasymptomatic Int64 Number of asymptomatic individuals X ticks after exposure\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.cumulative_quarantines-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.cumulative_quarantines","text":"cumulative_quarantines(postProcessor::PostProcessor)\n\nReturns a DataFrame containing cumulative information about days spent in isolation. \n\nColumns\n\nName Type Description\ntick Int16 Simulation tick (time)\nquarantined Int64 Total number of individuals in isolation during that tick\nstudents Int64 Total number of students in isolation during that tick\nworkers Int64 Total number of workers in isolation during that tick\nother Int64 Total number of non-students and -workers in isolation during that tick\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.deathsDF-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.deathsDF","text":"deathsDF(postProcessor::PostProcessor)\n\nReturns the internal flat deaths DataFrame.\n\nColumns\n\nName Type Description\ntick Int16 Tick of the death event\nid Int32 Individual's id\nsex Int8 Individual's sex\nage Int8 Individual's age\neducation Int8 Individual's education level\noccupation Int16 Individual's occupation group\nhousehold Int32 Individual's associated household\noffice Int32 Individual's associated office\nschool Int32 Individual's associated school\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.detected_infections-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.detected_infections","text":"detected_infections(postProcessor::PostProcessor)\n\nA subset of the infections dataframe with only the detected cases. An infection is considered to be detected if the infection has a non-missing first_detected_tick. For the column definitions, look up the infectionsDF(postProcessor) documentation.\n\nReturns\n\nDataFrame: Please look up the column definitions in the infectionsDF(postProcessor) documentation.\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.detected_tick_cases-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.detected_tick_cases","text":"detected_tick_cases(postProcessor::PostProcessor)\n\nReturns the number of detected cases per tick and the number of true new exposures. This analysis is based on the tick_test column of the infections-dataframe  which indicates when an individual with an active infection was first tested positive. Thus, there might be a delay between exposure_cnt and detected_cnt.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\ntotal_reported_cases Int64 Total number of reported cases at that tick\nnew_detections Int64 Number of true new detected cases at that tick (not known before)\ndouble_reports Int64 Number of cases that were reported at that tick but were known before\nfalse_positives Int64 Number of false positive reports at that tick\nexposed_cnt Int64 Number of new infections at that tick\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.detection_rate-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.detection_rate","text":"detection_rate(postProcessor::PostProcessor)\n\nReturns the fraction of detected cases.\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.effectiveR-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.effectiveR","text":"effectiveR(postProcessor::PostProcessor)\n\nReturns a DataFrame containing the effective R value for each tick.\n\nFor each infectee, this method looks ahead for secondary infections this individual might cause during the total span of the simulation. These infections are then counted towards the R-value of the initial infection. If individual A, for example, is infected at time 42 and causes four secondary infections  during the next 14 ticks, these four infections are counted towards the R-value of time 42.\n\nNote: This only works in scenarios without re-infection as the current implementation just evaluates the total infections caused by each individual in general. If an individual was infected multiple times, secondary infections will inflate the statistic.\n\nReturns\n\nDataframe with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\neffective_R Float64 Effective R-value\nrolling_R Float64 Effective R rolling average of the 7 previous ticks\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.hospital_df-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.hospital_df","text":"hospital_df(postProcessor::PostProcessor)\n\nCreates a DataFrame that includes information about the current hospitalizations etc.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\nhospital_cnt Int64 New hospitalizations per tick\nhospital_releases Int64 Hospital releases per tick\nicu_cnt Int64 New ICU admissions per tick\nicu_releases Int64 ICU releases per tick\nventilation_cnt Int64 New ventilations per tick\nventilation_releases Int64 Ventilation stops\ncurrent_hospitalized Int64 Number of currently hospitalized agents\ncurrent_icu Int64 Number of agents currently in the ICU\ncurrent_ventilation Int64 Number of currently ventilated agents\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.household_attack_rates-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.household_attack_rates","text":"household_attack_rates(postProcessor::PostProcessor; hh_samples::Int64 = HOUSEHOLD_ATTACK_RATE_SAMPLES)\n\nReturns a DataFrame containing data on the in-household attack rate. The in-household attack rate is defined as the fraction of individuals in a given household that got infected within the household (in-household infection chain) caused by the first introduction of  the pathogen in this household. It does not reflect overall fraction of individuals that were infected in this household throughout the course of the simuation. As the attack rate calculation is very  computationally intensive, it is not done for all household but rather  for a subset of households. You can change the desired subset size through the optional hh_samples argument. Its default can be found in constants.jl\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\nfirst_introduction Int16 Time of when the first member of the respective household was exposed\nhh_id Int32 Household setting identifier\nhh_size Int16 Household size\nchain_size Int32 Number of individuals that got infected within the household\nhh_attack_rate Float64 Number of infected individuals divided by household size\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.individuals_per_age_group","page":"Post Processing","title":"GEMS.individuals_per_age_group","text":"individuals_per_age_group(post_processor::PostProcessor, interval_steps::Int64)\n\nThe population in populationDF will be splitted in age groups of size interval_steps and the number of individuals per age group is counted.\n\nThe input DataFrame already needs a column called \"sum\" where the sum of individuals in this age is stored.\n\nReturns\n\nreturns a DataFrame with the follwing structure:\n\nName Type Description\nage_group String Min and Max age in this age group\nnum_individuals Int64 Total number of individuals\n\n\n\n\n\nindividuals_per_age_group(post_processor::PostProcessor, interval_steps::Int64, aggregation_bound::Int64)\n\nThe the population in populationDF will be splitted in age groups of size interval_steps and the number of individuals per age group is counted. The splitting is capped at aggregation_bound.\n\nThe input DataFrame already needs a column called \"sum\" where the sum of individuals in this age is stored.\n\nReturns\n\nreturns a DataFrame with the follwing structure:\n\nName Type Description\nage_group String Min and Max age in this age group\nnum_individuals Int64 Total number of individuals\n\n\n\n\n\n","category":"function"},{"location":"api_postproc/#GEMS.infections-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.infections","text":"infections(postProcessor::PostProcessor)\n\nReturns the internal flat infections DataFrame.\n\nColumns\n\nName Type Description\ninfection_id Int32 Unique identifier of an infection\ntick Int16 Tick of the infection event\nid_a Int32 Infecter id\nid_b Int32 Infectee id\ninfectious_tick Int16 Tick at which infectee becomes infectious\nremoved_tick Int16 Tick at which infectee becomes removed (recovers)\nsymptoms_tick Int16 Tick at which infectee develops symptoms\nsevereness_tick Int16 Tick at which infectee's symptoms become severe\nhospital_tick Int16 Tick at which infectee is hospitalized\nicu_tick Int16 Tick at which infectee is admitted to ICU\nventilation_tick Int16 Tick at which infectee requires ventilation\nsymptom_category Int8 Disease progression category (asymp., mild, severe, critical)\nsetting_id Int32 Id of setting in which infection happens\nsetting_type Char Setting type of the infection setting\nlat Float32 Latitude of infection location\nlon Float32 Longitude of infection location\nags Int32 German Community Identification Number of infection\nsource_infection_id Int32 ID of the infection even that caused this infection (chain)\ngeneration_time Int16 Time between preceeding infection and this exposure\nserial_interval Int16 Time between onset of symptoms of this and preceeding infection\ntest_type String Type of test which detected this infection\nfirst_detected_tick Int16 Tick of (reportable) test that first detected this infection\nsex_a Int8 Infecter sex\nage_a Int8 Infecter age\nnumber_of_vaccinations_a Int8 Infecter number of previous vaccinations\nvaccination_tick_a Int16 Infecter last time of vaccination\neducation_a Int8 Infecter education level\noccupation_a Int16 Infecter occupation group\nhousehold_a Int32 Infecter associated household\noffice_a Int32 Infecter associated office\nschoolclass_a Int32 Infecter associated school\nsex_b Int8 Infectee sex\nage_b Int8 Infectee age\nnumber_of_vaccinations_a Int8 Infecter number of previous vaccinations\nvaccination_tick_a Int16 Infecter last time of vaccination\neducation_b Int8 Infectee education level\noccupation_b Int16 Infectee occupation group\nhousehold_b Int32 Infectee associated household\noffice_b Int32 Infectee associated office\nschoolclass_b Int32 Infectee associated schoolclass\nhousehold_ags_b Int32 Infectee household German Community Identification Number\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.infectionsDF-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.infectionsDF","text":"infectionsDF(postProcessor::PostProcessor)\n\nReturns the internal flat infections DataFrame. Lookup the docstring of infections(postProcessor::PostProcessor) for column definitions.\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.observed_R-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.observed_R","text":"observed_R(postProcessor::PostProcessor)\n\nReturns a DataFrame containing estimations for the effective (current) reproduction number R, based on detected infections. The calculation uses the  estimation for the (rolling) observed serial interval (SI) and the total of detected cases within a time window of the length defined in R_ESTIMATION_TIME_WINDOW (lookup constants.jl) ending with a current tick t. It divides the total detected infections in the current time window with the total detected infections in the time window that lies one SI behind. The function does this for the mean estimate of the serial interval as well as the (floored) lower-95% confidence bound and the (ceiled) upper-95% confidence bound.\n\nExample\n\nFor tick t = 42 and\nGiven the R_ESTIMATION_TIME_WINDOW = 7, and\nThe rolling observed serial interval being 4,\nThis function does: sum(infections[35:42]) / sum(infections[31:38])\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\nmean_est_R Float64 Mean estimation (based on detected infections) for R\nlower_est_R Float64 Lower bound estimation (based on detected infections) for R\nupper_est_R Float64 Upper bound estimation (based on detected infections) for R\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.pooltestsDF-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.pooltestsDF","text":"pooltestsDF(postProcessor::PostProcessor)\n\nReturns the internal flat pool tests DataFrame.\n\nColumns\n\nName Type Description\ntest_tick Int16 Tick of the test event\nsetting_id Int32 Setting id of the tested pool\nsetting_type Int32 Setting type\ntest_result Bool Test result (pos./neg.)\nno_of_individuals Int32 Number of tested individuals\nno_of_infected Int32 Number of actually infected individuals\ntest_type String Name of test type\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.populationDF-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.populationDF","text":"populationDF(postProcessor)\n\nReturns the internal flat population DataFrame.\n\nColumns\n\nName Type Description\nid Int32 Individual id\nsex Int8 Individual sex\nage Int8 Individual age\neducation Int8 Individual education level\noccupation Int16 Individual occupation group\nhousehold Int32 Individual associated household\noffice Int32 Individual associated office\nschool Int32 Individual associated school\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.population_pyramid-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.population_pyramid","text":"population_pyramid(postProcessor::PostProcessor)\n\nReturns a DataFrame containing data to generate a population pyramid. It provides the sum of all female and male individuals in all age groups in the population model. Sums for female are multiplied by -1 to facilitate visualization.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\nage Int8 1-year age classes\nsex Int8 Sex according to population DataFame (0 = female, 1 = male)\ngender String String variant of Sex [Female, Male]\nsum Int64 Total of all genders in all ages (females multiplied by -1)\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.reported_tick_cases-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.reported_tick_cases","text":"reported_tick_cases(postProcessor::PostProcessor)\n\nReturns the number of reported positive test cases per tick. This analysis is based on the testDF dataframe.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\nreported_cnt Int64 Number of newly reported infections (positive reportable tests) at that tick\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.rolling_observed_SI-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.rolling_observed_SI","text":"rolling_observed_SI(postProcessor::PostProcessor)\n\nReturns a DataFrame containing aggregated estimations on the serial interval based on true detected cases. The estimations are based on all true detected cases in a 14-past-days time window. If fewer than 50 infections were recorded in that time window, detections prior to that are added until the sample is complete. This is done in order to reduce large stochastic fluctuations due to small sample size.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\nmin_SI Int16 Minimal serial interval recored for any infection that tick\nmax_SI Int16 Maximum serial interval recored for any infection that tick\nlower_95_SI Float64 Lower 95% confidence interval for serial intervals that tick\nupper_95_SI Float64 Upper 95% confidence interval for serial intervals that tick\nstd_SI Float64 Stanard deviation for serial intervals that tick\nmean_SI Float64 Mean for serial intervals that tick\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.setting_sizes-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.setting_sizes","text":"setting_sizes(postProcessor::PostProcessor)\n\nReturns a Dictionary containing information about size of the settings. The keys are equal to the settingtypes and the values correspond to a countmap of the setting sizes.\n\nReturns\n\nDict{String, Dict{Int64, Int64}}: Nested dictionary where the first key is the    name of the setting type (e.g., \"Household\") and the innter dictionary is a   countmap with the key being a setting size (e.g., 5) and the value the number of occurences.\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.settingdata-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.settingdata","text":"settingdata(postProcessor::PostProcessor)\n\nReturns a DataFrame containing information about setting types\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\nsetting_type String Setting type identifier (name)\nnumber_of_settings Int64 Overall number of settings of that type\nmin_individuals Float64 Lowest number of individuals assigned to a setting of this type\nmax_individuals Float64 Highest number of individuals assigned to a setting of this type\navg_individuals Float64 Average number of individuals assigned to a setting of this type\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.sim_infectionsDF-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.sim_infectionsDF","text":"sim_infectionsDF(postProcessor::PostProcessor)\n\nReturns a DataFrame containing all infections that happened during the simulation run. As it is a direct filter on the PostProcessors internal infectionsDF, the column structure is identical to the output of infectionsDF(postProcessor)\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.simulation-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.simulation","text":"simulation(postProcessor::PostProcessor)\n\nReturns the associated Simulation object.\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.testsDF-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.testsDF","text":"testsDF(postProcessor::PostProcessor)\n\nReturns the internal flat tests DataFrame. It was joined with the population dataframe to also obtain personal characteristics about the testees.\n\nColumns\n\nName Type Description\ntest_tick Int16 Tick of the test event\nid Int32 Individual's id\ntest_result Bool Test result\ninfected Bool Individual's current infection state\ninfection_id Int32 Individual's infection id\ntest_type String Test name\nreportable Bool If true, a positive test result will be \"reported\"\nsex Int8 Individual's sex\nage Int8 Individual's age\nnumber_of_vaccinations Int8 Individual's number of vaccinations\nvaccination_tick Int16 Tick when the individual was last vaccinated\neducation Int8 Individual's education level\noccupation Int16 Individual's occupation group\nhousehold Int32 Individual's associated household\noffice Int32 Individual's associated office\nschool Int32 Individual's associated school\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.tick_cases-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.tick_cases","text":"tick_cases(postProcessor::PostProcessor)\n\nReturns a DataFrame containing the count of individuals currently entering in the respective disease states exposed, infectious, and removed.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\nexposed_cnt Int64 Number of individuals entering the exposed state\ninfectious_cnt Int64 Number of individuals entering the infectious state\nremoved_cnt Int64 Number of individuals entering the removed state\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.tick_cases_per_setting-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.tick_cases_per_setting","text":"tick_cases_per_setting(postProcessor::PostProcessor)\n\nReturns a DataFrame containing information about the infections in different setting types\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Current tick of the simulation\nsetting_type String Setting type identifier (name)\ndaily_cases Int64 Cases for setting and tick\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.tick_deaths-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.tick_deaths","text":"tick_deaths(postProcessor::PostProcessor)\n\nReturns a DataFrame containing the count of individuals that died per tick.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\ndeath_cnt Int64 Number of individuals that dies\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.tick_generation_times-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.tick_generation_times","text":"tick_generation_times(postProcessor::PostProcessor)\n\nReturns a DataFrame containing aggregated information on the generation time per tick.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\nmin_generation_time Int16 Minimal generation time recored for any infection that tick\nmax_generation_time Int16 Maximum generation time recored for any infection that tick\nlower_95_generation_time Float64 Lower 95% confidence interval for generation times that tick\nupper_95_generation_time Float64 Upper 95% confidence interval for generation times that tick\nstd_generation_time Float64 Stanard deviation for generation times that tick\nmean_generation_time Float64 Mean for generation times that tick\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.tick_pooltests-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.tick_pooltests","text":" tick_pooltests(postProcessor::PostProcessor)\n\nReturns a Dict for each employed test_type containing their name as a key and a DataFrame containing the number of applied pool tests (positive/negative/total) per tick.\n\nReturns\n\nDict{String, DataFrame}: The key is the TestType's name.   The values are DataFrames with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\npositive_tests Int64 Number of positive tests\nnegative_tests Int64 Number of negative tests\ntotal_tests Int64 Number of tests performed\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.tick_serial_intervals-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.tick_serial_intervals","text":"tick_serial_intervals(postProcessor::PostProcessor)\n\nReturns a DataFrame containing aggregated information on the serial interval per tick.\n\nReturns\n\nDataFrame with the follwing columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\nmin_SI Int16 Minimal serial interval recored for any infection that tick\nmax_SI Int16 Maximum serial interval recored for any infection that tick\nlower_95_SI Float64 Lower 95% confidence interval for serial intervals that tick\nupper_95_SI Float64 Upper 95% confidence interval for serial intervals that tick\nstd_SI Float64 Stanard deviation for serial intervals that tick\nmean_SI Float64 Mean for serial intervals that tick\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.tick_tests-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.tick_tests","text":"tick_tests(postProcessor::PostProcessor)\n\nReturns a Dict for each employed test_type containing their name as a key and a DataFrame containing the count of individuals that got tested (positive/negative) as well as the people reported positive for the first time per tick.\n\nReturns\n\nDict{String, DataFrame}: The key is the TestType's name.   The values are DataFrames with the following columns:\n\nName Type Description\ntick Int16 Simulation tick (time)\nreported_cases Int16 Number cases tested positive for the first time\npositive_tests Int64 Number of positive tests\nnegative_tests Int64 Number of negative tests\ntotal_tests Int64 Number of tests performed\npositive_rate Float64 Fraction of positive tests\nrolling_positive_rate Float64 Positive rate rolling average of the 7 previous ticks\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.time_to_detection-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.time_to_detection","text":"time_to_detection(postProcessor::PostProcessor)\n\nReturns the mean, standard deviation, minimum, maximum, upper- and lower 95% confidence intervals of the time to detection for all detected cases. The time to detection is defined as the  number of ticks between the time of exposure and time of detection. \n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int64 Simulation tick (time)\nmean_time_to_detection Int64 Mean time to detection at that tick\nstd_time_to_detection Int64 Standard deviation of time to detection at that tick\nmin_time_to_detection Int64 Minimum time to detection at that tick\nmax_time_to_detection Int64 Maximum time to detection at that tick\nupper_95_time_to_detection Int64 Upper 95% confidence interval of time to detection at that tick\nlower_95_time_to_detection Int64 Lower 95% confidence interval of time to detection at that tick\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.total_detected_cases-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.total_detected_cases","text":"total_detected_cases(postProcessor::PostProcessor)\n\nReturns the total number of detected cases.\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.total_quarantines-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.total_quarantines","text":"total_quarantines(postProcessor::PostProcessor)\n\nReturns the total number of total ticks spent in quarantine. E.g., if 10 indiviuals were in quarantine for 5 ticks each, this function will return 50.\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.total_tests-Tuple{PostProcessor}","page":"Post Processing","title":"GEMS.total_tests","text":"total_tests(postProcessor::PostProcessor)\n\nSums up the total number of tests per test type.\n\nReturns\n\nDict{String, Int64}: Dictionary where the key is the TestType's name and the value   the number of tests that were applied.\n\n\n\n\n\n","category":"method"},{"location":"api_postproc/#GEMS.weighted_error_sum","page":"Post Processing","title":"GEMS.weighted_error_sum","text":"weighted_error_sum(post_processor::PostProcessor, error_matrix::ContactMatrix{T})::T where T <: Number\n\nCalculate a weighted error sum for the given contact matrix. Each cell will be multiplied by the number of individuals in the corresponding age group and then divided by the number of individuals in the whole population.\n\nweighted_error_sum = (cell value * individuals per age group) / population size)\n\nTo calculate the weighted sum, \"weighted arithmetic mean\" is used.\n\nAssumptions\n\nerror_matrix Matrix contains error values between two contact matrices.\n\n\n\n\n\nweighted_error_sum(post_processor::PostProcessor, setting::DataType, reference_matrix::ContactMatrix{T}; fit_to_reference_matrix::Bool)::T where T <: Number\n\nCalculate a \"weighted error sum\" for a setting specific contact matrix compared to a reference_matrix. The post_processor is used to calculate a contact matrix for the associated simulation that will then be fitted by a factor alpha calculated from the differences between the simulation contact matrix and the reference_matrix. \n\nCompared to weighted_error_sum(post_processor::PostProcessor, error_matrix::ContactMatrix{T})::T where T <: Number the error_matrix first needs to be calculated using the post_processor and the reference_matrix.\n\nEach cell of the calculated error matrix will be multiplied by the number of individuals in the corresponding age group and then divided by the number of individuals in the whole population of the simulation.\n\nweighted_error_sum = (cell value * individuals per age group) / population size)\n\nTo calculate the weighted sum, \"weighted arithmetic mean\" is used.\n\nParameters\n\npost_processor::PostProcessor: PostProcessor object containing the simulation and population data\nsetting::DataType: Settingtype of the reference_matrix (i.e. Household)\nreference_matrix::ContactMatrix{T}: Matrix containing mean number of contacts per age group between individuals of one settingtype.\nfit_to_reference_matrix::Bool: Flag, indicating if the matrix calculated from the simulation should be fitted to the 'reference_matrix`.\n\nAssumptions\n\nreference_matrix logically stems from the same setting as setting!\n\n\n\n\n\n","category":"function"},{"location":"api_misc/#Misc","page":"Misc","title":"Misc","text":"","category":"section"},{"location":"api_misc/#Overview-Structs","page":"Misc","title":"Overview Structs","text":"","category":"section"},{"location":"api_misc/","page":"Misc","title":"Misc","text":"Pages   = [\"api_misc.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_misc/#Overview-Functions","page":"Misc","title":"Overview Functions","text":"","category":"section"},{"location":"api_misc/","page":"Misc","title":"Misc","text":"Pages   = [\"api_misc.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_misc/#AGS","page":"Misc","title":"AGS","text":"","category":"section"},{"location":"api_misc/#Constructors","page":"Misc","title":"Constructors","text":"","category":"section"},{"location":"api_misc/#GEMS.AGS","page":"Misc","title":"GEMS.AGS","text":"AGS\n\nStruct to represent Germany's Community Identification Number (Amtlicher Gemeindeschlüssel).\n\nTaken from Wikipedia (https://en.wikipedia.org/wiki/Community_Identification_Number):\n\nThe municipality key consists of eight digits, which are generated as follows: The first two digits designate the individual German state. The third digit designates the government district (in areas without government districts a zero is used instead). The fourth and fifth digits designate the number of the urban area (in a district-free city) or the district (in a city with districts). In GEMS they are called 'counties'. The sixth, seventh, and eighth digits indicate the municipality or the number of the unincorporated area.\n\nExample\n\nmünster = AGS(\"05515000\")\n\nThe above code generates the community identification number for the city of Münster.\n\nThe first two digits identify the state of North Rhine-Westphalia (05)\nThe third digit identifies the government district Münster (5)\nThe fourth and fifth digit identify the district-free city of Münster (15)\n\nBeing a district-free city, Münster does not have a municipality code. Examples for municipalities are: Emsdetten (05566008), Warendorf (05570052), or  Steinfurt (05566084).\n\nThere are multiple helper functions to navigate through the hierarchical AGS structure such as: state, district, county, or municiaplity which each return the AGS of the respective geographic level. The is_state, is_district, and is_county return true, if the provided AGS is on the respective geographic level. Moreover, in_state,  in_district, and in_county verify whether a provided AGS is contained in a parent region.\n\nAGS are directly comparable (==) and broadcastable (.==).\n\nNote:\n\nThere is no is_municiaplity function as this could be confused as a  check wether the AGS is on the lowest geographic level. However, as there are district-free cities which are technically municipalities but without the last three digits given, this check could only be done with context information on the actual region. Based purely on the number, we do not know which county has contains municipalites and which conty is a  district-free city.\n\n\n\n\n\n","category":"type"},{"location":"api_misc/#Functions","page":"Misc","title":"Functions","text":"","category":"section"},{"location":"api_misc/#GEMS.county-Tuple{AGS}","page":"Misc","title":"GEMS.county","text":"county(ags::AGS)\n\nReturns the parent county's Community Identification Number (AGS) of the provided AGS.\n\n\n\n\n\n","category":"method"},{"location":"api_misc/#GEMS.district-Tuple{AGS}","page":"Misc","title":"GEMS.district","text":"district(ags::AGS)\n\nReturns the parent district's Community Identification Number (AGS) of the provided AGS.\n\n\n\n\n\n","category":"method"},{"location":"api_misc/#GEMS.id-Tuple{AGS}","page":"Misc","title":"GEMS.id","text":"id(ags::AGS)\n\nRetuns the AGSs internal number (int).\n\n\n\n\n\n","category":"method"},{"location":"api_misc/#GEMS.in_county-Tuple{AGS, AGS}","page":"Misc","title":"GEMS.in_county","text":"in_county(ags::AGS, parent::AGS)\n\nReturns true if the county-section of both Community Identification Numbers (AGS) match. Both AGSs are in the same county. \n\n\n\n\n\n","category":"method"},{"location":"api_misc/#GEMS.in_district-Tuple{AGS, AGS}","page":"Misc","title":"GEMS.in_district","text":"in_district(ags::AGS, parent::AGS)\n\nReturns true if the district-section of both Community Identification Numbers (AGS) match. Both AGSs are in the same district. \n\n\n\n\n\n","category":"method"},{"location":"api_misc/#GEMS.in_state-Tuple{AGS, AGS}","page":"Misc","title":"GEMS.in_state","text":"in_state(ags::AGS, parent::AGS)\n\nReturns true if the state-section of both Community Identification Numbers (AGS) match.  Both AGSs are in the same state.\n\n\n\n\n\n","category":"method"},{"location":"api_misc/#GEMS.is_county-Tuple{AGS}","page":"Misc","title":"GEMS.is_county","text":"is_district(ags::AGS)\n\nReturns true if the Community Identification Number (AGS) belongs to a conty. First five digits given, last three being 0s.\n\n\n\n\n\n","category":"method"},{"location":"api_misc/#GEMS.is_district-Tuple{AGS}","page":"Misc","title":"GEMS.is_district","text":"is_district(ags::AGS)\n\nReturns true if the Community Identification Number (AGS) belongs to a governmental district. First three digits given, everything else being 0s.\n\n\n\n\n\n","category":"method"},{"location":"api_misc/#GEMS.is_state-Tuple{AGS}","page":"Misc","title":"GEMS.is_state","text":"is_state(ags::AGS)\n\nReturns true if the Community Identification Number (AGS) belongs to a state. First two digits given, everything else being 0s.\n\n\n\n\n\n","category":"method"},{"location":"api_misc/#GEMS.isunset-Tuple{AGS}","page":"Misc","title":"GEMS.isunset","text":"isunset(ags::AGS)\n\nReturns true if the AGS is the \"empty\" default and does not  actually belongs to a any geographic region.\n\n\n\n\n\n","category":"method"},{"location":"api_misc/#GEMS.municipality-Tuple{AGS}","page":"Misc","title":"GEMS.municipality","text":"municipality(ags::AGS)\n\nReturns the Community Identification Number (AGS) regardless of its geographic level.\n\n\n\n\n\n","category":"method"},{"location":"api_misc/#GEMS.state-Tuple{AGS}","page":"Misc","title":"GEMS.state","text":"state(ags::AGS)\n\nReturns the parent state's Community Identification Number (AGS) of the provided AGS.\n\n\n\n\n\n","category":"method"},{"location":"api_misc/#Utils","page":"Misc","title":"Utils","text":"","category":"section"},{"location":"api_misc/#GEMS._int","page":"Misc","title":"GEMS._int","text":"_int(f::Function)\n\nWrapper to enforce Integer returns of anonymous functions.\n\n\n\n\n\n","category":"function"},{"location":"api_misc/#GEMS.aggregate_df","page":"Misc","title":"GEMS.aggregate_df","text":"aggregate_df(df::DataFrame, key::Symbol)\n\nGroups dataframes (with numerical values) on the provided key column and applies the aggregate_values function to each of them. The resulting dataframe has all initial columns supplemented with the suffixes min, max, mean, lower_95, upper_95, and std\n\n\n\n\n\n","category":"function"},{"location":"api_misc/#GEMS.aggregate_dfs","page":"Misc","title":"GEMS.aggregate_dfs","text":"aggregate_dfs(dfs::Vector{DataFrame}, key::Symbol)\n\nJoins the input vector of dataframes on the key and aggregates the residual data. Requires all dataframes to  provide the exact same columns and column names.\n\n\n\n\n\n","category":"function"},{"location":"api_misc/#GEMS.aggregate_dfs_multcol","page":"Misc","title":"GEMS.aggregate_dfs_multcol","text":"aggregate_dfs_multcol(dfs::Vector{DataFrame}, key::Symbol)\n\nAggregates data on the columns of the dataframes contained in the  provided vector for each value in the key column. All dataframes must have identical columnnames.  Returns a dictionary with the columnnames as keys and a dataframe as the value.\n\n\n\n\n\n","category":"function"},{"location":"api_misc/#GEMS.foldercount-Tuple{AbstractString}","page":"Misc","title":"GEMS.foldercount","text":"foldercount(directory)\n\nReturns the number of subfolders in a directory.\n\n\n\n\n\n","category":"method"},{"location":"api_misc/#GEMS.group_by_age-Tuple{DataFrame}","page":"Misc","title":"GEMS.group_by_age","text":"group_by_age(df::DataFrame)\n\nGroups a dataframe by its \"age\" column. The column \"sum\" contains the sum of each individual in this age. This also adds rows for each age from 0 till the maximum age in the \"age\" column.\n\nReturns\n\nreturns a DataFrame with an additional column \"sum\". This column contains the count of the age in the DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"api_misc/#GEMS.print_aggregates","page":"Misc","title":"GEMS.print_aggregates","text":"print_aggregates(agg; unit, multiplier, digits)\n\nPretty-prints the outcomes of an aggregate_values() function call.\n\n\n\n\n\n","category":"function"},{"location":"api_misc/#GEMS.printinfo-Tuple{String}","page":"Misc","title":"GEMS.printinfo","text":"printinfo(str::String)\n\nPrints an @info-Text with the provided string and a HH:MM:SS timestamp.\n\n\n\n\n\n","category":"method"},{"location":"api_misc/#GEMS.remove_kw","page":"Misc","title":"GEMS.remove_kw","text":"remove_kw(to_remove::Symbol, kwrds)\n\nRemoves a particular keyword from a Named Tuple keyword ist. This is mainly used to exclude certain keywords in plots when passing plotargs... to subplots.\n\nExample\n\nfunction my_function(;args...)\n    new_kwrds = remove_kw(:a, args)\n    my_other_function(new_kwrds...)\nend\n\nIf you call the above function with my_function(a = 2, b = 3), it will call the inner function with my_other_function(b = 3).\n\n\n\n\n\n","category":"function"},{"location":"api_misc/#GEMS.subinfo-Tuple{String}","page":"Misc","title":"GEMS.subinfo","text":"subinfo(str::String)\n\nReturns a string with a \"sub-line-hook\" indicating subtasks of an @info task (as generated by printinfo())\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"api_plotting/#Overview-Structs","page":"Plotting","title":"Overview Structs","text":"","category":"section"},{"location":"api_plotting/","page":"Plotting","title":"Plotting","text":"Pages   = [\"api_plotting.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_plotting/#Overview-Functions","page":"Plotting","title":"Overview Functions","text":"","category":"section"},{"location":"api_plotting/","page":"Plotting","title":"Plotting","text":"Pages   = [\"api_plotting.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_plotting/#Plotting-2","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"api_plotting/#GEMS.gemsplot","page":"Plotting","title":"GEMS.gemsplot","text":"gemsplot(rd::ResultData; type::Symbol = :nothing, plotargs...)\ngemsplot(bd::BatchData; type::Symbol = :nothing, combined::Symbol = :all, plotargs...)\ngemsplot(rd::Vector{ResultData}; type::Symbol = :nothing, combined::Symbol = :all, plotargs...)\n\nFacilitates the usage of GEMS' inbuilt plots. Just pass the name of the plot-type  as a Symbol (must be exactly the same as the respective SimulationPlot-struct). The plotargs... can be any keyworded argument that is available in the standard Plots.jl package.\n\nYou can pass a ResultData object to get a plot for one simulation run or even pass a vector of ResultData objects or even a BatchData object. Passing data of multiple simulation runs (ResultData-vector or BatchData) will generate the respective plot with the data of all simulation runs inside. E.g., the :TickCases plot will show one line for each run. Simulations with the same label attribute will be grouped using the same color.\n\nThe keyword combined (only applicable for ResultData-vectors or BatchData-objects) determines whether all data is combined in a single plot (:all), each simulation run gets its own subplot (:single), or the plots are separated by label (:bylabel). Note: There might be plots without a multi-plot implementation. They will always be printed as if combined = :single was passed. Check the table below to see which plots are available for single- and multiplots.\n\nParameters\n\nrd/bd: Data object to plot. Can be ResultData, Vector{ResultData} or BatchData\ntype = :nothing (optional): Plot type (instantiates a plot with the exact same struct name).   You can pass a tuple of plots to generate one graph with multiple visualizations\ncombined::Symbol = :all (optional): all data in one plot (:all), all individual plots (:singe),   plot separated by label (:bylabel).\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Plot using the Plots.jl package's struct.\n\nExamples\n\nGiven that rd is a valid ResultData object that came out of a simulation, you can plot a summary like this:\n\ngemsplot(rd)\n\nIf you want a specific plot, say the cases-per-tick plot, try this and add a custom title:\n\ngemsplot(rd, type = :TickCases, title = \"My Tick Case Plot\")\n\nYou can also generate multiple plots in one figure like so:\n\ngemsplot(rd, type = (:CompartmentFill, :EffectiveReproduction), layout = (2,1))\n\nThe layout keyword makes the plots appear on top of each other in stead of side-by-side.\n\nGenerate a multi-plot for a vector of ResultData objects and separate plots by label like so:\n\n# assuming you have a baseline, and a lockdown scenario with two simulation runs each.\n# the simulations of these ResultData objects must have the same label (\"Baseline\" and \"Lockdown\") to group them\nrds = [rd_baseline_1, rd_baseline_2, rd_lockdown_1, rd_lockdown_2]\ngemsplot(rds, type = :EffectiveReproduction, combined = :bylabel)\n\nPlot Types\n\nThe following plot types can be generated using the gemsplot() function. The mutli-plot column describes which plots can work with ResultData-vector or BatchData-objects. Some of the plots have keyword arguments that are only applicable to that very plot.\n\nType Description Multi-Plot Plot-Specific Parameters\n:ActiveDarkFigure Fraction of current infections per tick that are \"known\"/detected at that tick. Yes \n:AggregatedSettingAgeContacts Age-X-Age contact matrix for all setting types in the simulation (e.g., Household). No settingtype::DataType: Filter for specific setting type (e.g., Household), show_values::Bool: Enable or disable printed values in cells.\n:CompartmentFill Current number of individuals per compartment (classic SEIR curves). No \n:CumulativeCases Summed-up cases over time. Yes \n:CumulativeDiseaseProgressions Number of people in a certain disease state at a given tick after their exposure. No \n:CumulativeIsolations Number of currently isolated individuals over time. Yes series::Symbol: Filter for :workers, :students, :other, or :all\n:CustomLoggerPlot CustomLogger values. One subplot per logging function in the multi-plot variant. Yes \n:DetectedCases New detected cases per time step. No \n:EffectiveReproduction Effective reproduction number (R_eff) over time. Yes \n:GenerationTime Mean generation time over time. Yes \n:HospitalOccupancy Number of hospitalized, ventilated, and ICU-admitted indivudual over time. No \n:HouseholdAttackRate In-Household attack rate per household size. Yes \n:Incidence Indicende over time by 10-year age group (stacked chart). No \n:IncubationHistogram Histogram of incubation period duratons. No \n:InfectionDuration Histogram of total infection durations. Yes \n:InfectiousHistogram Histogram of infectious period duratons. No \n:LatencyHistogram Histogram of latency period durations. No \n:ObservedReproduction Observed rffective reproduction number (R_eff) over time (based on detected cases). No \n:ObservedSerialInterval Observed serial interval (SI) over time (based on detected cases). No \n:PopulationPyramid Population Pyramid by age and sex. No \n:SettingSizeDistribution Histograms of setting sizes for all setting types (e.g., Households) No \n:SymptomCategories Heatmap of the fraction of symptom categories (asymptomatic, mild, severe...) by age. No \n:TestPositiveRate Fraction of all performed tests that were positive per test type (e.g., PCR). No \n:TickCases New cases per time step. For single sim. also with new infectious, removed, dead. Yes \n:TickCasesBySetting New cases stratified by setting type (e.g., Household or Office) No \n:TickTests Performed tests per time step, including positive and total tests and reported cases. No \n:TimeToDetection Average time between exposure and detected for all infections over time. No \n:TotalTests Total number of performed tests per test type (e.g., PCR) Yes \n\nSome Useful Keyword Arguments\n\nHere are some examples of the Plots.jl package's keyword arguments that you can also pass to the gemsplot() function and might find helpful:\n\nxlims = (0, 100): Setting the X-axis range between 0 and 100\nylims = (0, 200): Setting the Y-axis range between 0 and 200\nsize = (300, 400): Resizing the plot\nplot_title = \"My New Title\": Changing the plot title\nxlabel = \"New X-label\": Changing the x-axis label\nylabel = \"New Y-label\": Changing the y-axis label\nlegend = :topright: Changing the legend position (false to disable)\naspect_ratio = :equal: Having the axis of equal size\n\nPlease consult the Plots.jl package documentation for a comprehensive list\n\n\n\n\n\n","category":"function"},{"location":"api_plotting/#GEMS.emptyplot-Tuple{String}","page":"Plotting","title":"GEMS.emptyplot","text":"emptyplot(message::String)\n\nReturns an empty plot with the argument message as a text overlay. This can be used as a default for plot-generate()-functions, if no data is available in the ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.plotseries!","page":"Plotting","title":"GEMS.plotseries!","text":"plotseries!(p::Plots.Plot, extract_function::Function, rds::Vector{ResultData}; plotargs...)\n\nExtends a plot and adds data grouped by the labels of the ResultData objects. The extract_function argument must be a one-argument function that is the called with a single ResultData object. It must return the data series that should be plotted.\n\nParameters\n\np::Plots.Plot: Input plot object to extend\nextract_function::Function: One-argument lambda function that will be called with   each of the ResultData objects in the input vector. This function must return    a vector of numberical values that is being added as a line series to input plot p.\nrds::Vector{ResultData}: Vector of ResultData objects to plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Plot using the Plots.jl package's struct.\n\nExample\n\nThis code generates a plot of the effective reproduction number with one line per ResultData object and grouped by label.\n\np = plotseries!(plot(), rd -> effectiveR(rd)[!,\"rolling_R\"], rds)\n\n\n\n\n\n","category":"function"},{"location":"api_plotting/#GEMS.saveplot","page":"Plotting","title":"GEMS.saveplot","text":"saveplot(plot::Plots.Plot, path::AbstractString)\n\nStores a plot from the juliaplots package to the provided path.\n\n\n\n\n\nsaveplot(plot::GMTWrapper, path::AbstractString)\n\nCopies a GMT plot from the temp folder into the provided path (removes the temporary file).\n\n\n\n\n\n","category":"function"},{"location":"api_plotting/#GEMS.splitlabel","page":"Plotting","title":"GEMS.splitlabel","text":"splitlabel(plt::SimulationPlot, rds::Vector{ResultData}; plotargs...)\n\nReturns a split side-by-side plot for multiple ResultData objects but groups simulation runs by label. If you have 2 scenarios with 10 simulation runs each, this function will generate two plots with 10 data series each.\n\nplt::SimulationPlot: Simulation plot struct (e.g. TickCases())\nrds::Vector{ResultData}: Vector of ResultData objects to plot   (requires the rd objects to have the label attribute)\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Plot using the Plots.jl package's struct.\n\n\n\n\n\n","category":"function"},{"location":"api_plotting/#GEMS.splitplot","page":"Plotting","title":"GEMS.splitplot","text":"splitplot(plt::SimulationPlot, rds::Vector{ResultData}; plotargs...)\n\nReturns a split side-by-side plot for multiple ResultData objects.\n\nParameters\n\nplt::SimulationPlot: Simulation plot struct (e.g. TickCases())\nrds::Vector{ResultData}: Vector of ResultData objects to plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Plot using the Plots.jl package's struct.\n\n\n\n\n\n","category":"function"},{"location":"api_plotting/#Plot-Types","page":"Plotting","title":"Plot Types","text":"","category":"section"},{"location":"api_plotting/#GEMS.ActiveDarkFigure","page":"Plotting","title":"GEMS.ActiveDarkFigure","text":"ActiveDarkFigure <: SimulationPlot\n\nA simulation plot type for generating an active-darkfigure-per-tick plot.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{ActiveDarkFigure, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::ActiveDarkFigure, rd::ResultData; plotargs...)\n\nGenerates and returns a active-darkfigure-per-tick plot for a provided ResultData object. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::ActiveDarkFigure: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Active Dark Figure plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.AggregatedSettingAgeContacts","page":"Plotting","title":"GEMS.AggregatedSettingAgeContacts","text":"AggregatedSettingAgeContacts <: SimulationPlot\n\nA simulation plot type for sampling contacts from the model and build an age group x age group matrix for a given Setting type. The plot  displays aggregated age groups and their mean number of contacts.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{AggregatedSettingAgeContacts, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::AggregatedSettingAgeContacts, rd::ResultData;\n    settingtype::Union{DataType, Nothing} = nothing, plotargs...)\n\nGenerates and returns an age group x age group matrix from sampled contacts for a given Setting type. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::AggregatedSettingAgeContacts: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nsettingtype::Union{DataType, Nothing} = nothing (optional): Setting type (e.g. \"Household\"). If nothing is passed, all   setting types in the ResultData object are being ploted.\nshow_values = true (optional): If true, values will be printed in the contact matrix\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Aggregated Setting Age Contacts plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.CompartmentFill","page":"Plotting","title":"GEMS.CompartmentFill","text":"CompartmentFill <: SimulationPlot\n\nA simulation plot type for generating a cumulative infections plot.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{CompartmentFill, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::CompartmentFill, rd::ResultData; plotargs...)\n\nGenerates and returns a plot of the current compartment fill for a provided ResultData object. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::CompartmentFill: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Compartment Fill plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.CumulativeCases","page":"Plotting","title":"GEMS.CumulativeCases","text":"CumulativeCases <: SimulationPlot\n\nA simulation plot type for generating a cumulative infections plot.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{CumulativeCases, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::CumulativeCases, rd::ResultData; plotargs...)\n\nGenerates and returns a cumulative infections plot for a provided simulation object. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::CumulativeCases: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Cumulative Cases plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.CumulativeDiseaseProgressions","page":"Plotting","title":"GEMS.CumulativeDiseaseProgressions","text":"CumulativeDiseaseProgressions <: SimulationPlot\n\nA simulation plot type for generating a stacked bar chart on the cumulative disease progression.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{CumulativeDiseaseProgressions, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::CumulativeDiseaseProgressions, rd::ResultData; plotargs...)\n\nGenerates a stacked bar chart of cumulative disease progressions for all infections. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::CumulativeDiseaseProgressions: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Cumulative Disease Progressions plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.CumulativeIsolations","page":"Plotting","title":"GEMS.CumulativeIsolations","text":"CumulativeIsolations <: SimulationPlot\n\nA simulation plot type for generating a plot displaying the cumulative number of individuals currently in isolation.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{CumulativeIsolations, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::CumulativeIsolations, rd::ResultData; plotargs...)\n\nGenerates a plot for the cumulative number of isolated individuals per tick. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::CumulativeIsolations: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Cumulative Isolations plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.CustomLoggerPlot","page":"Plotting","title":"GEMS.CustomLoggerPlot","text":"CustomLoggerPlot <: SimulationPlot\n\nA simulation plot type for generating a time series plot displaying values stored in a ResultDatas CustomLogger dataframe.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{CustomLoggerPlot, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::CustomLoggerPlot, rd::ResultData; plotargs...)\n\nGenerates and returns a plot for the values contained in the custom logger of a ResultData object. It will contain one individual plot per function that was passed to the custom logger. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package. However, be aware that the keyword arguments might be applied to each of the subplots individually.\n\nParameters\n\nplt::CustomLoggerPlot: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Custom Logger Plot plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.DetectedCases","page":"Plotting","title":"GEMS.DetectedCases","text":"DetectedCases <: SimulationPlot\n\nA simulation plot type for generating a new-DETECTED-cases-per-tick plot.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{DetectedCases, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::DetectedCases, rd::ResultData; plotargs...)\n\nGenerates and returns a new-DETECTED-cases-per-tick plot for a provided simulation object. Sorts infections dataframe by test_tickand filters for tested individuals. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::DetectedCases: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Detected Cases plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.EffectiveReproduction","page":"Plotting","title":"GEMS.EffectiveReproduction","text":"EffectiveReproduction <: SimulationPlot\n\nA simulation plot type for generating an effective reproduction number plot.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{EffectiveReproduction, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::EffectiveReproduction, rd::ResultData; plotargs...)\n\nGenerates a plot for the effective reproduction number per tick. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::EffectiveReproduction: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Effective Reproduction Number plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.GMTWrapper","page":"Plotting","title":"GEMS.GMTWrapper","text":"GMTWrapper\n\nWrapper-struct to inform saveplot function about  the existance of a GMT-generated plot in the  temp-folder (path_to_map).\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.GenerationTime","page":"Plotting","title":"GEMS.GenerationTime","text":"GenerationTime <: SimulationPlot\n\nA simulation plot type for generating a generation-time-per-tick.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{GenerationTime, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::GenerationTime, rd::ResultData; plotargs...)\n\nGenerates and returns a generation-time-per-tick plot for a provided simulation object. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::GenerationTime: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Generation Time plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.HospitalOccupancy","page":"Plotting","title":"GEMS.HospitalOccupancy","text":"HospitalOccupancy <: SimulationPlot\n\nA simulation plot type for generating a plot with hospitalization numbers etc.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{HospitalOccupancy, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::HospitalOccupancy, rd::ResultData; plotargs...)\n\nGenerates a plot of the number of hospitalized, ventilated and ICU admitted agents for each tick. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::HospitalOccupancy: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Hospital Occupancy plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.HouseholdAttackRate","page":"Plotting","title":"GEMS.HouseholdAttackRate","text":"HouseholdAttackRate <: SimulationPlot\n\nA simulation plot type for generating a household-attack-rate plot.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{HouseholdAttackRate, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::HouseholdAttackRate, rd::ResultData; plotargs...)\n\nGenerates and returns a household-attack-rate plot for a provided simulation object. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package. However, be aware that the keyword arguments might be applied to each of the subplots individually.\n\nParameters\n\nplt::HouseholdAttackRate: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Household Attack Rate plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.Incidence","page":"Plotting","title":"GEMS.Incidence","text":"Incidence <: SimulationPlot\n\nA simulation plot type for generating an incidence plot.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{Incidence, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::Incidence, rd::ResultData; plotargs...)\n\nGenerates an age-stratified incidence plot. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::Incidence: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Incidence plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.IncubationHistogram","page":"Plotting","title":"GEMS.IncubationHistogram","text":"IncubationHistogram <: SimulationPlot\n\nA simulation plot type for generating the distribution of incubation period lengths for symptomatic individuals.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{IncubationHistogram, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::IncubationHistogram, rd::ResultData; plotargs...)\n\nGenerates a histrogram of the incubation period distribution (time to symptoms) of collected infections. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nNote that this only shows the incubation period for symptomatic individuals!\n\nParameters\n\nplt::IncubationHistogram: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Infectious Histogram plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.InfectionDuration","page":"Plotting","title":"GEMS.InfectionDuration","text":"InfectionDuration <: SimulationPlot\n\nA simulation plot type for visualizing the distribution of infection durations as a histogram.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{InfectionDuration, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::InfectionDuration, rd::ResultData; plotargs...)\n\nGenerates and returns a histogram of the total infection durations in ticks. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::InfectionDuration: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Infection Duration plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.InfectiousHistogram","page":"Plotting","title":"GEMS.InfectiousHistogram","text":"InfectiousHistogram <: SimulationPlot\n\nA simulation plot type for generating the distribution of infectious period lengths.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{InfectiousHistogram, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::InfectiousHistogram, rd::ResultData; plotargs...)\n\nGenerates a histrogram of the infectious period distribution of collected infections. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::InfectiousHistogram: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Infectious Histogram plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.LatencyHistogram","page":"Plotting","title":"GEMS.LatencyHistogram","text":"LatencyHistogram <: SimulationPlot\n\nA simulation plot type for generating the distribution of latency period lengths.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{LatencyHistogram, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::LatencyHistogram, rd::ResultData; plotargs...)\n\nGenerates a histrogram of the latency period distribution of collected infections. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::LatencyHistogram: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Latency Histogram plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.ObservedReproduction","page":"Plotting","title":"GEMS.ObservedReproduction","text":"ObservedReproduction <: SimulationPlot\n\nA simulation plot type for generating a observed-reproduction-number-plot.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{ObservedReproduction, ResultData}","page":"Plotting","title":"GEMS.generate","text":" generate(plt::ObservedReproduction, rd::ResultData; plotargs...)\n\nGenerates a plot for the effective reproduction number per tick. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::ObservedReproduction: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Observed Reproduction Number plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.ObservedSerialInterval","page":"Plotting","title":"GEMS.ObservedSerialInterval","text":"ObservedSerialInterval <: SimulationPlot\n\nA simulation plot type for generating a observed-serial-interval-plot.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{ObservedSerialInterval, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::ObservedSerialInterval, rd::ResultData; plotargs...)\n\nGenerates a plot for the estimation on the observed serial interval per tick. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::ObservedSerialInterval: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Observed Serial Interval plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.PopulationPyramid","page":"Plotting","title":"GEMS.PopulationPyramid","text":"PopulationPyramid <: SimulationPlot\n\nA simulation plot type for generating a population pyramid for the associated population model.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{PopulationPyramid, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::PopulationPyramid, rd::ResultData; plotargs...)\n\nGenerates population pyramid for a the associated population model.\n\nThe current implementation does not offer the option for additional keyworded arguments. The plotargs... argument is just a placeholder.\n\nParameters\n\nplt::PopulationPyramid: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): PLACEHOLDER. Currently not implemented.\n\nReturns\n\nPlots.Plot: Population Pyramid plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.SettingAgeContacts","page":"Plotting","title":"GEMS.SettingAgeContacts","text":"SettingAgeContacts <: SimulationPlot\n\nA simulation plot type for sampling contacts from the model and build an age x age matrix for a given Setting type.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{SettingAgeContacts, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::SettingAgeContacts, rd::ResultData; plotargs...)\n\nGenerates and returns an age x age matrix from sampled contacts for a given Setting type. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::SettingAgeContacts: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Setting Age Contacts plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.SettingSizeDistribution","page":"Plotting","title":"GEMS.SettingSizeDistribution","text":"SettingSizeDistribution <: SimulationPlot\n\nA simulation plot type for generating a population pyramid for the associated population model.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{SettingSizeDistribution, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::SettingSizeDistribution, rd::ResultData; plotargs...)\n\nGenerates the setting size distributions for all included settings. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::SettingSizeDistribution: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Setting Size Distribution plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.SimulationPlot","page":"Plotting","title":"GEMS.SimulationPlot","text":"Supertype for all plots that go into single-run simulation reports\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{SimulationPlot, ResultData}","page":"Plotting","title":"GEMS.generate","text":"Abstract wrapper function for all simulation report plots. Requires concrete implementation in subtypes\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.SymptomCategories","page":"Plotting","title":"GEMS.SymptomCategories","text":"SymptomCategories <: SimulationPlot\n\nA simulation plot type for visualizing the symptom categories of infections by age.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{SymptomCategories, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::SymptomCategories, rd::ResultData; plotargs...)\n\nGenerates and returns a symptom_category x age matrix as heatmap. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::SymptomCategories: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Symptom Categories plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.TestPositiveRate","page":"Plotting","title":"GEMS.TestPositiveRate","text":"TestPositiveRate <: SimulationPlot\n\nA simulation plot type for generating a tests-positive-rate-per-tick plot.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{TestPositiveRate, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::TestPositiveRate, rd::ResultData; plotargs...)\n\nGenerates and returns a tests-positive-rate-per-tick plot for a provided simulation object. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::TestPositiveRate: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Test Positive Rate plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.TickCases","page":"Plotting","title":"GEMS.TickCases","text":"TickCases <: SimulationPlot\n\nA simulation plot type for generating a new-cases-per-tick plot.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{TickCases, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::TickCases, rd::ResultData; plotargs...)\n\nGenerates and returns a new-cases-per-tick plot for a provided simulation object. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::TickCases: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Tick Cases plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.TickCasesBySetting","page":"Plotting","title":"GEMS.TickCasesBySetting","text":"TickCasesBySetting <: SimulationPlot\n\nA simulation plot type for generating tick cases for each included setting type.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{TickCasesBySetting, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::TickCasesBySetting, rd::ResultData; plotargs...)\n\nGenerates a plot of tick cases for each included setting type. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::TickCasesBySetting: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Tick Cases By Setting plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.TickTests","page":"Plotting","title":"GEMS.TickTests","text":"TickTests <: SimulationPlot\n\nA simulation plot type for generating a new-tests-per-tick plot.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{TickTests, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::TickTests, rd::ResultData; plotargs...)\n\nGenerates and returns a tests-per-tick plot for a provided simulation object. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::TickTests: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Tick Tests plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.TimeToDetection","page":"Plotting","title":"GEMS.TimeToDetection","text":"TimeToDetection <: SimulationPlot\n\nA simulation plot type for generating a time-to-detection plot.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{TimeToDetection, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::TimeToDetection, rd::ResultData; plotargs...)\n\nGenerates and returns a time-to-detection plot for a provided simulation object. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::TimeToDetection: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Time To Detection plot\n\n\n\n\n\n","category":"method"},{"location":"api_plotting/#GEMS.TotalTests","page":"Plotting","title":"GEMS.TotalTests","text":"TotalTests <: SimulationPlot\n\nA simulation plot type for generating a total-tests-per-tick plot.\n\n\n\n\n\n","category":"type"},{"location":"api_plotting/#GEMS.generate-Tuple{TotalTests, ResultData}","page":"Plotting","title":"GEMS.generate","text":"generate(plt::TotalTests, rd::ResultData; plotargs...)\n\nGenerates and returns a total-tests-per-tick plot for a provided simulation object. You can pass any additional keyword arguments using plotargs... that are available in the Plots.jl package.\n\nParameters\n\nplt::TotalTests: SimulationPlot struct with meta data (i.e. title, description, and filename)\nrd::ResultData: Input data used to generate plot\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Total Tests plot\n\n\n\n\n\n","category":"method"},{"location":"glossary/#Glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Term Definition\nAsymptomatic A symptom category. An individual will not develop any symptoms. Its terminal state is \"Presymptomatic\".\nCritical (State) A state in the natural disease progression. An individual is in a critical condition with the need of hospitalization and possible need of ventilation or ICU.\nCritical (Symptom Category) A symptom category. The individual will get into a critical condition during its disease progression with the need of hospitalization and possible need of ventilation.\nCritical Death Rate The probability of individuals with critical condition to die at the end of the natural disease progression.\nDisease Progression An individual's course through the disease states from initial exposure to recovery or death.\nDisease Status The status of an individual in the natural disease progression. Holds information about infectiousness and symptoms.\nExposed The individual is infected, but is not yet infectious.\nExposure Exposure to a pathogen is regarded as an infection event and marks the inception of a disease progression.\nGeneration Time The time interval between the infections of the infector and infectee, two immediate successors in an infection chain.\nHospitalization Status States if an individual is hospitalized and if additional measures have to be applied (vetilation, ICU).\nHospitalization Rate The probability of an individual with severe symptoms to need hospitalization.\nICU Short for Intensive Care Unit. An hospitalization state. Individuals are in the hospital, ventilated and are in ICU.\nICU Rate The probabilityof an individual in critical condition to need ICU.\nIndividual The representation of a person. It has different attributes and can become infected inside settings.\nInfection Rate Basic risk of getting infected upon infectious contact\nInfectious Offset An offset from the onset of symptoms. Determines if an individual becomes infectious before becoming symptomatic. Is also used for asymptomatic cases to determine the start of infectiousness.\nInfectious The individual is infectious, if it can infect other individuals.\nInfectiousness Measurement of how infectious an individual is. Reminiscent of viral load.\n(Intervention) Measure A single intervention-related activity chaning one distinct state variable in the simulation model (e.g. closing a particular school).\n(Intervention) Strategy A collection of intervention measures which are executed in chronological order.\n(Intervention) Trigger An event that causes an intervention strategy to be executed (e.g. an individual starting to experience symptoms).\nIsolation As of now defined as \"household isolation\". An individual staying in its household while still being able to have contacts to other household members.\nLength of Stay The time an individual will spend inside the hospital.\nMild An individual will only develop mild symptoms. Its terminal state is \"Symptomatic\".\nMild Death Rate The probability of individuals with mild symptoms to die at the end of the natural disease progression.\nOnset of Symptoms The time when symptoms start. Is generally calculated and given as an increment to the tick, when an infection happend.\nOnset of Severeness The time when symptoms become severe as an increment to the onset of symptoms.\nPathogen An enclosure to collect disease-related parameters such as infection rates or the delay until the onset of symptoms.\nPresymptomatic A state in the natural disease progression. The individual is infected but does not experience symptoms yet.\nRemoved The state of an individual being recovered or dead\nSetting Some sort of context in which contacts can happen. Those can be Households or Offices or more abstract settings like social networks.\nSevere (State) A state in the natural disease progression. The individual has severe symptoms with the potential need to be hospitalized.\nSevere (Symptom Category) A symptom category. An individual will develop severe symptoms and has possibly the need to be hospitalized. Its terminal state is \"Severe\".\nSevere Death Rate The probability of individuals with severe symptoms to die at the end of the natural disease progression.\nSymptom Category Categorization of the disease progression regarding the occuring symptoms.\nSymptomatic A state in the natural disease progression. The individual has symptoms, but they aren't severe.\nTerminal State The last state reached by an individual in the disease progression before being removed\nTestType Parameterizing a certain type of test (e.g. PCR or Antigen).\nTest Sensitivity A test's ability to positively identify an infected individual.\nTime to Hospitalization If an individual will need hospitalization eventually, this defines the time between the onset of symptoms and hospitalization.\nTime to ICU If an individual will need ICU eventually, this defines the time between the time to hospitalization and the delivery into ICU.\nTime to Recovery The time it takes an individual to recover from an infection as an increment from the onset of symptoms. If an individual will die at the end of the natural disease progression, this will (also) define the time of death.\nVentilated An hospitalization state. Individuals are in the hospital and receive ventilation.\nVentilation Rate The probability of an individual in critical condition to need ventilation.","category":"page"},{"location":"changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"This page lists the changes and release notes for GEMS.jl, automatically generated from GitHub Releases.","category":"page"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"<a id=\"v0.4.0\"></a>","category":"page"},{"location":"changelog/#[v0.4.0-Initial-Public-Version](https://github.com/IMMIDD/GEMS/releases/tag/v0.4.0)-2025-04-16","page":"Changelog","title":"v0.4.0 Initial Public Version - 2025-04-16","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"This is the first public version of GEMS as it was presented at the MONID 2025 Conference in Berlin in February 2025.","category":"page"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"[Changes][v0.4.0]","category":"page"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"[v0.4.0]: https://github.com/IMMIDD/GEMS/tree/v0.4.0","category":"page"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"<!– Generated by https://github.com/rhysd/changelog-from-release v3.9.0 –>","category":"page"},{"location":"api_pathogens/#Pathogens","page":"Pathogens","title":"Pathogens","text":"","category":"section"},{"location":"api_pathogens/#Overview-Structs","page":"Pathogens","title":"Overview Structs","text":"","category":"section"},{"location":"api_pathogens/","page":"Pathogens","title":"Pathogens","text":"Pages   = [\"api_pathogens.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_pathogens/#Overview-Functions","page":"Pathogens","title":"Overview Functions","text":"","category":"section"},{"location":"api_pathogens/","page":"Pathogens","title":"Pathogens","text":"Pages   = [\"api_pathogens.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_pathogens/#Structs","page":"Pathogens","title":"Structs","text":"","category":"section"},{"location":"api_pathogens/#GEMS.Pathogen","page":"Pathogens","title":"GEMS.Pathogen","text":"Pathogen <: Parameter\n\nA type representing a pathogen.\n\nInstantiation\n\nThe instantiation requires at least an id and a name that must be supplied as keyword arguments. All other fields are optional parameters.\n\ncovid = Pathogen(id = 1, name = \"COVID19\")\nflu = Pathogen(id = 2, name = \"Flu\", onset_of_symptoms = Poission(3))\n\nParameters\n\nid::Int8: Unique identifier pathogen\nname::String: Name of the pathogen\ndpr::DiseaseProgressionStrat = DiseaseProgressionStrat() (optional): Defines the distribution of symptom categories across age groups\ninfection_rate::Distribution = Uniform(0,1) (optional): Distribution of the infection rate\nmild_death_rate::Distribution = Uniform(0,0.005) (optional): Distribution of the death rate for mild cases\nsevere_death_rate::Distribution = Uniform(0,0.1) (optional): Distribution of the death rate for severe cases\ncritical_death_rate::Distribution = Uniform(0,0.1) (optional): Distribution of the death rate for critical cases\nhospitalization_rate::Distribution = Uniform(0, 0.1) (optional): Distribution of the probability for a severe case to be hospitalized\nventilation_rate::Distribution = Uniform(0, 0.1) (optional): Distribution of the probability for a critical case to need ventilation\nicu_rate::Distribution = Uniform(0, 0.1) (optional): Distribution of the probability for a critical case to need ICU\nonset_of_symptoms::Distribution = Uniform(2,3) (optional): Distribution of time till onset of symptoms from becoming exposed\nonset_of_severeness::Distribution = Uniform(2,3) (optional): Distribution of time till onset of severeness from onset of symptoms\ninfectious_offset::Distribution = Uniform(0,1) (optional): Distribution of the offset to become infectious compared to the onset of symptoms\ntime_to_hospitalization::Distribution = Uniform(0,1) (optional): Distribution of time till hospitalization from onset of symptoms\ntime_to_icu::Distribution = Uniform(0,1) (optional): Distribution of time till ICU from hospitalization\ntime_to_recovery::Distribution = Uniform(5,6) (optional): Distribution of time till recovery from becoming exposed\nlength_of_stay::Distribution = Uniform(6,7) (optional): Distribution of time duration to stay in hospital\n\n\n\n\n\n","category":"type"},{"location":"api_pathogens/#GEMS.DiseaseProgressionStrat","page":"Pathogens","title":"GEMS.DiseaseProgressionStrat","text":"DiseaseProgressionStrat <: AgeStratification\n\nA wrapper type for an age stratification matrix regarding the disease progression.\n\nFields\n\nage_groups::Vector{String}: A list of the age groups in order of the rows of the        stratification matrix. The first entry in age_groups belongs to the first row in       the matrix.\ndisease_compartments::Vector{String}: A list of the compartments/terminal states in       the disease progression in order of the columns of the stratification matrix. First       entry in disease_compartments belongs to the first column in the stratification       matrix.\nstratification_matrix::Vector{Vector{T}} where T <: Real: The matrix that holds the       probabilities for the age stratified disease progression.       The entries of each row have to add up to 1.\n\n\n\n\n\n","category":"type"},{"location":"api_pathogens/#Functions","page":"Pathogens","title":"Functions","text":"","category":"section"},{"location":"api_pathogens/#GEMS.critical_death_rate-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.critical_death_rate","text":"critical_death_rate(pathogen::Pathogen)\n\nReturns the death rate (distribution) of the pathogen in the case of critical progression.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.DiseaseProgressionStrat-Tuple{}","page":"Pathogens","title":"GEMS.DiseaseProgressionStrat","text":"DiseaseProgressionStrat()\n\nA constructor for a default Disease Progression, where every individual will only be assigned to be asymptomatic. Mainly for testing purposes.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.disease_progression_strat-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.disease_progression_strat","text":"disease_progression_strat(pathogen::Pathogen)\n\nReturns the stratified probabilities for disease progression.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.hospitalization_rate-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.hospitalization_rate","text":"hospitalization_rate(pathogen::Pathogen)\n\nReturns the hospitalization rate (distribution) of the pathogen in the case  of a severe disease progression.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.icu_rate-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.icu_rate","text":"icu_rate(pathogen::Pathogen)\n\nReturns the icu rate (distribution) of the pathogen in the case  of a critical disease progression.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.id-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.id","text":"id(pathogen::Pathogen)\n\nReturns the id of the pathogen.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.infection_rate-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.infection_rate","text":"infection_rate(pathogen::Pathogen)\n\nReturns the infection rate (distribution) of the pathogen.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.infectious_offset-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.infectious_offset","text":"infectious_offset(pathogen::Pathogen)\n\nReturns the time distribution for the offset of becoming infectious,     before developing symptoms.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.length_of_stay-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.length_of_stay","text":"length_of_stay(pathogen::Pathogen)\n\nReturns the time distribution of the duration an individual will be hospitalized.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.mild_death_rate-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.mild_death_rate","text":"mild_death_rate(pathogen::Pathogen)\n\nReturns the death rate (distribution) of the pathogen in the case of mild symptoms.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.name-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.name","text":"name(pathogen::Pathogen)\n\nReturns the name of the pathogen.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.onset_of_severeness-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.onset_of_severeness","text":"onset_of_severeness(pathogen::Pathogen)\n\nReturns the time distribution for the onset of severe symptoms.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.onset_of_symptoms-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.onset_of_symptoms","text":"onset_of_symptoms(pathogen::Pathogen)\n\nReturns the time distribution for the onset of symptoms.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.sample_critical_death_rate-Tuple{Pathogen, Individual}","page":"Pathogens","title":"GEMS.sample_critical_death_rate","text":"sample_critical_death_rate(pathogen::Pathogen, indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nReturns a randomly drawn value from the death rate distribution for critical  disease progressions.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.sample_hospitalization_rate-Tuple{Pathogen, Individual}","page":"Pathogens","title":"GEMS.sample_hospitalization_rate","text":"sample_hospitalization_rate(pathogen::Pathogen, indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nReturns a randomly drawn value from the hospitalization rate distribution.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.sample_icu_rate-Tuple{Pathogen, Individual}","page":"Pathogens","title":"GEMS.sample_icu_rate","text":"sample_icu_rate(pathogen::Pathogen, indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nReturns a randomly drawn value from the ICU rate distribution.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.sample_infectious_offset-Tuple{Pathogen, Individual}","page":"Pathogens","title":"GEMS.sample_infectious_offset","text":"sample_infectious_offset(pathogen::Pathogen,  indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nReturns a randomly drawn (rounded) value from the infectious offset distribution.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.sample_length_of_stay-Tuple{Pathogen, Individual}","page":"Pathogens","title":"GEMS.sample_length_of_stay","text":"sample_length_of_stay(pathogen::Pathogen,  indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nReturns a randomly drawn (rounded) value from the time_to_hopsitalization distribution for cases with severe disease progression.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.sample_mild_death_rate-Tuple{Pathogen, Individual}","page":"Pathogens","title":"GEMS.sample_mild_death_rate","text":"sample_mild_death_rate(pathogen::Pathogen, indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nReturns a randomly drawn value from the death rate distribution for cases  with mild symptoms.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.sample_onset_of_severeness-Tuple{Pathogen, Individual}","page":"Pathogens","title":"GEMS.sample_onset_of_severeness","text":"sample_onset_of_severeness(pathogen::Pathogen,  indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nReturns a randomly drawn (rounded) value from the onset_of_symptoms distribution.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.sample_onset_of_symptoms-Tuple{Pathogen, Individual}","page":"Pathogens","title":"GEMS.sample_onset_of_symptoms","text":"sample_onset_of_symptoms(pathogen::Pathogen,  indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nReturns a randomly drawn (rounded) value from the onset_of_symptoms distribution.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.sample_self_quarantine_rate-Tuple{Pathogen, Individual}","page":"Pathogens","title":"GEMS.sample_self_quarantine_rate","text":"sample_self_quarantine_rate(pathogen::Pathogen, indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nReturns a randomly drawn value from the ICU rate distribution.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.sample_severe_death_rate-Tuple{Pathogen, Individual}","page":"Pathogens","title":"GEMS.sample_severe_death_rate","text":"sample_severe_death_rate(pathogen::Pathogen, indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nReturns a randomly drawn value from the death rate distribution for severe  disease progressions.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.sample_time_to_hospitalization-Tuple{Pathogen, Individual}","page":"Pathogens","title":"GEMS.sample_time_to_hospitalization","text":"sample_time_to_hospitalization(pathogen::Pathogen,  indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nReturns a randomly drawn (rounded) value from the time_to_hospitalization distribution for cases with severe disease progression.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.sample_time_to_icu-Tuple{Pathogen, Individual}","page":"Pathogens","title":"GEMS.sample_time_to_icu","text":"sample_time_to_icu(pathogen::Pathogen,  indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nReturns a randomly drawn (rounded) value from the time_to_icu distribution for cases with critical disease progression.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.sample_time_to_recovery-Tuple{Pathogen, Individual}","page":"Pathogens","title":"GEMS.sample_time_to_recovery","text":"sample_time_to_recovery(pathogen::Pathogen,  indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nReturns a randomly drawn (rounded) value from the time_to_recovery distribution.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.sample_ventilation_rate-Tuple{Pathogen, Individual}","page":"Pathogens","title":"GEMS.sample_ventilation_rate","text":"sample_ventilation_rate(pathogen::Pathogen, indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nReturns a randomly drawn value from the Ventilation rate distribution.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.severe_death_rate-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.severe_death_rate","text":"severe_death_rate(pathogen::Pathogen)\n\nReturns the death rate (distribution) of the pathogen in the case of severe symptoms.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.time_to_hospitalization-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.time_to_hospitalization","text":"time_to_hospitalization(pathogen::Pathogen)\n\nReturns the distribution for the time till hospitalization starting     from the onset of symptoms.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.time_to_icu-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.time_to_icu","text":"time_to_icu(pathogen::Pathogen)\n\nReturns the distribution for the time till ICU starting     from the hospitalization time.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.time_to_recovery-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.time_to_recovery","text":"time_to_recovery(pathogen::Pathogen)\n\nReturns the time to recovery (distribution) of the pathogen.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.transmission_function!-Tuple{Pathogen, TransmissionFunction}","page":"Pathogens","title":"GEMS.transmission_function!","text":"transmission_function!(pathogen::Pathogen, transFunc::TransmissionFunction)\n\nReturns the transmission_function for the pathogen.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.transmission_function-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.transmission_function","text":"transmission_function(pathogen::Pathogen)\n\nReturns the transmission_function for the pathogen.\n\n\n\n\n\n","category":"method"},{"location":"api_pathogens/#GEMS.ventilation_rate-Tuple{Pathogen}","page":"Pathogens","title":"GEMS.ventilation_rate","text":"ventilation_rate(pathogen::Pathogen)\n\nReturns the ventilation rate (distribution) of the pathogen in the case  of a critical disease progression.\n\n\n\n\n\n","category":"method"},{"location":"base-disease/#Base-Disease-Model","page":"Disease","title":"Base Disease Model","text":"","category":"section"},{"location":"base-disease/#Disease-Progression","page":"Disease","title":"Disease Progression","text":"","category":"section"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"For a given pathogen we assume a disease progression following the following diagramm.","category":"page"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"<p align=\"center\">\n    <img src=\"../assets/disease_progression_diagramm.png\" width=\"40%\"/>\n</p>","category":"page"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"An infected person will be considered exposed until they become infectious. After this they can stay without symptoms (resulting in asymptomatic cases) or progress through the pipeline above until leaving to the recovered or dead state.","category":"page"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"Throughout GEMS we use the term \"removed\" for the state of an individual leaving this disease progression by either recover from the disease or dying.","category":"page"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"Depending on the terminal state an individual reaches before being removed, we can categorize the infected individuals like in the following table.","category":"page"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"Symptoms Category Terminal State\nAsymptomatic Presymptomatic\nMild Symptomatic\nSevere Severe\nCritical Critical","category":"page"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"GEMS assigns different categories numerical values to represent them internally. Those are defined as constants within the module.","category":"page"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"Constant Value\nGEMS.SYMPTOM_CATEGORY_NOT_INFECTED 0\nGEMS.SYMPTOM_CATEGORY_ASYMPTOMATIC 1\nGEMS.SYMPTOM_CATEGORY_MILD 2\nGEMS.SYMPTOM_CATEGORY_SEVERE 3\nGEMS.SYMPTOM_CATEGORY_CRITICAL 4","category":"page"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"As the symptom category and terminal state are closely related, the terms \"exposed\" and \"asymptomatic\" might be used synonymically as well as \"mild\" and \"symptomatic\".","category":"page"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"Furthermore the progression for some symptom categories includes the need of hospitalization. Severe cases will have a given probability to need hospitalization, while criticl cases will always be hospitalized. Critical case furthermore have probability to need ventilation. Ventilated critical case have also a probability to need ICU (intensive care unit).","category":"page"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"While asymptotic cases can't die by means of the disease, all other symptom categories are assigned a certain death probability as seen in the graphic.","category":"page"},{"location":"base-disease/#Infectiousness","page":"Disease","title":"Infectiousness","text":"","category":"section"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"The infectiousness of an individual is tracked seperately from the disease state. Generally an individual should become infectious some time after becoming exposed and before getting symptoms. In asymptomatic cases, the individual will become infectious between becoming exposed and recovering from a disease.","category":"page"},{"location":"base-disease/#Age-Stratifiction","page":"Disease","title":"Age Stratifiction","text":"","category":"section"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"To estimate the disease progression, we make use of age-stratified stochastic matrices.","category":"page"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"As an example consider the age groups 0-40, 40-80 and 80+ as well as the above mentioned four symptom categories of the disease progression. A possible age stratification matrix can be given by the following 3x4 matrix.","category":"page"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"beginbmatrix\n    09  01  00  00 \n    05  03  02  00\n    00  00  05  05\nendbmatrix","category":"page"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"In this example the first row contains the probability of an individual between 0 and 40 years of age to end up in the symptom categories \"Asymptomatic\", \"Mild\", \"Severe\" or \"Critical\" in this order.","category":"page"},{"location":"base-disease/#True-vs.-Observed-Cases","page":"Disease","title":"True- vs. Observed Cases","text":"","category":"section"},{"location":"base-disease/","page":"Disease","title":"Disease","text":"We generally differentiate \"true\" cases and \"observed\" cases. While a true case is an actual infection.","category":"page"},{"location":"TriSM/#trism","page":"Interventions","title":"Base Intervention Model","text":"","category":"section"},{"location":"TriSM/","page":"Interventions","title":"Interventions","text":"<img src=\"../assets/TriSM-overview.png\" width=\"100%\"/>","category":"page"},{"location":"TriSM/","page":"Interventions","title":"Interventions","text":"⠀","category":"page"},{"location":"TriSM/","page":"Interventions","title":"Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/TriSM-example-1.png\" width=\"30%\"/>\n</p>","category":"page"},{"location":"TriSM/","page":"Interventions","title":"Interventions","text":"⠀","category":"page"},{"location":"TriSM/","page":"Interventions","title":"Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/TriSM-example-2.png\" width=\"60%\"/>\n</p>","category":"page"},{"location":"TriSM/","page":"Interventions","title":"Interventions","text":"⠀","category":"page"},{"location":"TriSM/","page":"Interventions","title":"Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/TriSM-example-3.png\" width=\"90%\"/>\n</p>","category":"page"},{"location":"TriSM/","page":"Interventions","title":"Interventions","text":"⠀","category":"page"},{"location":"api_movie/#Movie","page":"Movie","title":"Movie","text":"","category":"section"},{"location":"api_movie/#Overview-Functions","page":"Movie","title":"Overview Functions","text":"","category":"section"},{"location":"api_movie/","page":"Movie","title":"Movie","text":"Pages   = [\"api_movie.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_movie/#Functions","page":"Movie","title":"Functions","text":"","category":"section"},{"location":"api_movie/#GEMS.generate_movie","page":"Movie","title":"GEMS.generate_movie","text":"generate_movie(rd::ResultData; seconds::Int64 = 60, fps::Int64 = 24, savepath::String = \"video.mp4\")\n\nGenerates a video of the disease progression on a geographical map based on the  infections dataframe in the ResultData object. Note, that the population model used in the simulation must contain geolocated settings. Otherwise there is nothing to show. The optional parameters steer custom video length (seconds),  custom framerates (fps) and a custom filepath (savepath).\n\nWe've noticed that very large models may cause problems both in terms of runtime (too many points to put on the map for each frame) and explanatory value of the  movie (as it can result in widespread 'red surfaces'). For this reason, there is a  maximum number of points that will be put on the maps in videos. The value can be adapted via the MAX_MAP_POINTS_VIDEO constant in the constants.jl file. Generally, a value between 1,000,000 and 2,000,000 has proven to be a good maximum. If there are more geolocated infections in the ResultData object than specified in the maximum,  a subsample will be taken.\n\nParameters\n\nrd::ResultData: Data used to generate the movie (must contain the infections-dataframe with geolocations)\nseconds::Int64 = 60 (optional): Length of the video in seconds\nfps::Int64 = 24 (optoional): Frames per second\nsavepath::String = \"video.mp4\" (optional): Path to where the video shall be stored (must end in .mp4)\n\n\n\n\n\n","category":"function"},{"location":"tut_batches/#4-Running-Batches","page":"4 - Running Batches","title":"4 - Running Batches","text":"","category":"section"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"In most situations, running a simulation once is not sufficient. This tutorial teaches you how to work with so-called batches of simulations.","category":"page"},{"location":"tut_batches/#Repeating-Simulations","page":"4 - Running Batches","title":"Repeating Simulations","text":"","category":"section"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"You can instantiate a simulation multiple times and add them to a vector. The Batch(...) function creates a batch from multiple simulations. Running and post-processing of a batch works the same as for single simulations. Note that the rd variable in the example below now contains a vector of ResultData objects.","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"using GEMS\n\nsims = Simulation[]\nfor i in 1:5\n    sim = Simulation()\n    push!(sims, sim)\nend\n\nb = Batch(sims...)\nrun!(b)\nrd = ResultData(b)\ngemsplot(rd)","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Plot","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_batches.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Simulation runs are automatically named (Simulation 1, Simulation 2, ...) if no explicit label is provided. Passing a label keyword to the Simulation() function causes all simulation results of the same label to be grouped:","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"using GEMS\n\nsims = Simulation[]\nfor i in 1:5\n    sim = Simulation(label = \"My Experiment\")\n    push!(sims, sim)\nend\n\nb = Batch(sims...)\nrun!(b)\nrd = ResultData(b)\ngemsplot(rd)","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Plot","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_batches_labels.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_batches/#Sweeping-Parameter-Spaces","page":"4 - Running Batches","title":"Sweeping Parameter Spaces","text":"","category":"section"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"If you want to run simulations and systematically scan parameter spaces, you can use batches to do just that. Here's an example of how to run a basic simulation with varying transmission_rates:","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"using GEMS\n\nsims = Simulation[]\nfor i in 0:0.1:0.5\n    sim = Simulation(transmission_rate = i, label = \"Transmission Rate $i\")\n    push!(sims, sim)\nend\n\nb = Batch(sims...)\nrun!(b)\nrd = ResultData(b)\ngemsplot(rd, legend = :topright)","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Plot","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_batches_parameter-spaces.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_batches/#Running-Scenarios","page":"4 - Running Batches","title":"Running Scenarios","text":"","category":"section"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"GEMS' batch functionalities offer easy options to compare different scenarios and run multiple simulations for each of them. The example below compares a baseline scenario with a scenario with a lower transmission_rate and we assume that this is due to mask-wearing mandates. It spawns five simulations for each of the scenarios and puts them into the same batch, runs it, and visualizes the processed results:","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"using GEMS\n\nsims = Simulation[]\nfor i in 1:5\n    baseline = Simulation(transmission_rate = 0.2, label = \"Baseline\")\n    masks = Simulation(transmission_rate = 0.15, label = \"Mask Wearing\")\n    push!(sims, baseline)\n    push!(sims, masks)\nend\n\nb = Batch(sims...)\nrun!(b)\nrd = ResultData(b)\ngemsplot(rd)","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Plot","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_batches_scenarios.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Use the combined = :bylabel keyword to show both scenarios side-by-side (pass the ylims attribute to unify axis-scaling):","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"gemsplot(rd, type = :TickCases, combined = :bylabel, ylims = (0, 2000))","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Plot","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_batches_combined.png\" width=\"60%\"/>\n</p>","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Of course, all of this can also be done with much more complex intervention strategies. Please look up the interventions tutorial for examples.","category":"page"},{"location":"tut_batches/#Merging-Batches","page":"4 - Running Batches","title":"Merging Batches","text":"","category":"section"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Sometimes it's easier to build up batches individually and then merge them into one for execution. Here's an example of how that can be done based on the scenario of the previous chapter:","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"using GEMS\n\nsims1 = Simulation[]\nfor i in 1:5\n    baseline = Simulation(transmission_rate = 0.2, label = \"Baseline\")\n    push!(sims1, baseline)\nend\nb1 = Batch(sims1...)\n\nsims2 = Simulation[]\nfor i in 1:5\n    masks = Simulation(transmission_rate = 0.15, label = \"Mask Wearing\")\n    push!(sims2, masks)\nend\nb2 = Batch(sims2...)\n\ncombined_batch = merge(b1, b2)\nrun!(combined_batch)\nrd = ResultData(combined_batch)\ngemsplot(rd, type = :TickCases)","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Plot","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_batches_2.png\" width=\"60%\"/>\n</p>","category":"page"},{"location":"tut_batches/#*BatchData*-Objects","page":"4 - Running Batches","title":"BatchData Objects","text":"","category":"section"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"While ResultData objects are the processed output of single simulation runs, BatchData objects are processed output of Batches. They contain aggregated data on the simulations, e.g., the average number of total infections including standard devation, confidence intervals and ranges. While you do not necessarily need a BatchData object to plot batches, they do contain a lot of helpful data. Here's an example:","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"using GEMS\n\nsims = Simulation[]\nfor i in 1:5\n    sim = Simulation(label = \"My Experiment\")\n    push!(sims, sim)\nend\n\nb = Batch(sims...)\nrun!(b)\nbd = BatchData(b)\ntotal_infections(bd)","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Output","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"[ Info: 23:32:43 | Initializing Simulation [My Experiment] with default configuration \n...\n[ Info: 23:32:56 | Running Simulation 1/5 [My Experiment]\n[ Info: 23:32:57 | Running Simulation My Experiment\n100.0%┣████████████████████████████████████████┫ 365 days/365 days [00:30<00:00, 12 days/s]\n...\n[ Info: 23:35:44 | Processing Simulation 1/5 in Batch\n...\nDict{String, Real} with 6 entries:\n  \"upper_95\" => 76052.5\n  \"max\"      => 76088\n  \"min\"      => 75363\n  \"lower_95\" => 75415.1\n  \"mean\"     => 75733.8\n  \"std\"      => 256.672","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Run the info(...) function to get an overview of values that you can retrieve from a BatchData object by calling a function of the same name (e.g., total_infections(...)) on the BatchData object:","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"info(bd)","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Output","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"BatchData Entries\n└ meta_data\n  └ GEMS_version\n  └ id\n  └ execution_date\n└ dataframes\n  └ tick_cases\n  └ effectiveR\n  └ cumulative_disease_progressions\n  └ cumulative_quarantines\n  └ tests\n└ sim_data\n  └ total_tests\n  └ number_of_runs\n  └ attack_rate\n  └ total_infections\n  └ total_quarantines\n  └ runs\n└ system_data\n...","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"It's also possible to directly pass BatchData objects to the gemsplot() function:","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"gemsplot(bd)","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Plot","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_batches_batchdata.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"A BatchData object contains ResultData objects for each of the individual runs. Creating a BatchData object from a Batch (as in the example above), triggers the post processing for each of the simulations contained in the batch, i.e., generating their ResultData objects. You can access them like this:","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"runs(bd)","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Output","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"5-element Vector{ResultData}:\n ResultData Object\n└ Dataframes inside: 22\n└ Config file: DefaultConf.toml\n  └ Pathogens: [\"Covid19\"]\n└ Population file: Not available.\n  └ Individuals: 100000\n  └ Settings: [\"Household\", \"SchoolClass\", \"Office\"]\n└ Simulation:\n  └ Total infections: 75363\n  └ Attack rate: 0.75363\n  └ Total quarantine days: 0\n  └ Total tests: NamedTuple()\n  └ Test detection rate: 0.0\n...","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"However, these ResultData objects are generated using the batch-optimized LightRD style (look up the tutorial on  ResultDataStyles). This style does not store raw data (such as the infections dataframe) as they are usually not particularly relevant for batches, reducing the required memory significantly.","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"If you still want the raw data for each of the simulation runs, you can pass the DefaultResultData style to the BatchData(...) function. Have a look at this example showing how to still get the raw data when working with batches:","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"bd = BatchData(b, rd_style = \"DefaultResultData\")\nrns = runs(bd)\ninfections(rns[1])","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"Output","category":"page"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"[ Info: 23:38:51 | Processing Simulation 1/5 in Batch\n[ Info: 23:38:55 | Processing Simulation 2/5 in Batch\n[ Info: 23:38:59 | Processing Simulation 3/5 in Batch\n[ Info: 23:39:03 | Processing Simulation 4/5 in Batch\n[ Info: 23:39:07 | Processing Simulation 5/5 in Batch\n        23:39:12 | └ Done                                                            \n75363×47 DataFrame\n   Row │ infection_id  tick   id_a   id_b    infectious_tick  removed_tick  ⋯\n       │ Int32         Int16  Int32  Int32   Int16            Int16         ⋯ \n       ┼───────────────────────────────────────────────────────────────────────\n     1 │         1134     17  88197       1               17                ⋯    \n     2 │        35969     56  59946       2               60                ⋯\n    ⋮  |      ⋮          ⋮      ⋮      ⋮            ⋮              ⋮            ⋮     \n 75362 │        36576     56  22625   99999               56\n 75363 │         7133     34  92825  100000               36                ⋯\n38 columns and 75359 rows omitted","category":"page"},{"location":"tut_batches/#Custom-*BatchDataStyles*","page":"4 - Running Batches","title":"Custom BatchDataStyles","text":"","category":"section"},{"location":"tut_batches/","page":"4 - Running Batches","title":"4 - Running Batches","text":"t.b.d.","category":"page"},{"location":"base-config/#default-config","page":"Default Parameters","title":"Default Parameters","text":"","category":"section"},{"location":"base-config/","page":"Default Parameters","title":"Default Parameters","text":"This list shows the parameters that are applied when spawning a simulation without additonal arguments like sim = Simulation().","category":"page"},{"location":"base-config/","page":"Default Parameters","title":"Default Parameters","text":"Parameter Value\nSimulation \nTime Unit days\nGlobal setting false (single common setting for all individuals is deactivated)\nSetting types Household, SchoolClass, Office\nStart date 2024.01.01\nEnd date 2024.12.31\nStart condition 0.1% randomly infected individuals\nPopulation \nsize 100,000 individuals\nAverage household size 3 individuals\nAverage school size 100 individuals (everybody 6-18 years assigned); internally handled as SchoolClass\nAverage office size 5 individuals (everybody 18-65 years assigned)\nPathogen \nName Covid19\nTransmission rate 20% infection chance for each contact\nSymptom onset 3 days after infection (Poission-distributed)\nTime to recovery 7 days after symptom onset (Poission-distributed)\nSevereness onset 3 days after symptom onset (Poission-distributed)\nInfecious offset 1 days before symptom onset (Poission-distributed)\nDeath rate with mild progression 0%\nDeath rate with severe progression 5%\nDeath rate with critical progression 20%\nHospitalization rate 30% with severe- and 100% with critical progression\nTime to Hospitalization 7 days after symptom onset (Poission-distributed)\nLength of (hospital) stay 7 days (Poission-distributed)\nDisease progressions 40% asymptomatic, 45% mild, 10% severe, 5% critical, age-independent\nContacts \nHousehold contact rate 1 contact per day (poisson distributed), randomly drawn from member list\nSchool contact rate 1 contact per day (poisson distributed), randomly drawn from member list\nOffice contact rate 1 contact per day (poisson distributed), randomly drawn from member list\nAny other setting If you load a population model with more setting types, they will have the same parameters","category":"page"},{"location":"config-files/#config-files","page":"Config Files","title":"Config Files","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Using a config file, you can manipulate any parameter of a GEMS simulation. Although you can spawn a simulation without a config file (e.g., by just calling Simulation()), GEMS will iternally load a default config file and override the values based on the custom parameter you might have provided.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"This page gives an overview of what you can put into a config file and uses the default config file as demonstration. Config files use the *.TOML notation. When working with the Simulation() function to create a simulation, you can either use keyword arguments or a config file. Therefore, when you use a config file, you need to make sure that all parameters you want to pass are contained in the file.","category":"page"},{"location":"config-files/#Default-Config-File","page":"Config Files","title":"Default Config File","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"These are the internal defaults whenever you spawn a simulation without additional arguments. Please look up the Default Configuration section for a more readable summary of the values. If you want to set up a custom config file, you can copy this one into your own *.TOML file and change the values to your liking.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Simulation]\n\n    # seed = 1234\n    tickunit = 'd'\n    GlobalSetting = false\n    startdate = '2024.01.01'\n    enddate = '2024.12.31'\n    [Simulation.StartCondition]\n        type = \"InfectedFraction\"\n        fraction = 0.001\n        pathogen = \"Covid19\"   # BE AWARE, THAT NAME MUST BE THE SAME AS IN TOML SECTION\n\n    [Simulation.StopCriterion]\n        type = \"TimesUp\"\n        limit = 365\n\n[Population]\n    n = 100_000\n    avg_household_size = 3\n    avg_office_size = 5\n    avg_school_size = 100\n    empty = false\n\n[Pathogens]\n\n    [Pathogens.Covid19]\n        [Pathogens.Covid19.transmission_function]\n            type = \"ConstantTransmissionRate\"\n            [Pathogens.Covid19.transmission_function.parameters]\n                transmission_rate = 0.2\n\n        [Pathogens.Covid19.onset_of_symptoms]\n            distribution = \"Poisson\"\n            parameters = [3]\n\n\n        [Pathogens.Covid19.time_to_recovery]\n            distribution = \"Poisson\"\n            parameters = [7]\n\n        [Pathogens.Covid19.onset_of_severeness]\n            distribution = \"Poisson\"\n            parameters = [3]\n\n        [Pathogens.Covid19.infectious_offset]\n            distribution = \"Poisson\"\n            parameters = [1]\n\n        [Pathogens.Covid19.mild_death_rate]\n            distribution = \"Binomial\"\n            parameters = [1, 0.0]\n\n        [Pathogens.Covid19.severe_death_rate]\n            distribution = \"Binomial\"\n            parameters = [1, 0.05]\n\n        [Pathogens.Covid19.critical_death_rate]\n            distribution = \"Binomial\"\n            parameters = [1, 0.2]\n\n        [Pathogens.Covid19.hospitalization_rate]\n            distribution = \"Binomial\"\n            parameters = [1, 0.3]\n\n        [Pathogens.Covid19.ventilation_rate]\n            distribution = \"Binomial\"\n            parameters = [1, 0.3]\n\n        [Pathogens.Covid19.icu_rate]\n            distribution = \"Binomial\"\n            parameters = [1, 0.3]\n\n        [Pathogens.Covid19.time_to_hospitalization]\n            distribution = \"Poisson\"\n            parameters = [7]\n\n        [Pathogens.Covid19.time_to_icu]\n            distribution = \"Poisson\"\n            parameters = [7]\n\n        [Pathogens.Covid19.length_of_stay]\n            distribution = \"Poisson\"\n            parameters = [7]\n\n        [Pathogens.Covid19.dpr]\n        # Matrix with Disease Progression\n            age_groups = [\"0+\"]\n            disease_compartments = [\"Asymptomatic\", \"Mild\", \"Severe\", \"Critical\"]\n            stratification_matrix = [[0.4, 0.45, 0.1, 0.05]]\n\n[Settings]\n\n    [Settings.Household]\n        [Settings.Household.contact_sampling_method]\n                type = \"ContactparameterSampling\"\n\n                [Settings.Household.contact_sampling_method.parameters]\n                    contactparameter = 1.0\n\n    [Settings.Office]\n        [Settings.Office.contact_sampling_method]\n                type = \"ContactparameterSampling\"\n\n                [Settings.Office.contact_sampling_method.parameters]\n                    contactparameter = 1.0\n                    \n    [Settings.School]\n        [Settings.School.contact_sampling_method]\n                type = \"ContactparameterSampling\"\n\n                [Settings.School.contact_sampling_method.parameters]\n                    contactparameter = 1.0\n\n    [Settings.SchoolClass]\n        [Settings.SchoolClass.contact_sampling_method]\n                type = \"ContactparameterSampling\"\n\n                [Settings.SchoolClass.contact_sampling_method.parameters]\n                    contactparameter = 1.0\n\n    [Settings.Municipality]\n        [Settings.Municipality.contact_sampling_method]\n                type = \"ContactparameterSampling\"\n\n                [Settings.Municipality.contact_sampling_method.parameters]\n                    contactparameter = 1.0\n\n    [Settings.WorkplaceSite]\n        [Settings.WorkplaceSite.contact_sampling_method]\n                type = \"ContactparameterSampling\"\n\n                [Settings.WorkplaceSite.contact_sampling_method.parameters]\n                    contactparameter = 1.0\n\n    [Settings.SchoolComplex]\n        [Settings.SchoolComplex.contact_sampling_method]\n                type = \"ContactparameterSampling\"\n\n                [Settings.SchoolComplex.contact_sampling_method.parameters]\n                    contactparameter = 1.0\n\n    [Settings.SchoolYear]\n        [Settings.SchoolYear.contact_sampling_method]\n                type = \"ContactparameterSampling\"\n\n                [Settings.SchoolYear.contact_sampling_method.parameters]\n                    contactparameter = 1.0\n\n    [Settings.Department]\n        [Settings.Department.contact_sampling_method]\n                type = \"ContactparameterSampling\"\n\n                [Settings.Department.contact_sampling_method.parameters]\n                    contactparameter = 1.0\n\n    [Settings.Workplace]\n        [Settings.Workplace.contact_sampling_method]\n                type = \"ContactparameterSampling\"\n\n                [Settings.Workplace.contact_sampling_method.parameters]\n                    contactparameter = 1.0\n                    \n    [Settings.GlobalSetting]\n        [Settings.GlobalSetting.contact_sampling_method]\n                type = \"ContactparameterSampling\"\n\n                [Settings.GlobalSetting.contact_sampling_method.parameters]\n                    contactparameter = 1.0","category":"page"},{"location":"config-files/#Manipulating-Config-Files","page":"Config Files","title":"Manipulating Config Files","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"While you can adapt many parameters via the Simulation() constructor, config files are required if you want to add custom mechanics (like custom transmission functions or custom contact sampling functions). Please have a look at the tutorial for advanced parameterization.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"A config file contains four sections: [Simulation], [Population], [Pathogens], and [Settings].","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Pages   = [\"config-files.md\"]\nDepth = 3:4","category":"page"},{"location":"config-files/#Simulation","page":"Config Files","title":"Simulation","text":"","category":"section"},{"location":"config-files/#seed","page":"Config Files","title":"seed","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Random seed used for the simulation. The seed is being set upon creation of the Simulation object.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Simulation]\n    seed = 12345\n    ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The seed must be an integer value.","category":"page"},{"location":"config-files/#tickunit","page":"Config Files","title":"tickunit","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Length of a simulated timestep.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Simulation]\n    tickunit = 'd'\n    ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The tick unit can either by days('d'), hours('h'), or weeks('w').","category":"page"},{"location":"config-files/#GlobalSetting","page":"Config Files","title":"GlobalSetting","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Boolean flag that adds a single setting containing all individuals of the simulations, the GlobalSetting.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Simulation]\n    GlobalSetting = false\n    ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Can be activated or deactivated with true or false.","category":"page"},{"location":"config-files/#startdate","page":"Config Files","title":"startdate","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"t.b.d.","category":"page"},{"location":"config-files/#enddate","page":"Config Files","title":"enddate","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"t.b.d.","category":"page"},{"location":"config-files/#Population","page":"Config Files","title":"Population","text":"","category":"section"},{"location":"config-files/#n","page":"Config Files","title":"n","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The number of individuals to generate.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Population]\n    n = 100_000\n    ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Must be an integer value. This parameter does not apply if you pass a dedicated population file.","category":"page"},{"location":"config-files/#avg_household_size","page":"Config Files","title":"avg_household_size","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The average household size in a generated population.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Population]\n    avg_household_size = 3\n    ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Must be an integer value. This parameter does not apply if you pass a dedicated population file.","category":"page"},{"location":"config-files/#avg_office_size","page":"Config Files","title":"avg_office_size","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The average office size in a generated population.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Population]\n    avg_office_size = 5\n    ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Must be an integer value. This parameter does not apply if you pass a dedicated population file.","category":"page"},{"location":"config-files/#avg_school_size","page":"Config Files","title":"avg_school_size","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The average school size in a generated population. This is internally handled as SchoolClasses, as Schools are a ContainerSetting that cannot directly hold individuals. Look up the explanation of setting hierarchies.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Population]\n    avg_school_size = 100\n    ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Must be an integer value. This parameter does not apply if you pass a dedicated population file.","category":"page"},{"location":"config-files/#empty","page":"Config Files","title":"empty","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"If true, overrides all other arguments and returns a completely empty population object.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Population]\n    empty = false\n    ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Must be a boolean value.","category":"page"},{"location":"config-files/#Pathogens","page":"Config Files","title":"Pathogens","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The [Pathogens] section defines the pathogens contained in the simulation. You can define an arbitrary number of pathogens. However, currently only the first pathogen is being loaded. We are working on a multi-pathogen implementation.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Every pathogen must be defined via a dedicated section where the pathogen name is the section identifier:","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogen]\n    [Pathogens.Covid19]\n        # Pathogen Parameters\n        ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The following sections present the parameters that can be specified for a named pathogen.","category":"page"},{"location":"config-files/#transmission_function","page":"Config Files","title":"transmission_function","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Defines the routine which is used to evaluate the infection probability for any contact. This can as well be used to model immunity and waning.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19]\n        [Pathogens.Covid19.transmission_function]\n            type = \"ConstantTransmissionRate\"\n            [Pathogens.Covid19.transmission_function.parameters]\n                transmission_rate = 0.2\n                ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The type argument specifies the TransmissionFunction that conditions the dispatching to the respective transmission_probability(...) function when running GEMS. The subsequent [....parameters] section holds the arguments that the GEMS engine will pass to the TransmissionFunction struct upon initialization. Look up the tutorial on creating Custom Transmission Functions for more explanations and examples.","category":"page"},{"location":"config-files/#onset_of_symptoms","page":"Config Files","title":"onset_of_symptoms","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Speficies the distribution that is being used to draw the duration from exposure to onset of symptoms upon infection.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19]\n        [Pathogens.Covid19.onset_of_symptoms]\n            distribution = \"Poisson\"\n            parameters = [3]\n            ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The distribution argument must be a distribution of the Distributions.jl package. The parameters argument must contain a vector of arguments that are being passed to the distribution's constructor.","category":"page"},{"location":"config-files/#time_to_recovery","page":"Config Files","title":"time_to_recovery","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Speficies the distribution that is being used to draw the duration from onset of symptoms to recovery upon infection.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19]\n        [Pathogens.Covid19.time_to_recovery]\n            distribution = \"Poisson\"\n            parameters = [7]\n            ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The distribution argument must be a distribution of the Distributions.jl package. The parameters argument must contain a vector of arguments that are being passed to the distribution's constructor.","category":"page"},{"location":"config-files/#onset_of_severeness","page":"Config Files","title":"onset_of_severeness","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Speficies the distribution that is being used to draw the duration from onset of symptoms to the onset of severeness (for a severe progression) upon infection.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19]\n        [Pathogens.Covid19.onset_of_severeness]\n            distribution = \"Poisson\"\n            parameters = [3]\n            ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The distribution argument must be a distribution of the Distributions.jl package. The parameters argument must contain a vector of arguments that are being passed to the distribution's constructor.","category":"page"},{"location":"config-files/#infectious_offset","page":"Config Files","title":"infectious_offset","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Speficies the distribution that is being used to draw the duration that infectiousness sets on before the onset of symptoms upon infection.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19]\n        [Pathogens.Covid19.infectious_offset]\n            distribution = \"Poisson\"\n            parameters = [1]\n            ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The distribution argument must be a distribution of the Distributions.jl package. The parameters argument must contain a vector of arguments that are being passed to the distribution's constructor.","category":"page"},{"location":"config-files/#mild_death_rate","page":"Config Files","title":"mild_death_rate","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Speficies the distribution that determines the death probability with a mild disease progression upon infection.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19.mild_death_rate]\n        distribution = \"Binomial\"\n        parameters = [1, 0.0]\n        ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The distribution argument must be a distribution of the Distributions.jl package. The parameters argument must contain a vector of arguments that are being passed to the distribution's constructor.","category":"page"},{"location":"config-files/#severe_death_rate","page":"Config Files","title":"severe_death_rate","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Speficies the distribution that determines the death probability with a severe disease progression upon infection.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19.severe_death_rate]\n        distribution = \"Binomial\"\n        parameters = [1, 0.05]\n        ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The distribution argument must be a distribution of the Distributions.jl package. The parameters argument must contain a vector of arguments that are being passed to the distribution's constructor.","category":"page"},{"location":"config-files/#critical_death_rate","page":"Config Files","title":"critical_death_rate","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Speficies the distribution that determines the death probability with a critical disease progression upon infection.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19.critical_death_rate]\n        distribution = \"Binomial\"\n        parameters = [1, 0.2]\n        ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The distribution argument must be a distribution of the Distributions.jl package. The parameters argument must contain a vector of arguments that are being passed to the distribution's constructor.","category":"page"},{"location":"config-files/#hospitalization_rate","page":"Config Files","title":"hospitalization_rate","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Speficies the distribution that determines the hospitalization probability with a severe disease progression upon infection.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19.hospitalization_rate]\n        distribution = \"Binomial\"\n        parameters = [1, 0.3]\n        ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The distribution argument must be a distribution of the Distributions.jl package. The parameters argument must contain a vector of arguments that are being passed to the distribution's constructor.","category":"page"},{"location":"config-files/#ventilation_rate","page":"Config Files","title":"ventilation_rate","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Speficies the distribution that determines the ventilation probability with a critical disease progression upon infection.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19.ventilation_rate]\n        distribution = \"Binomial\"\n        parameters = [1, 0.3]\n        ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The distribution argument must be a distribution of the Distributions.jl package. The parameters argument must contain a vector of arguments that are being passed to the distribution's constructor.","category":"page"},{"location":"config-files/#icu_rate","page":"Config Files","title":"icu_rate","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Speficies the distribution that determines the probability of being admitted to ICU with a critical disease progression upon infection.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19.icu_rate]\n        distribution = \"Binomial\"\n        parameters = [1, 0.3]\n        ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The distribution argument must be a distribution of the Distributions.jl package. The parameters argument must contain a vector of arguments that are being passed to the distribution's constructor.","category":"page"},{"location":"config-files/#time_to_hospitalization","page":"Config Files","title":"time_to_hospitalization","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Speficies the distribution that is being used to draw the duration from onset of symptoms to hospitalization upon infection.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19]\n        [Pathogens.Covid19.time_to_hospitalization]\n            distribution = \"Poisson\"\n            parameters = [7]\n            ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The distribution argument must be a distribution of the Distributions.jl package. The parameters argument must contain a vector of arguments that are being passed to the distribution's constructor.","category":"page"},{"location":"config-files/#time_to_icu","page":"Config Files","title":"time_to_icu","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Speficies the distribution that is being used to draw the duration from hospitalization to ICU admittance upon infection.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19]\n        [Pathogens.Covid19.time_to_icu]\n            distribution = \"Poisson\"\n            parameters = [7]\n            ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The distribution argument must be a distribution of the Distributions.jl package. The parameters argument must contain a vector of arguments that are being passed to the distribution's constructor.","category":"page"},{"location":"config-files/#length_of_stay","page":"Config Files","title":"length_of_stay","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Speficies the distribution that is being used to draw the duration from hospitalization to release/recovery upon infection.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19]\n        [Pathogens.Covid19.length_of_stay]\n            distribution = \"Poisson\"\n            parameters = [7]\n            ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The distribution argument must be a distribution of the Distributions.jl package. The parameters argument must contain a vector of arguments that are being passed to the distribution's constructor.","category":"page"},{"location":"config-files/#dpr-(Disease-Progression)","page":"Config Files","title":"dpr (Disease Progression)","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Defines the severity of the disease progression by age group.","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Pathogens]\n    [Pathogens.Covid19.dpr]\n        age_groups = [\"0-10\", \"11+\"]\n        disease_compartments = [\"Asymptomatic\", \"Mild\", \"Severe\", \"Critical\"]\n        stratification_matrix = [[0.40, 0.45, 0.10, 0.05],\n                                 [0.45, 0.30, 0.20, 0.05]]\n        ...","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The age_groups argument defines the age ranges that are differentiated when evaluating the severity of disease progressions. Make sure to pass a vector of strings that contain an integer range of age-values. The \"+\" indicates that this is an \"open-end\" age range. All possible ages must be covered, therefore, you should always have a trailing \"open-end\" age range. The disease_compartments argument defines the categories of disease progressions that are being simulated. In most cases, the defaults ([\"Asymptomatic\", \"Mild\", \"Severe\", \"Critical\"]) should not be changed. The stratification_matrix must be a matrix representation that matches the age groups (rows) with the severity categories (columns). Each row must sum to 1.","category":"page"},{"location":"config-files/#Settings","page":"Config Files","title":"Settings","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The [Settings] section defines the rules for how contacts are being drawn in settings of the respective type. Setting type-specific definitions are introduced by a new subsection with the setting type as an identifier:","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Settings]\n    [Settings.Household]\n    ...","category":"page"},{"location":"config-files/#contact_sampling_method","page":"Config Files","title":"contact_sampling_method","text":"","category":"section"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"Defines the routine which is used to draw contacts in settings of the respective type in each timestep (tick).","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"[Settings]\n    [Settings.Household]\n        [Settings.Household.contact_sampling_method]\n                type = \"ContactparameterSampling\"\n                [Settings.Household.contact_sampling_method.parameters]\n                    contactparameter = 1.0","category":"page"},{"location":"config-files/","page":"Config Files","title":"Config Files","text":"The type argument specifies the ContactSamplingMethod that conditions the dispatching to the respective sample_contacts(...) function when running GEMS. The subsequent [....parameters] section holds the arguments that the GEMS engine will pass to the ContactSamplingMethod struct upon initialization. Look up the tutorial on creating Custom Contact Functions for more explanations and examples.","category":"page"},{"location":"installation/#installation","page":"Installation","title":"Full Installation Guide","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"We recommend using VSCode to work with GEMS.    In case you are new to Julia or VSCode, you might need to install and setup additional software to run GEMS. But don't worry! Please check out the installation guide below for further information about how to setup the environment for your simulations.","category":"page"},{"location":"installation/#Windows","page":"Installation","title":"Windows","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"In order to run the framework, please install the following.","category":"page"},{"location":"installation/#1.-Installing-Julia","page":"Installation","title":"1. Installing Julia","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"The GEMS framework was developed under Julia v.1.11.3. ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Download the Windows installer for version v.1.11.3 of Julia from the JuliaLang website.\nRun the installer and follow the on-screen instructions. You can generally accept the default settings. However, make sure to check the option to add the PATH variable automatically, which is NOT selected by default. Otherwise, you'll have to configure it manually as explained below. Setting the PATH variable for all users requires administration rights, so the installation of the software packages might need to be done by your IT department. If you're installing the software just for yourself, user rights are sufficient.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"info: Note\nYou can also download the latest version of Julia (if there is any newer version available), but it might cause dependency issues during the installation of GEMS that have to be resolved manually. If you run into this issue, please consult the GEMS development team.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"A system reboot might be required after installation.","category":"page"},{"location":"installation/#2.-Installing-MiKTex-and-Pandoc-(optional)","page":"Installation","title":"2. Installing MiKTex and Pandoc (optional)","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"info: Exporting Simulation Reports as pdf-Files\nThe automated simulation report generator requires Pandoc and a TeX distribution, while the HTML report does not need additional software. If the pdf-file is requested, please install the following:Pandoc\nMiKTeX (or any other distribution containing xelatex)","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"MiKTeX","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Visit the MiKTeX website.\nDownload the MiKTeX Installer for Windows.\nRun the installer and choose the \"Install MiKTeX\" option.\nFollow the on-screen instructions to complete the installation. Generally, you can accept the default settings. However, consider changing the \"ask me first\" option to prevent multiple confirmation requests when installing additional packages the first time you run GEMS.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Pandoc","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Visit the Pandoc website.\nDownload the Windows Installer for Pandoc (the name ends with windows-x86_64.msi).\nRun the installer and follow the on-screen instructions. Generally, you can accept the default settings","category":"page"},{"location":"installation/#3.-Installing-VSCode","page":"Installation","title":"3. Installing VSCode","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Visit the Visual Studio Code website.\nDownload the Windows installer for Visual Studio Code.\nRun the installer and follow the on-screen instructions. Generally, you can accept the default settings.","category":"page"},{"location":"installation/#4.-Checking-Path-Variables","page":"Installation","title":"4. Checking Path Variables","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"All previously mentioned software packages require a PATH system variable to function correctly. It is therefore worthwhile to ensure that these have been configured correctly at this point.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Open the Start menu and search for \"Environment Variables\".\nClick on \"Edit the system environment variables.\" (If you do not have admin rights or have installed the software only for your account and not system-wide use the \"Environment Variables for this account\" option instead).\nIn the System Properties window, click the \"Environment Variables\" button.\nIn the \"System Variables\" section, scroll down and find the \"Path\" variable. Select it and click \"Edit\".\nCheck that an entry for all software packages exists.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To ensure that your system can make use of all software packages you have installed, you should reboot it at this point.","category":"page"},{"location":"installation/#5.-VS-Code-Extensions","page":"Installation","title":"5. VS Code Extensions","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To use Julia in VS Code. You need to install the Julia extension for VS Code.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Open Visual Studio Code.\nGo to the Extensions view by clicking the square icon on the sidebar or pressing Ctrl + Shift + X.\nSearch for \"Julia\" in the Extensions view search bar.\nInstall the \"Julia\" extension provided by the JuliaLang organization.\nYou can now start the Julia REPL by pressing Alt + J + O in Visual Studio Code. If you are encountering errors consult the troubleshooting at the bottom.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Congratulations! You successfully set up the coding environment to use GEMS.","category":"page"},{"location":"installation/#Mac-OS","page":"Installation","title":"Mac OS","text":"","category":"section"},{"location":"installation/#1.-Installing-Julia-2","page":"Installation","title":"1. Installing Julia","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"The GEMS framework was developed under Julia v.1.11.3. ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Visit the Julia website.\nDownload the MacOS installer (usually a .dmg file) for your MacOS system for version v.1.11.3, i.e., the newest version, of Julia.\nLocate the downloaded '.dmg' file and double click on it to mount the disk image. The julia application icon should now be visible, drag the icon to the \"Aplications\" folder to install it. Setting the PATH variable for all users requires administration rights, so the installation of the software packages might need to be done by your IT department. If you're installing the software just for yourself, user rights are sufficient.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"info: Note\nYou can also download the current version of Julia by using the terminal . Start the terminal , execute the following command:  curl -fsSL https://install.julialang.org | sh","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Configuring PATH for Julia","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you want to launch Julia from the command line, first open a new terminal window, then run the following snippet from your shell (e.g., using the Terminal app, not inside the Julia prompt).","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"sudo mkdir -p /usr/local/bin\nsudo rm -f /usr/local/bin/julia\nsudo ln -s /Applications/Julia-1.10.app/Contents/Resources/julia/bin/julia /usr/local/bin/julia","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To launch Julia, simply type 'julia' inside your shell and press return.","category":"page"},{"location":"installation/#2.-Installing-MiKTex-and-Pandoc-(optional)-2","page":"Installation","title":"2. Installing MiKTex and Pandoc (optional)","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"info: Exporting Simulation Reports as pdf-Files\nThe automated simulation report generator requires Pandoc and a TeX distribution, while the HTML report does not need additional software. If the pdf-file is requested, please install the following:Pandoc\nMacTeX (or any other distribution containing xelatex)","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"MiKTeX","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Visit the MacTeX website.\nDownload the MacTex Installer.\nRun the installer and follow the on-screen instructions to complete the installation.\nA folder named TeX should now be visible in your Applications folder.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Pandoc","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Visit the Pandoc website.\nDownload the macOS Installer for Pandoc (usually a '.pkg' file ).\nRun the installer and follow the on-screen instructions. Generally, you can accept the default settings.","category":"page"},{"location":"installation/#3.-Installing-VSCode-2","page":"Installation","title":"3. Installing VSCode","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Visit the Visual Studio Code website.\nDownload the Mac installer for Visual Studio Code.\nOpen the downloaded file and drag the Visual Studio Code icon to the Applications folder to complete the installation.","category":"page"},{"location":"installation/#4.-Checking-Path-Variables-2","page":"Installation","title":"4. Checking Path Variables","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"All previously mentioned software packages require a PATH system variable to function correctly. It is therefore worthwhile to ensure that these have been configured correctly at this point.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Open the terminal and type the following commands:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"which tex","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"It should be typically something like /Library/TeX/texbin/tex.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"which pandoc","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"It should be something like /usr/local/bin/pandoc.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"which code","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"It should be something like /usr/local/bin/code.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To ensure that your system can make use of all software packages you have installed, you should reboot it at this point.","category":"page"},{"location":"installation/#5.-VS-Code-Extensions-2","page":"Installation","title":"5. VS Code Extensions","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To use Julia in VS Code. You need to install the Julia extension for VS Code.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Open Visual Studio Code.\nGo to the Extensions view by clicking the square icon on the sidebar or pressing Cmd + Shift + X.\nSearch for \"Julia\" in the Extensions view search bar.\nInstall the \"Julia\" extension provided by the JuliaLang organization.\nYou can now start the Julia REPL in Visual Studio by pressing Cmd + Shift + P to open the command palette and typing \"Julia: Start REPL\".","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Congratulations! You successfully set up the coding environment to use GEMS.","category":"page"},{"location":"tut_behavior/#10-Modelling-Behavior","page":"10 - Modelling Behavior","title":"10 - Modelling Behavior","text":"","category":"section"},{"location":"tut_behavior/","page":"10 - Modelling Behavior","title":"10 - Modelling Behavior","text":"NPIs modeling interventions cf. workshop block 3 aufsplitten ","category":"page"},{"location":"faq-page/#Frequently-Asked-Questions","page":"FAQ","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq-page/","page":"FAQ","title":"FAQ","text":"Pages   = [\"faq-page.md\"]\nDepth = 3:4","category":"page"},{"location":"faq-page/#How-do-I-run-GEMS?","page":"FAQ","title":"How do I run GEMS?","text":"","category":"section"},{"location":"faq-page/","page":"FAQ","title":"FAQ","text":"GEMS is an open Julia package. Just install Julia, and install the package as shown here. We recommend using Visual Studio Code as an IDE.","category":"page"},{"location":"faq-page/#What-are-the-system-requirements-to-run-GEMS?","page":"FAQ","title":"What are the system requirements to run GEMS?","text":"","category":"section"},{"location":"faq-page/","page":"FAQ","title":"FAQ","text":"GEMS needs roughly ~1GB of system memory per million individuals. The default model contains 100,000 individuals which should only take a couple megabytes. Post-processing takes half of the required memory. If you do not need post-processing, GEMS requires only ~500mb/million individuals.","category":"page"},{"location":"faq-page/#Can-I-add-my-own-populations-to-GEMS?","page":"FAQ","title":"Can I add my own populations to GEMS?","text":"","category":"section"},{"location":"faq-page/","page":"FAQ","title":"FAQ","text":"Yes. There are many ways to load your own population model via CSV- and JLD2 files or passing a dataframe that contains your model. Look up the tutorial on creating populations.","category":"page"},{"location":"faq-page/#Can-I-use-GEMS-in-my-research-project?","page":"FAQ","title":"Can I use GEMS in my research project?","text":"","category":"section"},{"location":"faq-page/","page":"FAQ","title":"FAQ","text":"Of course! GEMS has an open source license (GPLv3) permitting any kind of use as long as your code will be published under the same license. For any publications, please cite the papers referenced on the repository landing page.","category":"page"},{"location":"cheat-sheet/#Cheat-Sheet","page":"Cheat Sheet","title":"Cheat Sheet","text":"","category":"section"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Coming soon ...","category":"page"},{"location":"tut_reporting/#8-Reporting","page":"8 - Reporting","title":"8 - Reporting","text":"","category":"section"},{"location":"tut_reporting/","page":"8 - Reporting","title":"8 - Reporting","text":"Coming soon ...","category":"page"},{"location":"tut_reporting/#Exporting-PDF-Reports","page":"8 - Reporting","title":"Exporting PDF Reports","text":"","category":"section"},{"location":"tut_reporting/#Custom-Report-Styles","page":"8 - Reporting","title":"Custom Report Styles","text":"","category":"section"},{"location":"package-structure/#Package-Structure","page":"Package Structure","title":"Package Structure","text":"","category":"section"},{"location":"package-structure/","page":"Package Structure","title":"Package Structure","text":"How is the package structured (i.e., which folders exist in the repo)","category":"page"},{"location":"package-structure/#Folder-Structure","page":"Package Structure","title":"Folder-Structure","text":"","category":"section"},{"location":"package-structure/#applications","page":"Package Structure","title":"applications","text":"","category":"section"},{"location":"package-structure/","page":"Package Structure","title":"Package Structure","text":"contact analyses and WSC-related files","category":"page"},{"location":"package-structure/#data","page":"Package Structure","title":"data","text":"","category":"section"},{"location":"package-structure/","page":"Package Structure","title":"Package Structure","text":"testfiles test conf- and pop- files","category":"page"},{"location":"package-structure/#docs","page":"Package Structure","title":"docs","text":"","category":"section"},{"location":"package-structure/","page":"Package Structure","title":"Package Structure","text":"documentation of the functionalities and simulations","category":"page"},{"location":"package-structure/#src","page":"Package Structure","title":"src","text":"","category":"section"},{"location":"package-structure/","page":"Package Structure","title":"Package Structure","text":"main code section methods, loggers, interventions, reportings, validation","category":"page"},{"location":"package-structure/#test","page":"Package Structure","title":"test","text":"","category":"section"},{"location":"package-structure/","page":"Package Structure","title":"Package Structure","text":"tests and testdata","category":"page"},{"location":"package-structure/#misc","page":"Package Structure","title":"misc","text":"","category":"section"},{"location":"package-structure/","page":"Package Structure","title":"Package Structure","text":"everything else ","category":"page"},{"location":"package-structure/#Known-Issues","page":"Package Structure","title":"Known Issues","text":"","category":"section"},{"location":"tut_mapping/#8-Infection-Maps","page":"8 - Infection Maps","title":"8 - Infection Maps","text":"","category":"section"},{"location":"tut_mapping/","page":"8 - Infection Maps","title":"8 - Infection Maps","text":"mapping","category":"page"},{"location":"api_analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"api_analysis/","page":"Analysis","title":"Analysis","text":"with contact analysis","category":"page"},{"location":"tut_gettingstarted/#1-Getting-Started","page":"1 - Getting Started","title":"1 - Getting Started","text":"","category":"section"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"Assuming you have Julia readily installed on your machine, getting GEMS is quite straight forward. Load the package manager and install the GEMS-package:","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"using Pkg\nPkg.add(url = \"https://github.com/IMMIDD/GEMS\")\nusing GEMS","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"The tutorials make intense use of Julia's pipelining feature, utilized through the |> operator. It allows for the output of one function to be seamlessly passed as the input to another, enabling a clear and concise expression of a sequence of operations. That means: mean(squared(vector)) is the same as vector |> squared |> mean. GEMS tutorials rely heavily on this feature, therefore it's important to make sure everybody is familiar with it!","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"GEMS relies heavily on the DataFrames.jl and Plots.jl packages. Being vaguely familiar with their core functionalities might help when following these tutorials.","category":"page"},{"location":"tut_gettingstarted/#Hello-World","page":"1 - Getting Started","title":"Hello World","text":"","category":"section"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"This code creates the default simulation and runs it. It then applies default post-processing methods, genrating the ResultData object before a summary of the simulation run is being plotted.","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"using GEMS\nsim = Simulation()\nrun!(sim)\nrd = ResultData(sim)\ngemsplot(rd)","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"Output","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"[ Info: 12:09:42 | Initializing Simulation [Simulation 0] with default configuration \nand one custom parameter.\n[ Info: 12:09:42 | └ Creating population\n[ Info: 12:09:43 | └ Creating simulation object\n[ Info: 12:09:43 | Running Simulation Simulation 0\n100.0%┣████████████████████████████████████████┫ 365 days/365 days [00:18<00:00, 20 days/s]\n[ Info: 12:10:02 | Processing simulation data\n        12:10:08 | └ Done  ","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_gs_hello-world2.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_gettingstarted/#Changing-Parameters","page":"1 - Getting Started","title":"Changing Parameters","text":"","category":"section"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"You can pass a variety of keyword arguments to the Simulation() function. Try changing the general transmission rate and increasing the average household size like this:","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"using GEMS\nsim = Simulation(transmission_rate = 0.3, avg_household_size = 5)\nrun!(sim)\nrd = ResultData(sim)\ngemsplot(rd)","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"Output","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"[ Info: 12:02:08 | Initializing Simulation [Simulation 1] with default configuration \nand custom parameters.\n[ Info: 12:02:08 | └ Creating population\n[ Info: 12:02:09 | └ Creating simulation object\n[ Info: 12:02:10 | Running Simulation Simulation 1\n100.0%┣████████████████████████████████████████┫ 365 days/365 days [00:16<00:00, 23 days/s]\n[ Info: 12:02:26 | Processing simulation data\n        12:02:36 | └ Done  ","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_gs_custom-parameters2.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"info: Where's the list of parameters I can change?\nPut a ? into the Julia REPL and call help?> Simulation to get an overview of arguments that you can pass to customize a simulation or look up the Simulation section of the API documentation.","category":"page"},{"location":"tut_gettingstarted/#Passing-Parameters-as-Dictionaries","page":"1 - Getting Started","title":"Passing Parameters as Dictionaries","text":"","category":"section"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"Sometimes having long function calls with many parameters is confusing. In GEMS, you can define a dictionary of parameters and pass it to the Simulation() function. The respective arguments must be stored as symbols (with a leading :):","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"pars = Dict(\n    :transmission_rate => 0.3,\n    :avg_household_size => 5\n)\nsim = Simulation(pars)\nrun!(sim)","category":"page"},{"location":"tut_gettingstarted/#Comparing-Scenarios","page":"1 - Getting Started","title":"Comparing Scenarios","text":"","category":"section"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"GEMS makes it very easy to run and compare infection scenarios. Here's an example that spanws two simulations, runs them, and calls the gemsplot() function with a vector of ResultData objects:","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"using GEMS\nsim1 = Simulation(label = \"Baseline\")\nsim2 = Simulation(transmission_rate = 0.3, avg_household_size = 5, label = \"More Infectious\")\nrun!(sim1)\nrun!(sim2)\nrd1 = ResultData(sim1)\nrd2 = ResultData(sim2)\ngemsplot([rd1, rd2])","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"Output","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"[ Info: 12:11:49 | Initializing Simulation [Baseline] with default configuration \nand one custom parameter.\n[ Info: 12:11:49 | └ Creating population\n[ Info: 12:11:51 | └ Creating simulation object\n[ Info: 12:11:51 | Initializing Simulation [More Infectious] with default \nconfiguration and custom parameters.\n[ Info: 12:11:51 | └ Creating population\n[ Info: 12:11:53 | └ Creating simulation object\n[ Info: 12:11:55 | Running Simulation Baseline\n100.0%┣█████████████████████████████████████████┫ 365 days/365 days [00:40<00:00, 9 days/s]\n[ Info: 12:12:35 | Running Simulation More Infectious\n100.0%┣████████████████████████████████████████┫ 365 days/365 days [00:35<00:00, 10 days/s]\n[ Info: 12:13:10 | Processing simulation data\n        12:13:15 | └ Done ","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_gs_comparing-scenarios.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"Pass the combined = :bylabel keyword to show the results side-by-side:","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"gemsplot([rd1, rd2], combined = :bylabel)","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_gs_comparing-scenarios-combined.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_gettingstarted/#Getting-the-Raw-Data","page":"1 - Getting Started","title":"Getting the Raw Data","text":"","category":"section"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"Both raw data (via the internal loggers) and processed data (via the ResultData object) are accessible. Try this to run a simulation and get the infections as a dataframe. Then visualize it using VSCode's internal table printing feature (of course only if you are using Visual Studio Code as your IDE):","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"using GEMS\nsim = Simulation()\nrun!(sim)\ndf = sim |> infectionlogger |> dataframe\nvscodedisplay(df)","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_gs_vs_code_table.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_gettingstarted/","page":"1 - Getting Started","title":"1 - Getting Started","text":"info: What do the columns mean?\nPut a ? into the Julia REPL and call help?> InfectionLogger to get an overview of what the InfectionLogger stores or look up the Logger section of the API documentation.","category":"page"},{"location":"api_logger/#Logger","page":"Logger","title":"Logger","text":"","category":"section"},{"location":"api_logger/#Overview-Structs","page":"Logger","title":"Overview Structs","text":"","category":"section"},{"location":"api_logger/","page":"Logger","title":"Logger","text":"Pages   = [\"api_logger.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_logger/#Overview-Functions","page":"Logger","title":"Overview Functions","text":"","category":"section"},{"location":"api_logger/","page":"Logger","title":"Logger","text":"Pages   = [\"api_logger.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_logger/#Structs","page":"Logger","title":"Structs","text":"","category":"section"},{"location":"api_logger/#GEMS.Logger","page":"Logger","title":"GEMS.Logger","text":"Supertype for all Loggers\n\n\n\n\n\n","category":"type"},{"location":"api_logger/#GEMS.CustomLogger","page":"Logger","title":"GEMS.CustomLogger","text":"CustomLogger <: TickLogger\n\nStruct to specify custom logging mechanisms. The constructor takes an arbitrary number of keyworded arguments that are each a function with exactly one argument (the Sim-object)\n\nExample\n\nThis instance of the CustomLogger would extract the number of  infected inividuals, each time the log!-function is called.\n\ncl = CustomLogger(infected = sim -> count(infected, sim |> population))\nlog!(cl, sim)\n\nResult\n\n    1×2 DataFrame\n     Row │ infected  tick \n         │ Any       Any  \n    ─────┼────────────────\n       1 │ 106       0\n\nNote\n\nThe function that fires the loggers fire_custom_loggers(sim::Simulation) is defined in the simulation methods script as the simulation object needs to be \"known\" for \"all access\".\n\n\n\n\n\n","category":"type"},{"location":"api_logger/#GEMS.DeathLogger","page":"Logger","title":"GEMS.DeathLogger","text":"DeathLogger <: EventLogger\n\nA logging structure specifically for deaths. A death event is given by all entrys of the field-vectors at a given index.\n\nFields\n\nid::Vector{Int32}: Identifiers of the agents that died\ntick::Vector{Int16}: Ticks of death\nlock::ReentrantLock: A lock for parallelised code to use to guarantee data race free    conditions when working with this setting.\n\n\n\n\n\n","category":"type"},{"location":"api_logger/#GEMS.EventLogger","page":"Logger","title":"GEMS.EventLogger","text":"Supertype for all Loggers, which are logging certain events\n\n\n\n\n\n","category":"type"},{"location":"api_logger/#GEMS.InfectionLogger","page":"Logger","title":"GEMS.InfectionLogger","text":"InfectionLogger <: EventLogger\n\nA logging structure specifically for infections. An infection event is given by all entries of the field-vectors at a given index.\n\nFields\n\nid_a::Vector{Int32}: Identifiers of the agents that are infecting\nid_b::Vector{Int32}: Identifiers of the agents to be infected\ninfectious_tick::Vector{Int16}: Ticks of infected to become infectious\nsymptoms_tick::Vector{Int16}: Tick at which infectee develops symptoms (-1 if not at all)\nsevereness_tick::Vector{Int16}: Tick at which infectee develops severe symptoms (-1 if not at all)\nhospital_tick::Vector{Int16}: Tick at which infectee is admitted to the hospital (-1 if not at all)\nicu_tick::Vector{Int16}: Tick at which infectee is admitted to the icu (-1 if not at all)\nventilation_tick::Vector{Int16}: Tick at which infectee needs ventilation (-1 if not at all)\nremoved_tick::Vector{Int16}: Ticks of agents to be recovered\ndeath_tick::Vector{Int16}: Ticks of death (if caused by this infection)\nsymptom_category::Vector{Int8}: Symptom Category of the disease progression    of the infection\ntick::Vector{Int16}: Ticks of infections\nsetting_id::Vector{Int32}: Identifiers of settings where the infections happened\nsetting_type::Vector{Char}: Types of settings where the infections happened\nlat::Float32: Latitude of infection event location\nlon::Float32: Longitude of infection event location\nags::Vector{Int32}: AGS of the settings where the infections happened\nlock::ReentrantLock: A lock for parallelised code to use to guarantee data race free    conditions when working with this logger.\n\n\n\n\n\n","category":"type"},{"location":"api_logger/#GEMS.PoolTestLogger","page":"Logger","title":"GEMS.PoolTestLogger","text":"PoolTestLogger <: EventLogger\n\nA logging structure specifically for pool tests. Pool tests take multiple individuals and evaluate whether at least one of them is infected. A test event is given by all entries of the field-vectors at a given index.\n\nFields\n\nsetting_id::Vector{Int32}: Identifiers of the setting this pooled test happened\nsetting_type{Char}: Setting type where this pool test was applied\ntest_tick::Vector{Int16}: Ticks of test\ntest_result::Vector{Boolean}: Result of the test\nno_of_individuals::Vector{Int32}: Number of tested individuals\nno_of_infected::Vector{Int32}: Number of actually infected individuals\ntest_type::Vector{String}: Type of the applied test\nlock::ReentrantLock: A lock for parallelised code to use to guarantee data race free    conditions when working with this logger.\n\n\n\n\n\n","category":"type"},{"location":"api_logger/#GEMS.QuarantineLogger","page":"Logger","title":"GEMS.QuarantineLogger","text":"QuarantineLogger <: TickLogger\n\nA logging structure to track the number of quarantined individuals stratified by occupation status (worker, school, all).\n\nFields\n\ntick::Vector{Int16}: Simulation tick\nquarantined::Vector{Int64}: Overall number of quarantined individuals at the given tick\nstudents::Vector{Int64}: Number of quarantined students at the given tick\nworkers::Vector{Int64}: Number of quarantined workers at the given tick\nlock::ReentrantLock: A lock for parallelised code to use to guarantee data race free    conditions when working with this logger.\n\n\n\n\n\n","category":"type"},{"location":"api_logger/#GEMS.TestLogger","page":"Logger","title":"GEMS.TestLogger","text":"TestLogger <: EventLogger\n\nA logging structure specifically for tests. A test event is given by all entries of the field-vectors at a given index.\n\nFields\n\nid::Vector{Int32}: Identifiers of the agents that got testet\ntest_tick::Vector{Int16}: Ticks of test\ntest_result::Vector{Bool}: Result of the test\ninfected::Vector{Bool}: Actual infection state \ninfection_id::Vector{Int32}: ID of current infection (if infected)\ntest_type::Vector{String}: Type of the applied test\nreportable::Vector{Bool}: Flag whether this test will be considered for the \"detected\" cases (i.e. \"reported\")\nlock::ReentrantLock: A lock for parallelised code to use to guarantee data race free    conditions when working with this logger.\n\n\n\n\n\n","category":"type"},{"location":"api_logger/#GEMS.TickLogger","page":"Logger","title":"GEMS.TickLogger","text":"Supertype for all Loggers, which are logging per tick\n\n\n\n\n\n","category":"type"},{"location":"api_logger/#Functions","page":"Logger","title":"Functions","text":"","category":"section"},{"location":"api_logger/#GEMS.dataframe-Tuple{CustomLogger}","page":"Logger","title":"GEMS.dataframe","text":"dataframe(cl::CustomLogger)\n\nReturns the internal dataframe of the CustomLogger.\n\n\n\n\n\n","category":"method"},{"location":"api_logger/#GEMS.dataframe-Tuple{DeathLogger}","page":"Logger","title":"GEMS.dataframe","text":"dataframe(deathlogger::DeathLogger)\n\nReturn a DataFrame holding the informations of the logger.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Tick of the death event\nid Int32 Individual id\n\n\n\n\n\n","category":"method"},{"location":"api_logger/#GEMS.dataframe-Tuple{InfectionLogger}","page":"Logger","title":"GEMS.dataframe","text":"dataframe(logger::InfectionLogger)\n\nReturn a DataFrame holding the informations of the logger.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ninfection_id Int32 Identifier of this infection event\ntick Int16 Tick of the infection event\nid_a Int32 Infecter id\nid_b Int32 Infectee id\ninfectious_tick Int16 Tick at which infectee becomes infectious\nsymptoms_tick Int16 Tick at which infectee develops symptoms (-1 if not at all)\nremoved_tick Int16 Tick at which infectee becomes removed (recovers)\ndeath_tick Int16 Tick at which infectee dies\nsymptom_category Int8 Last state of disease progression before recovery\nsetting_id Int32 Id of setting in which infection happens\nsetting_type Char setting type of the infection setting\nags Int32 AGS of the infection setting\nsource_infection_id Int32 Id of the infecter's infection event\n\n\n\n\n\n","category":"method"},{"location":"api_logger/#GEMS.dataframe-Tuple{PoolTestLogger}","page":"Logger","title":"GEMS.dataframe","text":"dataframe(poollogger::PoolTestLogger)\n\nReturn a DataFrame holding the informations of the logger.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntest_tick Int16 Tick of the test event\nsetting_id Int32 Setting id of the tested pool\nsetting_type Int32 Setting type\ntest_result Bool Test result (pos./neg.)\nno_of_individuals Int32 Number of tested individuals\nno_of_infected Int32 Number of actually infected individuals\ntest_type String Name of test type\n\n\n\n\n\n","category":"method"},{"location":"api_logger/#GEMS.dataframe-Tuple{QuarantineLogger}","page":"Logger","title":"GEMS.dataframe","text":"dataframe(quarantinelogger::QuarantineLogger)\n\nReturn a DataFrame holding the informations of the logger.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Simulation tick\nquarantined Int64 Total quarantined individuals\nstudents Int64 Quarantined students\nworkers Int64 Quarantined workers\n\n\n\n\n\n","category":"method"},{"location":"api_logger/#GEMS.dataframe-Tuple{TestLogger}","page":"Logger","title":"GEMS.dataframe","text":"dataframe(testlogger::TestLogger)\n\nReturn a DataFrame holding the informations of the logger.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntest_id Int32 ID of test in this logger\ntick Int16 Tick of the test\nid Int32 Individual id\ntest_result Bool Test result (pos./neg.)\ninfected Bool Actual infection state\ninfection_id Int32 ID of current infection (if infected)\ntest_type String Name of test type\nreportable Bool If true, this test causes the case to be \"reported\"\n\n\n\n\n\n","category":"method"},{"location":"api_logger/#GEMS.dataframe-Tuple{VaccinationLogger}","page":"Logger","title":"GEMS.dataframe","text":"dataframe(vacclogger::VaccinationLogger)\n\nReturn a DataFrame holding the informations of the logger.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\ntick Int16 Tick of the vaccination event\nid Int32 Individual id\n\n\n\n\n\n","category":"method"},{"location":"api_logger/#GEMS.duplicate-Tuple{CustomLogger}","page":"Logger","title":"GEMS.duplicate","text":"duplicate(cl::CustomLogger)\n\nCreates a new CustomLogger instance with the same parameters of the argument CustomLogger.\n\n\n\n\n\n","category":"method"},{"location":"api_logger/#GEMS.get_infections_between-Tuple{InfectionLogger, Int32, Int16, Int16}","page":"Logger","title":"GEMS.get_infections_between","text":"get_infections_between(logger::InfectionLogger, infecter::Int32, start_tick::Int16, end_tick::Int16)\n\nReturns the id of infected individuals who's infection time t is start_tick <= t <= end_tick)\n\nParameters\n\nlogger::InfectionLogger: Logger instance\ninfecter::Int32: ID of infecter individual that is used to filter secondary infections \nstart_tick::Int16: Lower bound (time)\nend_tick::Int16: Upper bound (time)\n\nReturns\n\nVector{Int32}: List of IDs of infected individuals\n\n\n\n\n\n","category":"method"},{"location":"api_logger/#GEMS.infectionlogger-Tuple{Simulation}","page":"Logger","title":"GEMS.infectionlogger","text":"infectionlogger(simulation)\n\nReturns the InfectionLogger of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_logger/#Base.length","page":"Logger","title":"Base.length","text":"length(logger::InfectionLogger)\n\nReturns the number of entries in a InfectionLogger.\n\n\n\n\n\nlength(logger::VaccinationLogger)\n\nReturns the number of entries in a VaccinationLogger.\n\n\n\n\n\nlength(logger::DeathLogger)\n\nReturns the number of entries in a DeathLogger.\n\n\n\n\n\nlength(logger::TestLogger)\n\nReturns the number of entries in a TestLogger.\n\n\n\n\n\nlength(logger::PoolTestLogger)\n\nReturns the number of entries in a PoolTestLogger.\n\n\n\n\n\nlength(logger::QuarantineLogger)\n\nReturns the number of entries in a QuarantineLogger.\n\n\n\n\n\nlength(logger::CustomLogger)\n\nReturns the number of entries in a CustomLogger.\n\n\n\n\n\nlength(eq::EventQueue)\n\nReturns the number of Events in the EventQueue.\n\n\n\n\n\n","category":"function"},{"location":"api_logger/#GEMS.log!","page":"Logger","title":"GEMS.log!","text":"log!(logger::InfectionLogger, a::Int32, b::Int32, tick::Int16, infectious_tick::Int16,\nsymptoms_tick::Int16, severeness_tick::Int16, hospital_tick::Int16, icu_tick::Int16,\nventilation_tick::Int16, removed_tick::Int16, death_tick::Int16, symptom_category::Int8,\nsetting_id::Int32, setting_type::Char, lat::Float32, lon::Float32, ags::Int32,\nsource_infection_id::Int32)\n\nLogs an infection event into the specified InfectionLogger. Returns a new infection_id for the newly added infection.\n\nParameters\n\nlogger::InfectionLogger: Logger instance\na::Int32: ID of infecting individual\nb::Int32: ID of infected individual\ntick::Int16: Current simultion tick\ninfectious_tick::Int16: Tick of individual becoming infectious \nsymptoms_tick::Int16: Tick of individual becoming symptomatic\nsevereness_tick::Int16: Tick of individual becoming a severe case\nhospital_tick::Int16: Tick of individual being hospitalized\nicu_tick::Int16:  Tick of individual being admitted to ICU\nventilation_tick::Int16: Tick of individual being admitted to ventilation\nremoved_tick::Int16: Tick of individual recovering/dying\ndeath_tick::Int16: Tick of individual death (if died)\nsymptom_category::Int8: Symptom category\nsetting_id::Int32: ID of setting this infection happend in\nsetting_type::Char: Setting type as char (e.g. \"h\" for Household)\nlat::Float32: Latitude of infection location (obatained from the setting)\nlon::Float32: Longitude of infection location (obatained from the setting)\nags::Int32: Amtlicher Gemeindeschlüssel (community identification number) of the region this infection happened in\nsource_infection_id::Int32: Current infection ID of the infecting individual\n\nReturns\n\nInt32: New infection ID\n\n\n\n\n\nlog!(vacclogger::VaccinationLogger, id::Int32, tick::Int16)\n\nLogs a vaccination event into the specified VaccinationLogger.\n\nParameters\n\nvacclogger::VaccinationLogger: Logger instance\nid::Int32: ID of the vaccinated individual\ntick::Int16: Time of vaccination\n\n\n\n\n\nlog!(deathlogger::DeathLogger, id::Int32, tick::Int16)\n\nLogs a death event into the specified DeathLogger.\n\nParameters\n\ndeathlogger::DeathLogger: Logger instance\nid::Int32: ID of deceased individual\ntick::Int16: Time of death\n\n\n\n\n\nlog!(testlogger::TestLogger, id::Int32, test_tick::Int16, test_result::Bool,\n    infected::Bool, infection_id::Int32, test_type::String, reportable::Bool)\n\nLogs a test event into the specified TestLogger.\n\nParameters\n\ntestlogger::TestLogger: Logger instance\nid::Int32: ID of individual that is being tested\ntest_tick::Int16: Time of test\ntest_result::Bool: Test result\ninfected::Bool: Actual infection state\ninfection_id::Int32: ID of infection\ntest_type::String: Name of the respective TestType (e.g., \"PCR\")\nreportable::Bool: Flag whether a positive test result will be reported\n\n\n\n\n\nlog!poollogger::PoolTestLogger, setting_id::Int32, setting_type::Char, test_tick::Int16,\n    test_result::Bool, no_of_individuals::Int16, no_of_infected::Int16, test_type::String)\n\nLogs a test event into the specified PoolTestLogger.\n\nParameters\n\npoollogger::PoolTestLogger: Logger instance\nsetting_id::Int32: ID of setting that is being pool-tested\nsetting_type::Char: Setting type as char (e.g. \"h\" for Household)\ntest_tick::Int16: Time of test\ntest_result::Bool: Test result\nno_of_individuals::Int16: Number of individuals n the tested set of inividuals\nno_of_infected::Int16: Actual number of infected individuals in the tested set of individuals\ntest_type::String: Name of the respective TestType (e.g., \"PCR\")\n\n\n\n\n\nlog!(quarantinelogger::QuarantineLogger, tick::Int16,\n    quarantined::Int64, students::Int64, workers::Int64)\n\nLogs a the number of quarantined individuals stratified by occupation in a QuarantineLogger.\n\nParameters\n\nquarantinelogger::QuarantineLogger: Logger instance\ntick::Int16: Current tick\nquarantined::Int64: Overall number of quarantined individuals\nstudents::Int64: Number of quarantined students\nworkers::Int64: Number of quarantined workers\n\n\n\n\n\n","category":"function"},{"location":"api_logger/#GEMS.lognow","page":"Logger","title":"GEMS.lognow","text":"lognow()\n\nReturns the current time in HH:MM:SS format for logging purposes.\n\n\n\n\n\n","category":"function"},{"location":"api_logger/#GEMS.save-Tuple{DeathLogger, AbstractString}","page":"Logger","title":"GEMS.save","text":"save(deathlogger::DeathLogger, path::AbstractString)\n\nSave the logger to a CSV-file at the specified path.\n\n\n\n\n\n","category":"method"},{"location":"api_logger/#GEMS.save-Tuple{InfectionLogger, AbstractString}","page":"Logger","title":"GEMS.save","text":"save(logger::InfectionLogger, path::AbstractString)\n\nSave the logger to a CSV-file at the specified path.\n\n\n\n\n\n","category":"method"},{"location":"api_logger/#GEMS.save-Tuple{PoolTestLogger, AbstractString}","page":"Logger","title":"GEMS.save","text":"save(poollogger::PoolTestLogger, path::AbstractString)\n\nSave the logger to a CSV-file at the specified path.\n\n\n\n\n\n","category":"method"},{"location":"api_logger/#GEMS.save-Tuple{TestLogger, AbstractString}","page":"Logger","title":"GEMS.save","text":"save(testlogger::TestLogger, path::AbstractString)\n\nSave the logger to a CSV-file at the specified path.\n\n\n\n\n\n","category":"method"},{"location":"api_logger/#GEMS.save_JLD2","page":"Logger","title":"GEMS.save_JLD2","text":"save_JLD2(logger::InfectionLogger, path::AbstractString)\n\nSave the logger to a JLD2 file.\n\n\n\n\n\nsave_JLD2(vacclogger::VaccinationLogger, path::AbstractString)\n\nSave the vaccination logger to a JLD2 file.\n\n\n\n\n\nsave_JLD2(deathlogger::DeathLogger, path::AbstractString)\n\nSave the death logger to a JLD2 file.\n\n\n\n\n\nsave_JLD2(testlogger::TestLogger, path::AbstractString)\n\nSave the test logger to a JLD2 file.\n\n\n\n\n\nsave_JLD2(poollogger::PoolTestLogger, path::AbstractString)\n\nSave the pool test logger to a JLD2 file.\n\n\n\n\n\n","category":"function"},{"location":"api_logger/#GEMS.ticks-Tuple{InfectionLogger}","page":"Logger","title":"GEMS.ticks","text":"ticks(logger::InfectionLogger)\n\nReturns a vector of ticks with logging events.\n\n\n\n\n\n","category":"method"},{"location":"tut_exploring/#2-Exploring-Models","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"","category":"section"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"This tutorial shows you how to easily navigate through model components.","category":"page"},{"location":"tut_exploring/#Exploring-Individuals","page":"2 - Exploring Models","title":"Exploring Individuals","text":"","category":"section"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Using the individuals() function on the simulation object is the easiest way to access the agents. The example below returns the vector of individuals:","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"using GEMS\nsim = Simulation()\nindividuals(sim)","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Output","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"[ Info: 21:36:54 | Initializing Simulation [Simulation 1] with default configuration \nand one custom parameter.\n[ Info: 21:36:54 | └ Creating population\n[ Info: 21:36:55 | └ Creating simulation object\n100000-element Vector{Individual}:\n Individual(1, 1, 6, -1, -1, 0.0f0, 0.0f0, Bool[], false, ...\n Individual(2, 2, 19, -1, -1, 0.0f0, 0.0f0, Bool[], false, ...\n ⋮\n Individual(99999, 2, 57, -1, -1, 0.0f0, 0.0f0, Bool[], false, ...\n Individual(100000, 2, 37, -1, -1, 0.0f0, 0.0f0, Bool[], false, ...","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Please be aware that the individual id is NOT necessarily matching their index in the individuals-vector.","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"If you are interested in a particular attribute (e.g., the age) of all individuals, you can call the respective getter-function on the vector using a . which applies is to all individuals:","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"using GEMS\nsim = Simulation()\ninds = individuals(sim)\nage.(inds)","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Output","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"[ Info: 21:40:00 | Initializing Simulation [Simulation 2] with default configuration\nand one custom parameter.\n[ Info: 21:40:00 | └ Creating population\n[ Info: 21:40:02 | └ Creating simulation object\n100000-element Vector{Int8}:\n 61\n 67\n  ⋮\n 59\n 12","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"info: Where's the list of attributes I can access?\nPut a ? into the Julia REPL and call help?> Individual to get an overview of fields that are stored for each individual or look up the Individuals section of the API documentation. Allmost every field has a function of the same name (e.g.g, age()) to get its value","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"A more comprehensive overview of the individuals in a population can be achieved via the Population-object. The example below generates a dataframe with one row per individual in the population:","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"using GEMS\nsim = Simulation()\npop = population(sim)\ndataframe(pop)","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Output","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"[ Info: 21:40:37 | Initializing Simulation [Simulation 3] with default configuration \nand one custom parameter.\n[ Info: 21:40:37 | └ Creating population\n[ Info: 21:40:39 | └ Creating simulation object\n100000×10 DataFrame\n    Row │ id      sex   age   number_of_vaccinations  vaccination_tick  education  ⋯\n        │ Int32   Int8  Int8  Int8                    Int16             Int8       ⋯\n────────┼─────────────────────────────────────────────────────────────────────────────\n      1 │      1     2    43                       0                -1         -1  ⋯\n      2 │      2     1    50                       0                -1         -1  ⋯\n   ⋮    │   ⋮      ⋮     ⋮              ⋮                    ⋮              ⋮          ⋮ \n  99999 │  99999     1     5                       0                -1         -1  ⋯  \n 100000 │ 100000     1    42                       0                -1         -1  ⋯ \n99996 rows omitted   ","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Additionally, there are a number of functions allowing you to check an individual's infection- or quarantine status. This example checks if the first individual in the list of individuals is infected:","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"using GEMS\nsim = Simulation()\nfirst_ind = individuals(sim) |> first\ninfected(first_ind)","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Output","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"[ Info: 21:42:31 | Initializing Simulation [Simulation 4] with default configuration\nand one custom parameter.\n[ Info: 21:42:31 | └ Creating population\n[ Info: 21:42:35 | └ Creating simulation object\nfalse","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Other useful status check functions are exposed(), infectious(), isquarantined(), quarantine_status(), hospital_status(), hospitalized(), ventilated(), dead(), isdetected(), and isvaccinated(). For a full list, please look up the Individuals section of the API documentation.","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Individuals are associated with at least one setting (the household). You can access them using the respective access functions. Please note, that these setting access functions require the Simulation object to be passed (for internal performance reasons).","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"using GEMS\nsim = Simulation()\nfirst_ind = individuals(sim) |> first\nhousehold(first_ind, sim)","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Output","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"[ Info: 21:43:20 | Initializing Simulation [Simulation 5] with default configuration \nand one custom parameter.\n[ Info: 21:43:20 | └ Creating population\n[ Info: 21:43:21 | └ Creating simulation object\nHousehold\n  id: Int32 1\n  individuals: Array{Individual}((3,))\n  income: Int8 -1\n  dwelling: Int8 -1\n  last_infectious: Int16 -1\n  contact_sampling_method: ContactparameterSampling\n  ags: AGS\n  lon: Float32 NaN32\n  lat: Float32 NaN32\n  isactive: Bool false\n  isopen: Bool true\n  lock: ReentrantLock","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Also try office(i), schoolclass(i), or municipality(i). If an individual is not assigned to the respective setting (e.g., a child not being assigned to an office), these functions will throw an exception. You can make sure to not call these functions for individuals without a valid assignment by verifying is_working(i) or is_student(i) first.","category":"page"},{"location":"tut_exploring/#Adjusting-Individuals","page":"2 - Exploring Models","title":"Adjusting Individuals","text":"","category":"section"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"You can esaily adjust individuals' attribute values. This example selects the first individual from the list of individuals and updates its age to 15:","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"using GEMS\nsim = Simulation()\nfirst_ind = individuals(sim) |> first\nfirst_ind.age = 15","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"warning: Caution\nPlease only touch individuals' attribute values if you really know what you are doing. This can potentially invalidate input population models or result in errors when the internal model structure is compromised (e.g., by assigning individuals to non-existent settings)","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"More elaborate ajustments can be made using the each! function on the Population object. Please look up the \"Creating Populations\" tutorial to learn how to ajust populations.","category":"page"},{"location":"tut_exploring/#Exploring-Settings","page":"2 - Exploring Models","title":"Exploring Settings","text":"","category":"section"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Here's how you access all settings that are available in a given simulation:","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"using GEMS\nsim = Simulation()\nsettings(sim)","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Output","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"[ Info: 21:44:52 | Initializing Simulation [Simulation 6] with default configuration \nand one custom parameter.\n[ Info: 21:44:52 | └ Creating population\n[ Info: 21:44:54 | └ Creating simulation object\nDict{DataType, Vector{Setting}} with 3 entries:\n  Household   => [Household(1, Individual[Individual(1, 2, 29, -1, -1, 0.0, 0.0, Bool[],…  \n  SchoolClass => [SchoolClass(1, Individual[Individual(9, 1, 7, -1, -1, 0.0, 0.0, Bool[],…\n  Office      => [Office(1, Individual[Individual(1, 2, 29, -1, -1, 0.0, 0.0, Bool[],…","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"The above example returns a dictionary where the key is the setting type and the value being the list of settings of that type. If you want a particular setting type, you can either pass the respective key to the settings dictionary like settings(sim)[Household] or use the prefined access functions, e.g., households(sim):","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"using GEMS\nsim = Simulation()\nhouseholds(sim)","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Output","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"[ Info: 21:45:33 | Initializing Simulation [Simulation 7] with default configuration \nand one custom parameter.\n[ Info: 21:45:33 | └ Creating population\n[ Info: 21:45:35 | └ Creating simulation object\n33334-element Vector{Setting}:\n Household\n  id: Int32 1\n  individuals: Array{Individual}((2,))\n  income: Int8 -1\n  dwelling: Int8 -1\n  last_infectious: Int16 -1\n  contact_sampling_method: ContactparameterSampling\n  ags: AGS\n  lon: Float32 NaN32\n  lat: Float32 NaN32\n  isactive: Bool false\n  isopen: Bool true\n  lock: ReentrantLock\n ⋮","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Similar to what we did with the individuals, you can run analyses on a collection of settings calling getter functions (e.g., size(s)) for a vector of settings using .. In the example below, we extract the size (number of assigned individuals) for each household and plot them in a histogram:","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"using GEMS, Plots\nsim = Simulation()\nhhlds = households(sim)\nhh_sizes = size.(hhlds)\nhistogram(hh_sizes, xlabel = \"Household Size\", label = \"Number of Households\")","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Plot","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_em_histogram.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_exploring/#Traversing","page":"2 - Exploring Models","title":"Traversing","text":"","category":"section"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"The previous examples demonstrated how you get from an individual to its settings. Of course, you can go the other way around and access all individuals of a setting. Moreover, you can traverse through the bi-partite graph (of individuals and settings) which is an important feature, e.g., to propagate intervention measures. Here's an example how to get the household members of an individual. To make sure, the individual is not living in a single-person houshold, we increase the average household size in our experiment. the id.() function gives us the IDs of all members (just for better readability). You see that the first ID is 1, as we select the first individual in the list and look into their household:","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"using GEMS\nsim = Simulation(avg_household_size = 10)\nfirst_ind = individuals(sim) |> first\nhh = household(first_ind, sim)\nhh_members = individuals(hh)\nid.(hh_members)","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"Output","category":"page"},{"location":"tut_exploring/","page":"2 - Exploring Models","title":"2 - Exploring Models","text":"[ Info: 21:50:17 | Initializing Simulation [Simulation 9] with default configuration \nand custom parameters.\n[ Info: 21:50:18 | └ Creating population\n[ Info: 21:50:20 | └ Creating simulation object\n10-element Vector{Int32}:\n     1\n 20643\n 23586\n     ⋮\n 57705\n 87052\n 94858","category":"page"},{"location":"#home","page":"Home","title":"GEMS Package","text":"","category":"section"},{"location":"#Welcome","page":"Home","title":"Welcome","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The German Epidemic Microsimulation System (GEMS) is a high-performance geo-referential agent-based infectious disease modeling framework developed in Julia. It is a research outcome of the BMBF-funded OptimAgent project. It comes with a full model of the German Population and allows to simulate the spread of infectious diseases and potential countermeasures such as isolation, testing, school- or workplace closure, contact-tracing, and many others. GEMS provides interfaces to load custom populations, adapt infection rules, or change contact patterns. It also comes with comprehensive post-processing and plotting features. All simulated data can be easily exported and used in other applications. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"./assets/landing-page-header.png\" width =\"90%\" />","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation provides a theoretical background to the underlying model, a guide through the most important features and simulation options, a detailed description of all included functionalities, and information about the Julia package itself. Please use the table of content below or the sidebar on the left to navigate through the different sections.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The code is on GitHub.","category":"page"},{"location":"#Background","page":"Home","title":"Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GEMS' core architecture and the integrated intervention modeling framework are discussed in these publications:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ponge, J., Horstkemper, D., Hellingrath, B., Bayer, L., Bock, W. and Karch, A., 2023, December. Evaluating Parallelization Strategies for Large-Scale Individual-based Infectious Disease Simulations. In 2023 Winter Simulation Conference (WSC) (pp. 1088-1099). IEEE. https://doi.org/10.1109/WSC60868.2023.10407633","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ponge, J., Suer, J., Hellingrath, B. and Karch, A., 2024, December. A Standardized Framework for Modeling Non-Pharmaceutical Interventions in Individual-Based Infectious Disease Simulations. In 2024 Winter Simulation Conference (WSC) (pp. 1106-1117). IEEE. https://doi.org/10.1109/WSC63780.2024.10838778","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GEMS requires Julia v1.11.3+.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You will need roughly 1GB of system memory for every million agents.","category":"page"},{"location":"#Quick-Installation","page":"Home","title":"Quick Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To import the GEMS package to your Julia environment, run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url = \"https://github.com/IMMIDD/GEMS\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Run a test simulation like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GEMS\nsim = Simulation()\nrun!(sim)\nrd = ResultData(sim)\ngemsplot(rd)","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Some GEMS features require additional software\nGEMS allows to generate PDF-reports of simulation experiments. These features require Pandoc and MiKTeX (or any other distribution containing xelatex) to be installed on your machine. If you're happy using GEMS without its PDF-reporting features, installing the Julia package is all you need and you can skip this part!","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you need support with the installation, have a look at this more detailed installation guide.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All files that belong to the GEMS are available under GPL-3.0 license.","category":"page"},{"location":"tut_pops/#tut_pops","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"","category":"section"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"If you spawn the default scenario like sim = Simulation(), GEMS will generate a non-representative population with 100,000 individuals households of average size 3, schools/school classes of average size 100 and workplaces/offices of average size 5. The age distribution and household compositions is similar to the German population (not accurate, not representative).","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"Beyond that, GEMS has a variety of options to load or generate custom population models.","category":"page"},{"location":"tut_pops/#Using-Parameters","page":"5 - Creating Populations","title":"Using Parameters","text":"","category":"section"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"You can change the default parameters mentioned above like this:","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"using GEMS\nsim = Simulation(pop_size = 50_000, avg_school_size = 20)","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"Available parameter options are: pop_size, avg_household_size, avg_office_size, and avg_school_size.","category":"page"},{"location":"tut_pops/#Using-Dataframes","page":"5 - Creating Populations","title":"Using Dataframes","text":"","category":"section"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"You can generate a custom population from a dataframe. This dataframe needs to have one row per individual and the columns must be named identical to the fields of the Individual struct. Every individual needs at least an id, an age and a sex. Therefore, these are the minimal requirements for column in your dataframe. The example below generates a synthetic population of 100,000 individuals with random ages from 1 to 100 and two indiviuals per household. This is achieved via the household column as two individuals with the same value will be placed in the same households. The example assigns each value from 1 to 50_000 to two of the individuals.","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"using GEMS, DataFrames\npop_df = DataFrame(\n    id = collect(1:100_000),\n    age = rand(1:100, 100_000),\n    sex = rand(1:2, 100_000),\n    household = append!(collect(1:50_000), collect(1:50_000))\n)\nmy_pop = Population(pop_df)\nsim = Simulation(population = my_pop)","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"If you want to check whether the generation worked and actually only generated two-person households, you can use the Plots.jl package to generate a simple histogram of the household sizes. The . following the size function indicates that this function is applied to all elements in a vector separately; in the example to all households of the simulation.","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"using Plots\nhh_sizes = size.(households(sim))\nhistogram(hh_sizes, xlims = (0, 10))","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"Plot","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_pops_households.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"We don't need to run this simulation as there is no setting except households. Therefore we won't see many infections.","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"info: Where's the list of columns I can create?\nPut a ? into the Julia REPL and call help?> Individual to get an overview of fields that are stored for each individual or look up the Individuals section of the API documentation.","category":"page"},{"location":"tut_pops/#Using-Inbuilt-Models","page":"5 - Creating Populations","title":"Using Inbuilt Models","text":"","category":"section"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"GEMS comes with inbuilt population models for each of the German states as well as a full model of Germany (attention: very large; requires 100+GB of system memory to run). You can load such a model via the state code (e.g. MV for the state of Mecklenburg-Vorpommern) like this:","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"using GEMS\nsim = Simulation(population = \"MV\")","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"Loading a new population model for the first time will spark a download of the file. The inbuilt models are geo-referencal, therefore they can be visualized using the gemsmap() function (e.g., to take a look at the population density):","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"gemsmap(sim, type = :PopDensityMap, clims = (0, 100))","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"Plot","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_pops_popdensity.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"Geo-referential models are fundamentally the same as all other models but have the AGS-field (german community identification number) set for geo-referenced settings. Additionally, they can have a lat/lon value pair stored, which allows to track infection locations. Putting this data into a model manually requires the use of a settings-file (see section below).","category":"page"},{"location":"tut_pops/#Using-Population-Files","page":"5 - Creating Populations","title":"Using Population Files","text":"","category":"section"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"Both, CSV- and JLD2-files can be used to load population models from the harddrive. This way, you can load populations that originate from other projects or tools (like R).","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"CSV-files must adhere to the same data structure as in the \"Using Dataframes\" section. They are basically just an export of the generated dataframe. Here's an exmaple file:","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"id,age,sex,household\n1,12,0,1\n2,75,1,1\n3,35,1,2\n4,63,0,2\n5,32,1,2","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"The JLD2-variant needs to store a dictionary with one key called data that contains a dataframe such as presented above in the \"Using Dataframes\" section.","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"To load such a file, simply pass the filepath as the population argument to the Simulation() function:","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"sim = Simulation(population = \"path/to/my/population_file.csv\")","category":"page"},{"location":"tut_pops/#Using-Settings-Files","page":"5 - Creating Populations","title":"Using Settings-Files","text":"","category":"section"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"All of the above examples that create populations manually, rely on input data that link individuals to a specific setting (e.g., putting an individual into a particular Office). However, GEMS also provides the option to consider hierarchical setting structures (e.g., multiple Offices forming a Department) to not only allow within-setting contacts but also between-setting contacts of a confined pool of subsettings. A so-called \"settings-file\" can be passed to superimpose a hierarchical setting structure:","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"sim = Simulation(population = \"path/to/my/population.jld2\", settingsfile = \"path/to/my/settings.jld2\")","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"Please be aware, that a settings-file usually belongs to a specific population-file as the setting-IDs require an exact matching. Look up the settings-file section of the API documentation to learn about the internal structure of settings-files.","category":"page"},{"location":"tut_pops/#Adjusting-Populations","page":"5 - Creating Populations","title":"Adjusting Populations","text":"","category":"section"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"In some cases, you might want to manually adjust populations after they have been loaded (e.g., to manually set a certain vaccination status for each individual). This can be done using the each!(...) function that applies a given function on each individual in a provided Population. Here's an example where we decide whether an individual has been vaccinated once with increasing probability, depending on their age. We exclude everybody below the age of 18. The sample_vacc! function that we define does just that for an individual. We then call each! to apply this function to all individuals in the population. After that, we build up a dataframe with ages and numbers of vaccinations for all individuals, group them by age, and visualize the fraction of vaccinated individuals per by age.","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"using GEMS, Plots, DataFrames\nsim = Simulation()\npop = population(sim)\n\n# function to adjust individual\nfunction sample_vaccs!(i)\n    if age(i) >= 18 && rand(1:100) < age(i)\n        i.number_of_vaccinations = 1\n    end\nend\n\n# apply function to each individual\neach!(sample_vaccs!, pop)\n\n# plot to verify that everything worked\ninds = individuals(pop)\ndf = DataFrame(age = age.(inds), vaccinations = number_of_vaccinations.(inds))\ndf_grouped = groupby(df, :age)\ndf_combined = combine(df_grouped, :vaccinations => (v -> sum(v) / length(v)) => :vacc_fraction)\nplot(df_combined.age, df_combined.vacc_fraction)","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"Plot","category":"page"},{"location":"tut_pops/","page":"5 - Creating Populations","title":"5 - Creating Populations","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_pops_adjusting.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"api_resultdata/#Result-data","page":"Result Data","title":"Result data","text":"","category":"section"},{"location":"api_resultdata/#Overview-Structs","page":"Result Data","title":"Overview Structs","text":"","category":"section"},{"location":"api_resultdata/","page":"Result Data","title":"Result Data","text":"Pages   = [\"api_resultdata.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_resultdata/#Overview-Functions","page":"Result Data","title":"Overview Functions","text":"","category":"section"},{"location":"api_resultdata/","page":"Result Data","title":"Result Data","text":"Pages   = [\"api_resultdata.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_resultdata/#ResultData","page":"Result Data","title":"ResultData","text":"","category":"section"},{"location":"api_resultdata/#Constructors","page":"Result Data","title":"Constructors","text":"","category":"section"},{"location":"api_resultdata/#GEMS.ResultData-Tuple{Simulation}","page":"Result Data","title":"GEMS.ResultData","text":"ResultData(sim::Simulation; style::String = \"\")\n\nCreate a ResultData object using a Simulation and the name of a ResultDataStyle, that describes the level of detail  for the fields to be calculated. This constructor instantiates a default PostProcessor for  the passed simulation object. If you want to manually configure the PostProcessor, you need to instantiate it first and pass the PostProcessor to the ResultData constructor instead. Post Processing requires a simulation to be done.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.ResultData-Tuple{PostProcessor}","page":"Result Data","title":"GEMS.ResultData","text":"ResultData(postProcessor::PostProcessor; style::String=\"\")\n\nCreate a ResultData object using a PostProcessor and a key, that describes the level of detail  for the fields to be calculated. Post Processing requires a simulation to be done.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.ResultData-Tuple{Vector{PostProcessor}}","page":"Result Data","title":"GEMS.ResultData","text":"ResultData(postProcessors::Vector{PostProcessor}; style::String=\"\", print_infos::Bool = false)\n\nCreate a vector ResultData objects using a vector of associated PostProcessor objects and a key, that describes the level of detail  for the fields to be calculated. Post Processing requires a simulation to be done. It supresses the usual info outputs that are being made during the ResultData generation. If you want to enable them, pass print_infos = true.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.ResultData-Tuple{Vector{Simulation}}","page":"Result Data","title":"GEMS.ResultData","text":"ResultData(sim::Vector{Simulation}; style::String = \"\", print_infos::Bool = false)\n\nCreate a vector ResultData objects using a vector of Simulation objects and the name of a ResultDataStyle, that describes the level of detail  for the fields to be calculated. If you want to manually configure the PostProcessor, you need to instantiate it first and pass the PostProcessor to the ResultData constructor instead. Post Processing requires a simulation to be done. It supresses the usual info outputs that are being made during the ResultData generation. If you want to enable them, pass print_infos = true.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.ResultData-Tuple{Batch}","page":"Result Data","title":"GEMS.ResultData","text":"ResultData(batch::Batch; style::String = \"\", print_infos::Bool = false)\n\nCreate a vector ResultData objects using a Batch object and the name of a ResultDataStyle, that describes the level of detail  for the fields to be calculated. If you want to manually configure the PostProcessors, you need to instantiate them first and pass the PostProcessors to the ResultData constructor instead. Post Processing requires a simulation to be done. It supresses the usual info outputs that are being made during the ResultData generation. If you want to enable them, pass print_infos = true.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#Functions","page":"Result Data","title":"Functions","text":"","category":"section"},{"location":"api_resultdata/#GEMS.aggregated_compartment_periods","page":"Result Data","title":"GEMS.aggregated_compartment_periods","text":"aggregated_compartment_periods(rd::ResultData)\n\nReturns the DataFrame with disease state durations (normalized). Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"function"},{"location":"api_resultdata/#GEMS.allempty","page":"Result Data","title":"GEMS.allempty","text":"allempty(f::Function, rds::Vector{ResultData})\n\nReturns true if the provided function returns an empty dictionary for all ResultData objects in the provided vector.\n\n\n\n\n\n","category":"function"},{"location":"api_resultdata/#GEMS.attack_rate-Tuple{ResultData}","page":"Result Data","title":"GEMS.attack_rate","text":"attack_rate(rd::ResultData)\n\nReturns the simulation's attack rate. It's total infections divided by population size. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.compartment_fill-Tuple{ResultData}","page":"Result Data","title":"GEMS.compartment_fill","text":"compartment_fill(rd::ResultData)\n\nReturns the compartment_fill infections over time. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.compartment_periods-Tuple{ResultData}","page":"Result Data","title":"GEMS.compartment_periods","text":"compartment_periods(rd::ResultData)\n\nReturns the DataFrame with duration of exposed and infectious states for all infections. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.config_file-Tuple{ResultData}","page":"Result Data","title":"GEMS.config_file","text":"config_file(rd::ResultData)\n\nReturns the path to the config file\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.config_file_val","page":"Result Data","title":"GEMS.config_file_val","text":"config_file_val(rd::ResultData)\n\nReturns the parsed config file. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"function"},{"location":"api_resultdata/#GEMS.cpu_data-Tuple{ResultData}","page":"Result Data","title":"GEMS.cpu_data","text":"cpu_data(rd::ResultData)\n\nReturns the processor information (not available for ARM Macs)\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.cumulative_cases-Tuple{ResultData}","page":"Result Data","title":"GEMS.cumulative_cases","text":"cumulative_cases(rd::ResultData)\n\nReturns the cumulative infections over time. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.cumulative_deaths-Tuple{ResultData}","page":"Result Data","title":"GEMS.cumulative_deaths","text":"cumulative_deaths(rd::ResultData)\n\nReturns the cumulative deaths over time. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.cumulative_disease_progressions-Tuple{ResultData}","page":"Result Data","title":"GEMS.cumulative_disease_progressions","text":"cumulative_disease_progressions(rd::ResultData)\n\nReturns the DataFrame with cumultive number of individuals in certain disease states per tick. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.cumulative_quarantines-Tuple{ResultData}","page":"Result Data","title":"GEMS.cumulative_quarantines","text":"cumulative_quarantines(rd::ResultData)\n\nReturns the DataFrame with number of isolated individuals per tick Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.cumulative_vaccinations-Tuple{ResultData}","page":"Result Data","title":"GEMS.cumulative_vaccinations","text":"cumulative_vaccinations(rd::ResultData)\n\nReturns the cumulative vaccinations over time. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.customlogger-Tuple{ResultData}","page":"Result Data","title":"GEMS.customlogger","text":"customlogger(rd::ResultData)\n\nReturns the DataFrame of the Simulation object's internal custom logger. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.data_hash-Tuple{ResultData}","page":"Result Data","title":"GEMS.data_hash","text":"data_hash(rd::ResultData)\n\nReturns a SHA1 hash value for the ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.dataframes-Tuple{ResultData}","page":"Result Data","title":"GEMS.dataframes","text":"dataframes(rd::ResultData)\n\nReturns the dataframes of result data. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.deaths-Tuple{ResultData}","page":"Result Data","title":"GEMS.deaths","text":"deaths(rd::ResultData)\n\nReturns the deaths DataFrame joined with individuals' attributes. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.detected_tick_cases-Tuple{ResultData}","page":"Result Data","title":"GEMS.detected_tick_cases","text":"detected_tick_cases(rd::ResultData)\n\nReturns the detected cases per tick DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.detection_rate-Tuple{ResultData}","page":"Result Data","title":"GEMS.detection_rate","text":"detection_rate(rd::ResultData)\n\nReturns the fraction of detected infections. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.effectiveR-Tuple{ResultData}","page":"Result Data","title":"GEMS.effectiveR","text":"effectiveR(rd::ResultData)\n\nReturns the Effective R value over time DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.execution_date-Tuple{ResultData}","page":"Result Data","title":"GEMS.execution_date","text":"execution_date(rd::ResultData)\n\nReturns the timestamp of result data generation. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.execution_date_formatted","page":"Result Data","title":"GEMS.execution_date_formatted","text":"execution_date_formatted(rd::ResultData)\n\nReturns the (formatted for report) timestamp of result data generation. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"function"},{"location":"api_resultdata/#GEMS.exportJLD-Tuple{ResultData, AbstractString}","page":"Result Data","title":"GEMS.exportJLD","text":"exportJLD(rd::ResultData, directory::AbstractString)\n\nExports the ResultData object as a JLD2 file, storing it in the specified directory.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.final_tick-Tuple{ResultData}","page":"Result Data","title":"GEMS.final_tick","text":"final_tick(rd::ResultData)\n\nReturns the tick counter at the end of the simulation run. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.free_mem_size-Tuple{ResultData}","page":"Result Data","title":"GEMS.free_mem_size","text":"free_mem_size(rd::ResultData)\n\nReturns the available system memory\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.GEMS_version-Tuple{ResultData}","page":"Result Data","title":"GEMS.GEMS_version","text":"GEMS_version(rd::ResultData)\n\nReturns the GEMS version this ResultData object was generated with. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.git_branch-Tuple{ResultData}","page":"Result Data","title":"GEMS.git_branch","text":"git_branch(rd::ResultData)\n\nReturns the current git branch.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.git_commit-Tuple{ResultData}","page":"Result Data","title":"GEMS.git_commit","text":"git_commit(rd::ResultData)\n\nReturns the current git commit.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.git_repo-Tuple{ResultData}","page":"Result Data","title":"GEMS.git_repo","text":"git_repo(rd::ResultData)\n\nReturns the current git repository.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.hashes-Tuple{ResultData}","page":"Result Data","title":"GEMS.hashes","text":"hashes(rd::ResultData)\n\nReturns the dataframes of result data. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.tick_hosptitalizations-Tuple{ResultData}","page":"Result Data","title":"GEMS.tick_hosptitalizations","text":"tick_hosptitalizations(rd::ResultData)\n\nReturns the tests per tick DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.household_attack_rates-Tuple{ResultData}","page":"Result Data","title":"GEMS.household_attack_rates","text":"household_attack_rates(rd::ResultData)\n\nReturns householdattackrates DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.id-Tuple{ResultData}","page":"Result Data","title":"GEMS.id","text":"id(rd::ResultData)\n\nReturns the unique identifer of the ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.import_resultdata","page":"Result Data","title":"GEMS.import_resultdata","text":"import_resultdata(filepath::String)\n\nImport the ResultData object from a jld2 file. Returns the ResultData object.\n\n\n\n\n\nimport_resultdata(filepath::String, config::Dict=Dict())\n\nImport the ResultData object from a jld2 file. Also accepts a config dictionary that includes the fields that should be obtained from the file. If there are fields in the config file that are not yet present in the ResultData object the creation of these fields is being attempted. If there are fields present in the ResultData object that are not in the config file, these fields are ommited. Providing an empty config dictionary will lead to the generation of all fields. \n\n\n\n\n\n","category":"function"},{"location":"api_resultdata/#GEMS.infections-Tuple{ResultData}","page":"Result Data","title":"GEMS.infections","text":"infections(rd::ResultData)\n\nReturns the infection DataFrame joined with individuals' attributes. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.infections_hash-Tuple{ResultData}","page":"Result Data","title":"GEMS.infections_hash","text":"infections_hash(rd::ResultData)\n\nReturns a SHA1 hash value for the infections DataFrame based on the tick, id_a, and id_b column. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.info-Tuple{ResultData}","page":"Result Data","title":"GEMS.info","text":"info(rd::ResultData)\n\nPrints info about available fields in the ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.initial_infections-Tuple{ResultData}","page":"Result Data","title":"GEMS.initial_infections","text":"initial_infections(rd::ResultData)\n\nReturns the number of individuals who are marked as infected during initialization. This happens before the actual simulation run. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.julia_version-Tuple{ResultData}","page":"Result Data","title":"GEMS.julia_version","text":"julia_version(rd::ResultData)\n\nReturns the Julia version that was used to generate this result data object. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.kernel-Tuple{ResultData}","page":"Result Data","title":"GEMS.kernel","text":"kernel(rd::ResultData)\n\nReturns the system kernel information Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.label-Tuple{ResultData}","page":"Result Data","title":"GEMS.label","text":"label(rd::ResultData)\n\nReturns the lable of the simulation run. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.meta_data-Tuple{ResultData}","page":"Result Data","title":"GEMS.meta_data","text":"meta_data(rd::ResultData)\n\nReturns the meta_data dictionary of the ResultData. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.model_size-Tuple{ResultData}","page":"Result Data","title":"GEMS.model_size","text":"model_size(rd::ResultData)\n\nReturns the size of the simulation model in memory.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.number_of_individuals-Tuple{ResultData}","page":"Result Data","title":"GEMS.number_of_individuals","text":"number_of_individuals(rd::ResultData)\n\nReturns the total number of individuals in the population model. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.observed_R-Tuple{ResultData}","page":"Result Data","title":"GEMS.observed_R","text":"observed_R(rd::ResultData)\n\nReturns the observed reproduction number estimation DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.pathogens-Tuple{ResultData}","page":"Result Data","title":"GEMS.pathogens","text":"pathogens(rd::ResultData)\n\nReturns an array of pathogen parameters. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.population_file-Tuple{ResultData}","page":"Result Data","title":"GEMS.population_file","text":"population_file(rd::ResultData)\n\nReturns the path to the population file Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.population_params-Tuple{ResultData}","page":"Result Data","title":"GEMS.population_params","text":"population_params(rd::ResultData)\n\nReturns parameters that were used to generate the population. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.population_pyramid-Tuple{ResultData}","page":"Result Data","title":"GEMS.population_pyramid","text":"population_pyramid(rd::ResultData)\n\nReturns the DataFrame required to plot population pyramid (age, sex, count) Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.population_size-Tuple{ResultData}","page":"Result Data","title":"GEMS.population_size","text":"population_size(rd::ResultData)\n\nReturns the size of the population model in memory.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.region_info-Tuple{ResultData}","page":"Result Data","title":"GEMS.region_info","text":"region_info(rd::ResultData)\n\nReturns a Dataframe with population size and area per municiaplity (if model is geolocalized). Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.rolling_observed_SI-Tuple{ResultData}","page":"Result Data","title":"GEMS.rolling_observed_SI","text":"rolling_observed_SI(rd::ResultData)\n\nReturns the rolling observed serial interval DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.setting_data-Tuple{ResultData}","page":"Result Data","title":"GEMS.setting_data","text":"setting_data(rd::ResultData)\n\nReturns a DataFrame containing information on all setting types. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.setting_sizes-Tuple{ResultData}","page":"Result Data","title":"GEMS.setting_sizes","text":"setting_sizes(rd::ResultData)\n\nReturns a Dictionary containing information on all setting sizes. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.sim_data-Tuple{ResultData}","page":"Result Data","title":"GEMS.sim_data","text":"sim_data(rd::ResultData)\n\nReturns the sim_data of result data. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.someempty","page":"Result Data","title":"GEMS.someempty","text":"someempty(f::Function, rds::Vector{ResultData})\n\nReturns true if the provided function returns an empty  dictionary for at least one of the ResultData objects.\n\n\n\n\n\n","category":"function"},{"location":"api_resultdata/#GEMS.start_condition-Tuple{ResultData}","page":"Result Data","title":"GEMS.start_condition","text":"start_condition(rd::ResultData)\n\nReturns the StartCondition object the simulation was initialized with. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.stop_criterion-Tuple{ResultData}","page":"Result Data","title":"GEMS.stop_criterion","text":"stop_criterion(rd::ResultData)\n\nReturns the StopCriterion object of the simulation. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.strategies-Tuple{ResultData}","page":"Result Data","title":"GEMS.strategies","text":"strategies(rd::ResultData)\n\nReturns the strategies included in the simulation. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.symptom_triggers-Tuple{ResultData}","page":"Result Data","title":"GEMS.symptom_triggers","text":"symptom_triggers(rd::ResultData)\n\nReturns the symptom triggers included in the simulation. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.system_data-Tuple{ResultData}","page":"Result Data","title":"GEMS.system_data","text":"system_data(rd::ResultData)\n\nReturns the system_data of result data. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.tests-Tuple{ResultData}","page":"Result Data","title":"GEMS.tests","text":"tests(rd::ResultData)\n\nReturns the tests DataFrame . Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.testtypes-Tuple{ResultData}","page":"Result Data","title":"GEMS.testtypes","text":"testtypes(rd::ResultData)\n\nReturns the test types included in the simulation. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.threads-Tuple{ResultData}","page":"Result Data","title":"GEMS.threads","text":"threads(rd::ResultData)\n\nReturns the number of threads this Julia instance was started with.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.tick_cases-Tuple{ResultData}","page":"Result Data","title":"GEMS.tick_cases","text":"tick_cases(rd::ResultData)\n\nReturns the infections per tick DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.tick_cases_per_setting-Tuple{ResultData}","page":"Result Data","title":"GEMS.tick_cases_per_setting","text":"tick_cases_per_setting(rd::ResultData)\n\nReturns the tests per tick DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.tick_deaths-Tuple{ResultData}","page":"Result Data","title":"GEMS.tick_deaths","text":"tick_deaths(rd::ResultData)\n\nReturns the deaths per tick DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.tick_generation_times-Tuple{ResultData}","page":"Result Data","title":"GEMS.tick_generation_times","text":"tick_generation_times(rd::ResultData)\n\nReturns the generation times per tick DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.tick_pooltests-Tuple{ResultData}","page":"Result Data","title":"GEMS.tick_pooltests","text":"tick_pooltests(rd::ResultData)\n\nReturns the pool tests per tick DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.tick_serial_intervals-Tuple{ResultData}","page":"Result Data","title":"GEMS.tick_serial_intervals","text":"tick_serial_intervals(rd::ResultData)\n\nReturns the serial intervals per tick DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.tick_tests-Tuple{ResultData}","page":"Result Data","title":"GEMS.tick_tests","text":"tick_tests(rd::ResultData)\n\nReturns the tests per tick DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.tick_unit-Tuple{ResultData}","page":"Result Data","title":"GEMS.tick_unit","text":"tick_unit(rd::ResultData)\n\nReturns the unit of time that one tick corresponds to. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.tick_vaccinations-Tuple{ResultData}","page":"Result Data","title":"GEMS.tick_vaccinations","text":"tick_vaccinations(rd::ResultData)\n\nReturns the vaccinations per tick DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.time_to_detection-Tuple{ResultData}","page":"Result Data","title":"GEMS.time_to_detection","text":"time_to_detection(rd::ResultData)\n\nReturns time to detection DataFrame. Look up the PostProcessor docs to find the column definitions. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.timer_output!-Tuple{ResultData, TimerOutput}","page":"Result Data","title":"GEMS.timer_output!","text":"timer_output!(rd::ResultData, timer_output::TimerOutput)\n\nSets the TimerOutput object for a ResultData object\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.timer_output-Tuple{ResultData}","page":"Result Data","title":"GEMS.timer_output","text":"timer_output(rd::ResultData)\n\nReturns the TimerOutput object used to supply debug report with execution time information Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.total_infections-Tuple{ResultData}","page":"Result Data","title":"GEMS.total_infections","text":"total_infections(rd::ResultData)\n\nReturns the row count of the PostProcessors' infections-DataFrame. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.total_mem_size-Tuple{ResultData}","page":"Result Data","title":"GEMS.total_mem_size","text":"total_mem_size(rd::ResultData)\n\nReturns the total system memory\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.total_quarantines-Tuple{ResultData}","page":"Result Data","title":"GEMS.total_quarantines","text":"total_quarantines(rd::ResultData)\n\nReturns the total quarantined agent over the course of the simulation. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.total_tests-Tuple{ResultData}","page":"Result Data","title":"GEMS.total_tests","text":"total_tests(rd::ResultData)\n\nReturns a dictionary with the the total number of tests per TestType. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#GEMS.word_size-Tuple{ResultData}","page":"Result Data","title":"GEMS.word_size","text":"word_size(rd::ResultData)\n\nReturns the system word size.\n\n\n\n\n\n","category":"method"},{"location":"api_resultdata/#ResultDataStyle","page":"Result Data","title":"ResultDataStyle","text":"","category":"section"},{"location":"api_resultdata/#Constructors-2","page":"Result Data","title":"Constructors","text":"","category":"section"},{"location":"api_resultdata/#GEMS.ResultDataStyle","page":"Result Data","title":"GEMS.ResultDataStyle","text":"ResultDataStyle\n\nAbstract type, whose implementations define the structure of a ResutltData object.\n\n\n\n\n\n","category":"type"},{"location":"api_resultdata/#GEMS.DefaultResultData","page":"Result Data","title":"GEMS.DefaultResultData","text":"DefaultResultData <: ResultDataStyle\n\nThe default style for ResultData objects. It contains all that can currently be calculated in the PostProcessor. Therefore, it is both, the most comprehensive and computationally intensive (memory & runtime) option.\n\nFields\n\ndata::Dict{String, Any}:\nmeta_data::Dict{String, Any}\ntimer_output::TimerOutput: TimerOutput object    \nexecution_date::String: Time this ResultData object was generated\nGEMS_version::VersionNumber: GEMS version this ResultData object was generated with \nconfig_file::String: Path to the config file\nconfig_file_val::Dict{String, Any}: Deep copy of the supplied TOML config file\npopulation_file::String: Path to the population file\npopulation_params::Dict{String, Any}: Parameters used to generate population\nsim_data::Dict{String, Any}\nlabel::String: Label of this simulation run (needed for plotting)\nfinal_tick::Int16: Tick counter at the end of the simulation run\nnumber_of_individuals::Int64: Total number of individuals in the population model\ninitial_infections::Int64: Number of initial infected individuals\ntotal_infections::Int64: Row count of the PostProcessor's infections DataFrame\nattack_rate::Float64: Fraction of overall infected individuals\nsetting_data::DataFrame: DataFrame containing information on all setting types\nsetting_sizes::Dict{Any, Any}: Dictionary containing the setting sizes distributions for all included settingtypes\nregion_info::Dataframe: Municipality population size and area (if geolocalized model is used)\npathogens::Vector{Pathogen}: Array of pathogen parameters\nvaccine::Vaccine: Vaccine parameter [CURRENTLY DEACTIVATED]\nvaccination_strategy::VaccineScheduler: Vaccination strategy used in this model [CURRENTLY DEACTIVATED]\ntick_unit::String: Unit of time that one tick corresponds to\nstart_condition::StartCondition: Initial setup of the simulation\nstop_criterion::StopCriterion: Termination conditions\nstrategies::Vector{Strategy}: Intervention strategies\nsymptom_triggers::Vector{ITrigger}: Strategies that are triggered upon experiencing symptoms\ntesttypes::Vector{AbstractTestType}: Test types used in the model (e.g. Antigen Tests)\ntotal_quarantines::Int64: Total person-ticks (e.g. days) spent in isolation\ntotal_tests::Dict{Any, Any}: Total number of performed tests per TestType\ndetection_rate::Float64: Fraction of detected infections (by testing)\nsystem_data::Dict{String, Any}\nkernel::String: System kernel\njulia_version::String: Julia version that was used to generate this data object\nword_size::Int64: System word size\nthreads::Int64: Number of threads this Julia instance was started with\ncpu_data::Markdown.MD: Information on the processor (not available for ARM Macs)\ntotal_mem_size::Float64: Total system memory\nfree_mem_size::Float64: Available system memory\ngit_repo::SubString{String}: Current Git repository\ngit_branch::SubString{String}: Current Git branch\ngit_commit::SubString{String}: Current Git commit ID\nmodel_size::Int64: Size of the simulation model in memory [CURRENTLY DACTIVATED]\npopulation_size::Int64: Size of the population model in memory [CURRENTLY DACTIVATED]\nsetting_age_contacts::Dict{String, Any}\nHousehold: age X age contact matrix for Households based on sampled data [CURRENTLY DACTIVATED]\nGlobalSetting: age X age contact matrix for GlobalSettings based on sampled data [CURRENTLY DACTIVATED]\naggregated_setting_age_contacts::Dict{String, Any}\nHousehold::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for Households based on sampled data\nSchoolClass::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for SchoolClass based on sampled data\nSchool::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for School based on sampled data\nSchoolComplex::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for SchoolComplex based on sampled data\nOffice::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for Office based on sampled data\nDepartment::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for Department based on sampled data\nWorkplace::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for Workplace based on sampled data\nWorkplaceSite::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for WorkplaceSite based on sampled data\nMunicipality::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for Municipality based on sampled data\nGlobalSetting::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for GlobalSetting based on sampled data\ndataframes::Dict{String, Any}\ninfections::DataFrame: Infection data joined with individuals' attributes\nvaccinations::DataFrame: Vaccination data joined with individuals' attributes\ndeaths::DataFrame: Death data joined with individuals' attributes\ntests::DataFrame: Test data joined with individuals' attributes\neffectiveR::DataFrame: Effective R value over time\ncompartment_periods::DataFrame: Duration of exposed and infectious states for all infections\naggregated_compartment_periods::DataFrame: Statistics on time individuals spend in each disease compartment\ntick_cases::DataFrame: Infections per tick\ntick_deaths::DataFrame: Deaths per tick\ntick_vaccinations::DataFrame: Vaccinations per tick\ntick_serial_intervals::DataFrame: Aggregated data on serial intervals per tick\ntick_generation_times::DataFrame: Aggregated data on generation timess per tick        \ntick_tests::DataFrame: Number of tests performed per tick\ntick_pooltests::DataFrame: Number of (pooled) tests per tick\ntick_cases_per_setting::DataFrame: Tick cases aggregated by settingtype,\ndetected_tick_cases::DataFrame: Number of detected infections per tick\ncompartment_fill::DataFrame: Number of individuals currently in any of the disease compartments\ncumulative_cases::DataFrame: Cumulative infections over time\ncumulative_deaths::DataFrame: Cumulative deaths over time\ncumulative_vaccinations::DataFrame: Cumulative vaccinations over time\ncumulative_disease_progressions::DataFrame: Cumulative information on disease states N ticks after exposure\ncumulative_quarantines::DataFrame: Number of quarantined individuals per tick\nage_incidence::DataFrame: Incidence over time stratified by age groups\npopulation_pyramid::DataFrame: Data required to plot population pyramid (age, sex, count)\nrolling_observed_SI::DataFrame: Serial interval estimation based on the last 14 days of detected cases\nobserved_R::DataFrame: Reproduction number estimation based on detected cases and the SI estimation\ntick_hosptitalizations::DataFrame: DataFrame containing the daily hospitalizations etc.\ntime_to_detection::DataFrame: Statistics on the time between exposure and first detection of an infection through a test\nhousehold_attack_rates::DataFrame: Statistics on the seconary infections in households\ncustomlogger::DataFrame: Dataframe obtained from any custom logger that might have been set\n\n\n\n\n\n","category":"type"},{"location":"api_resultdata/#GEMS.LightRD","page":"Result Data","title":"GEMS.LightRD","text":"LightRD <: ResultDataStyle\n\nSimilar to the default style for ResultData objects but without any raw data (e.g. the ìnfections-, deaths- or tests- dataframes) as the  raw data makes around 80% of the DefaultResultData style memory footprint. It contains everything that can currently be calculated in the PostProcessor.\n\nThis RD-style cannot be used to generate geographical maps or infection videos.\n\nFields\n\ndata::Dict{String, Any}: Dictionary holding the following sub-dictionaries \nmeta_data::Dict{String, Any}\ntimer_output::TimerOutput: TimerOutput object    \n(Note: This data is only available if the simulation runs were done via the main() function)\nexecution_date::String: Time this ResultData object was generated\nGEMS_version::VersionNumber: GEMS version this ResultData object was generated with \nconfig_file::String: Path to the config file\nconfig_file_val::Dict{String, Any}: Deep copy of the supplied TOML config file\npopulation_file::String: Path to the population file\npopulation_params::Dict{String, Any}: Parameters used to generate population\nsim_data::Dict{String, Any}\nlabel::String: Label of this simulation run (needed for plotting)\nfinal_tick::Int16: Tick counter at the end of the simulation run\nnumber_of_individuals::Int64: Total number of individuals in the population model\ninitial_infections::Int64: Number of initial infected individuals\ntotal_infections::Int64: Row count of the PostProcessor's infections DataFrame\nattack_rate::Float64: Fraction of overall infected individuals\nsetting_data::DataFrame: DataFrame containing information on all setting types\nsetting_sizes::Dict{Any, Any}: Dictionary containing the setting sizes distributions for all included settingtypes\nregion_info::Dataframe: Municipality population size and area (if geolocalized model is used)\npathogens::Vector{Pathogen}: Array of pathogen parameters\ntick_unit::String: Unit of time that one tick corresponds to\nstart_condition::StartCondition: Initial setup of the simulation\nstop_criterion::StopCriterion: Termination conditions\nstrategies::Vector{Strategy}: Intervention strategies\nsymptom_triggers::Vector{ITrigger}: Strategies that are triggered upon experiencing symptoms\ntesttypes::Vector{AbstractTestType}: Test types used in the model (e.g. Antigen Tests)\ntotal_quarantines::Int64: Total person-ticks (e.g. days) spent in isolation\ntotal_tests::Dict{Any, Any}: Total number of performed tests per TestType\ndetection_rate::Float64: Fraction of detected infections (by testing)\nsystem_data::Dict{String, Any}\nkernel::String: System kernel\njulia_version::String: Julia version that was used to generate this data object\nword_size::Int64: System word size\nthreads::Int64: Number of threads this Julia instance was started with\ncpu_data::Markdown.MD: Information on the processor (not available for ARM Macs)\ntotal_mem_size::Float64: Total system memory\nfree_mem_size::Float64: Available system memory\ngit_repo::SubString{String}: Current Git repository\ngit_branch::SubString{String}: Current Git branch\ngit_commit::SubString{String}: Current Git commit ID\nmodel_size::Int64: Size of the simulation model in memory [CURRENTLY DACTIVATED]\npopulation_size::Int64: Size of the population model in memory [CURRENTLY DACTIVATED]\naggregated_setting_age_contacts::Dict{String, Any}\nHousehold::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for Households based on sampled data\nSchoolClass::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for SchoolClass based on sampled data\nSchool::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for School based on sampled data\nSchoolComplex::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for SchoolComplex based on sampled data\nOffice::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for Office based on sampled data\nDepartment::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for Department based on sampled data\nWorkplace::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for Workplace based on sampled data\nWorkplaceSite::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for WorkplaceSite based on sampled data\nMunicipality::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for Municipality based on sampled data\nGlobalSetting::ContactMatrix{Float64}: age group x age group \"ContactMatrix\" object for GlobalSetting based on sampled data\ndataframes::Dict{String, Any}\neffectiveR::DataFrame: Effective R value over time\ntick_cases::DataFrame: Infections per tick\ntick_deaths::DataFrame: Deaths per tick\ntick_serial_intervals::DataFrame: Aggregated data on serial intervals per tick\ntick_generation_times::DataFrame: Aggregated data on generation timess per tick        \ntick_tests::DataFrame: Number of tests performed per tick\ntick_pooltests::DataFrame: Number of (pooled) tests per tick\ntick_cases_per_setting::DataFrame: Tick cases aggregated by settingtype,\ndetected_tick_cases::DataFrame: Number of detected infections per tick\ncompartment_fill::DataFrame: Number of individuals currently in any of the disease compartments\naggregated_compartment_periods::DataFrame: Statistics on time individuals spend in each disease compartment\ncumulative_cases::DataFrame: Cumulative infections over time\ncumulative_deaths::DataFrame: Cumulative deaths over time\ncumulative_disease_progressions::DataFrame: Cumulative information on disease states N ticks after exposure\ncumulative_quarantines::DataFrame: Number of quarantined individuals per tick\nage_incidence::DataFrame: Incidence over time stratified by age groups\npopulation_pyramid::DataFrame: Data required to plot population pyramid (age, sex, count)\nrolling_observed_SI::DataFrame: Serial interval estimation based on the last 14 days of detected cases\nobserved_R::DataFrame: Reproduction number estimation based on detected cases and the SI estimation\ntick_hosptitalizations::DataFrame: DataFrame containing the daily hospitalizations etc.\ntime_to_detection::DataFrame: Statistics on the time between exposure and first detection of an infection through a test\nhousehold_attack_rates::DataFrame: Statistics on the seconary infections in households\ncustomlogger::DataFrame: Dataframe obtained from any custom logger that might have been set\n\n\n\n\n\n","category":"type"},{"location":"api_mapping/#Mapping","page":"Mapping","title":"Mapping","text":"","category":"section"},{"location":"api_mapping/#Overview-Structs","page":"Mapping","title":"Overview Structs","text":"","category":"section"},{"location":"api_mapping/","page":"Mapping","title":"Mapping","text":"Pages   = [\"api_mapping.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_mapping/#Overview-Functions","page":"Mapping","title":"Overview Functions","text":"","category":"section"},{"location":"api_mapping/","page":"Mapping","title":"Mapping","text":"Pages   = [\"api_mapping.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_mapping/#Structs","page":"Mapping","title":"Structs","text":"","category":"section"},{"location":"api_mapping/#GEMS.AgeMap","page":"Mapping","title":"GEMS.AgeMap","text":"AgeMap <: MapPlot\n\nA map that shows the average age per region.\n\n\n\n\n\n","category":"type"},{"location":"api_mapping/#GEMS.AttackRateMap","page":"Mapping","title":"GEMS.AttackRateMap","text":"AttackRateMap <: MapPlot\n\nA map that shows the fraction of individuals that got infected at least one time per region. The region code (AGS) is taken from the individuals' household location, not the location of infection.\n\n\n\n\n\n","category":"type"},{"location":"api_mapping/#GEMS.CaseFatalityMap","page":"Mapping","title":"GEMS.CaseFatalityMap","text":"CaseFatailityMap <: MapPlot\n\nA map that shows the fraction of infections that led to death time per region.\n\n\n\n\n\n","category":"type"},{"location":"api_mapping/#GEMS.Geolocated","page":"Mapping","title":"GEMS.Geolocated","text":"Supertype for all simulation settings which directly contain individuals and are geolocated.\n\n\n\n\n\n","category":"type"},{"location":"api_mapping/#GEMS.InfectionMap","page":"Mapping","title":"GEMS.InfectionMap","text":"InfectionMap <: SimulationPlot\n\nA simulation plot type for generating an infection map.\n\n\n\n\n\n","category":"type"},{"location":"api_mapping/#GEMS.HouseholdSizeMap","page":"Mapping","title":"GEMS.HouseholdSizeMap","text":"HouseholdSizeMap <: MapPlot\n\nA map that shows the average household size per region.\n\n\n\n\n\n","category":"type"},{"location":"api_mapping/#GEMS.MapPlot","page":"Mapping","title":"GEMS.MapPlot","text":"Supertype for all maps that go into single-run simulation reports\n\n\n\n\n\n","category":"type"},{"location":"api_mapping/#GEMS.PopDensityMap","page":"Mapping","title":"GEMS.PopDensityMap","text":"PopDensityMap <: MapPlot\n\nA map that shows the population density per region.\n\n\n\n\n\n","category":"type"},{"location":"api_mapping/#GEMS.SinglesMap","page":"Mapping","title":"GEMS.SinglesMap","text":"SinglesMap <: MapPlot\n\nA map that shows the fraction of single-person households per region.\n\n\n\n\n\n","category":"type"},{"location":"api_mapping/#Functions","page":"Mapping","title":"Functions","text":"","category":"section"},{"location":"api_mapping/#GEMS.gemsmap","page":"Mapping","title":"GEMS.gemsmap","text":"gemsmap(data; type = :nothing, level = 3, plotargs...)\n\nGenerates a geographical map of a desired type. Just pass the name of  the map-type as a Symbol (must be exactly the same as the respective  SimulationPlot-struct). The data argument mus be either a Simulation object (used to map model-related features such as average household sizes per region) or a ResultData object (used to map simulation-result-related features such as the attack rate per region). Most of the maps that can be generated also take the level argument that converts the AGSs to the desired geographical resolution: states (level = 1), counties (level = 2) or municipalities (level = 3).\n\nParameters\n\ndata: Simulation or ResultData object.\ntype = :nothing (optional): Map type (instantiates a map with the exact same struct name).\nlevel = 3 (optional): Desired geographical resolution: states (level = 1), counties (level = 2)   or municipalities (level = 3)\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Map using the Plots.jl package's struct.\n\nExamples\n\nGiven that you have a simulation with geolocalized settings (available in the predefined models accessible via the German state codes. e.g., \"SH\" for the  northern-most state of \"Schleswig-Holstein\"), you can plot the average age per region on a map like this:\n\nsim = Simulation(population = \"SH\")\ngemsplot(sim, type = :AgeMap)\n\nIf you want to change the resolution to counties, try:\n\nsim = Simulation(population = \"SH\")\ngemsplot(sim, type = :AgeMap, level = 2)\n\nAll gemsmaps can be nested and combined with any plot of the Plots.jl package or gemsplots:\n\nusing Plots\nplot(\n    gemsmap(sim, type = :AgeMap),\n    gemsplot(rd, type = :TickCases)\n)\n\nMap Types\n\nType Input Object Description Plot-Specific Parameters\n:AgeMap Simulation Average age per region. \n:AttackRate ResultData Fraction of people who got infected per region. \n:CaseFatalityMap ResultData Fraction of infections that led to death per region. \n:HouseholdSizeMap Simulation Average household size per region. \n:PopDensityMap Simulation Population density per region. \n:SinglesMap Simulation Fraction of single-person households per region. \n\nNote: Maps that use infection data (e.g., the AttackRate) use the individuals' household location to map the data, not the loction of infection.\n\nSome Useful Keyword Arguments\n\nHere are some examples of the Plots.jl package's keyword arguments that you can also pass to the gemsmap() function and might find helpful:\n\nclims = (0, 1): Setting the color bar range between 0 and 1\ncolorbar = false: Disabling the colorbar\nsize = (300, 400): Resizing the map plot\ntitle = \"My Subtitle\": Adding a subtitle\nplot_title = \"My New Title\": Changing the map title\n\nPlease consult the Plots.jl package documentation for a comprehensive list\n\n\n\n\n\n","category":"function"},{"location":"api_mapping/#GEMS.agsmap","page":"Mapping","title":"GEMS.agsmap","text":"agsmap(df::DataFrame, level::Int64; plotargs...)\n\nReturns a Plot.js plot with shapes of German states, counties, or municipalities. The input dataframe df requires two columns. The first column needs to be named ags and has to be a vector of AGS structs (Amtlicher Gemeindeschlüssel). The second column needs to be a vector of numerical values which are used to color-code the map. The level argument defines wether the map plots states (level = 1), counties (level = 2) or municipalities (level = 3). Note that the AGS in the dataframe must thus also be of the same geographic resolution. The optional plotargs... are passed to the plot object. Please lookup the Plots.jl package for more information about what arguments can be used to customize a plot.\n\nParameters\n\ndf::DataFrame: DataFrame with ags-named column that contains AGS structs and   a second column with numerical values.\nlevel::Int64: Map resolution. states (level = 1), counties (level = 2) or municipalities (level = 3)\nplotargs... (optional): Any argument that the plot() function of the Plots.jl package can take.\n\nReturns\n\nPlots.Plot: Plot using the Plots.jl package's struct.\n\n\n\n\n\nagsmap(df::DataFrame; plotargs...)\n\nWrapper for the agsmap function that infers the correct geographical resolution (level) from the input dataframe. Please lookup the agsmap(df, level; plotargs...) function's docstring for more information.\n\n\n\n\n\n","category":"function"},{"location":"api_mapping/#GEMS.generate_map","page":"Mapping","title":"GEMS.generate_map","text":"generate_map(coords::DataFrame, dest::AbstractString; region = [], plotempty::Bool = false)\n\nGenerates a GMT map and stores it into the folder specified in dest. The coords DataFrame must provide at least a lat- and a lon-column specifying latitude and longitude data pairs. The region parameter expects an array of four integer values providing the outer bounds of the map according to [min_lon, max_lon, min_lat, max_lat]. If no region parameter is passed, the bounds are taken from the lan/lon  range provided in the coords data with a %-padding according to MAP_PADDING defined in constants.jl . With the plotempty flag you can force to plot a map without any data points.\n\nParameters\n\ncoords::DataFrame: Dataframe with lat and lon column\ndest::AbstractString: Storage location for the generated map\nregion = [] (optional): four-item region vector defining the map limits in lat/lon min/max pairs   (look up GMT.jl package to learn about regions)\nplotempty::Bool = false (optional): Allows to plot an empty map if no data points are given\n\nReturns\n\nGMTWrapper: Custom struct containing the storage location of the generated map \n\n\n\n\n\n","category":"function"},{"location":"api_mapping/#GEMS.germanshapes-Tuple{Int64}","page":"Mapping","title":"GEMS.germanshapes","text":"germanshapes(level::Int64)\n\nReturns the Shapefile.Table object read from the respective shapefile. Downloads the file if it is not already locally available. Lookup constants.jl to find remote location of the shapefile. The level argument defines wether the state- (level = 1), county- (level = 2) or municipality- (level = 3) shapes are returned.\n\nReturns\n\nShapefile.Table{Union{Missing, Shapefile.Polygon}}: Shapefile data.     Lookup Shapefile.jl package for documentation.\n\n\n\n\n\n","category":"method"},{"location":"api_mapping/#GEMS.maptypes","page":"Mapping","title":"GEMS.maptypes","text":"maptypes()\n\nReturns a list of all map types that can be used for the gemsmap() function.\n\n\n\n\n\n","category":"function"},{"location":"api_mapping/#GEMS.prepare_map_df!","page":"Mapping","title":"GEMS.prepare_map_df!","text":"prepare_map_df!(df::DataFrame; level::Int = 3)\n\nInput df requires the format that can go into the agsmap() function. This means, at least two columns, the first one being an AGS column called ags and a second column with numerical values. The level argument converts the AGSs to the desired geographical resolution: states (level = 1), counties (level = 2) or municipalities (level = 3)\n\nReturns\n\nDataFrame: Adapted dataframe with desired AGS resolution in first column.\n\n\n\n\n\n","category":"function"},{"location":"api_mapping/#GEMS.region_range-Tuple{DataFrame}","page":"Mapping","title":"GEMS.region_range","text":"region_range(coords::DataFrame)\n\nreturns outer bound lat/lon for map plotting based in the provided coordinates dataframe. Adds a padding as specified in MAP_PADDING in constants.jl\n\n\n\n\n\n","category":"method"},{"location":"contributing-guide/#Contributing-to-GEMS","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"","category":"section"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"In case you want to contribute to the GEMS package, please consider that we follow a workflow for the development for which you will find a brief guideline here. We are excited to see your contibutions to this project!","category":"page"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"Contributions to GEMS are released to the public under the project’s open source license.","category":"page"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"You can open issues to request features and report bugs or directly add to the code base via pull requests.","category":"page"},{"location":"contributing-guide/#Issues","page":"Contributing to GEMS","title":"Issues","text":"","category":"section"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"Feature: Something that you would like to see in GEMS.\nProvide a meaningful title\nSpecify your use-case precisely and suggest how to address the issue you currently encounter\nBugs: Something that doesn't work as expected.\nProvide a meaningful title\nInclude detailed examples on how to reproduce the issue\nDescribe the observed AND expected behavior in detail ","category":"page"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"Before submitting an issue, please make sure you're not submitting a duplicate and review the currently open issues. If there is an issue addressing your request, add a thumbs-up to help us prioritize fixes.","category":"page"},{"location":"contributing-guide/#Pull-Requests","page":"Contributing to GEMS","title":"Pull Requests","text":"","category":"section"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"Another way to directly contribute to GEMS is through pull requests (PRs). Please follow these steps to submit PRs:","category":"page"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"Fork and clone the GEMS repository\nInstall GEMS\nCreate a new branch\nApply your changes to the code\nPush to your fork\nMake a pull request","category":"page"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"We will review your code changes as soon as possible. However, there is no guarantee your PR will be merged. Moreover, we might get back to you with requests after review. These are our review requirements:","category":"page"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"Up-to-date with master with no merge conflicts\nSelf-contained\nFollowing the Julia Style Guide\nNew functions have complete, correctly formatted docstrings (see Style Guide below)\nNew features have a unit tests\nDocumentation updated (if applicable)\nOptional for substantial extensions: Add a tutorial to the documentation","category":"page"},{"location":"contributing-guide/#Style-Guides","page":"Contributing to GEMS","title":"Style Guides","text":"","category":"section"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"There is an official style guide for Julia, the Julia Style Guide.","category":"page"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"This guide was mostly used for the Blue Style. We will follow the Blue style, but as the Julia Style Guide is a large part of the Blue Style, there wont be many cases, where following the Julia Style Guide would be far off.","category":"page"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"Some differences include a 92 character line limit or the snake_case for method names. When in doubt, look at existing code in the project/module/file.","category":"page"},{"location":"contributing-guide/#GEMS-Docstring-Format","page":"Contributing to GEMS","title":"GEMS Docstring Format","text":"","category":"section"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"We require every function in GEMS to have a docstring like this:","category":"page"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"complete signature copied to the very top (indented). If you have multiple functions of the same name (that do roughly the same), copy all signatures here. You don't need to have docstrings for all functions of the same name.\nAdd a clear and expressive description of what the function does.\nAdd a parameter section for each function with 3+ arguments\nParameters are presented as a list with argument name, type and description\nOptional parameters are qualified as such and state their default value\nAdd a section that states the return value type and brief explanation.","category":"page"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"Here's an example:","category":"page"},{"location":"contributing-guide/","page":"Contributing to GEMS","title":"Contributing to GEMS","text":"\"\"\"\n    my_function(a::Int, b::Float; c::String = \"Hello\")\n\nThis is a clear, concise, and (ideally) short description of what the function does.\n\n# Parameters\n\n- `a::Int`: First required input argument\n- `b::Float`: Second required input argument\n- `c::String = \"Hello\"` *(optional)*: Optional string-argument\n\n# Returns\n\n- `Int`: 42, which is always right, no matter the input.\n\n\"\"\"\nfunction my_function(a::Int, b::Float; c::String = \"Hello\")\n    # do stuff\n    return 42\nend","category":"page"},{"location":"tut_npi/#9-Intervention-Strategies","page":"9 - Modeling Interventions","title":"9 - Intervention Strategies","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"GEMS offers extensive options for intervention modeling. We represent interventions using the \"Trigger-Strategy-Measure\" (TriSM) notation. Find an introduction to the TriSM notation here.","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"TriSM is more of a modeling paradigm and as such offers countless scenarios that could be modeled. This chapter contains a selection of examples to give you a broad idea. The examples will always compare an invervention scenario with a non-restricted baseline scnario to verify that there is an effect.","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"info: Where's the list of measures I can use to build up strategies?\nRun i_measuretypes() to get a list of all measures that apply to individuals or s_measuretypes() for a list of all measures that apply to settings. If you want to learn more about any of the measure types, put a ? into the Julia REPL and call help?> SelfIsolation (replace SelfIsolation with the measure name you want to learn about). ","category":"page"},{"location":"tut_npi/#Self-Isolation-With-Symptoms","page":"9 - Modeling Interventions","title":"Self-Isolation With Symptoms","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Here's an example that sends individuals into household-isolation for 14 days, if they are symptomatic. To do so, we set up an IStrategy called \"self_isolation\" and add an instance of the SelfIsolation measure with the duration parameter set to 14.","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Scenario Summary:","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Individuals go into self-isolation for 14 days, immediately upon experiencing symptoms\nIsolation prevents out-household contacts, but not in-household contacts\nIndividuals end their isolation after 14 days, regardless of their infection state","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"using GEMS\n# simulation without interventions\nbaseline = Simulation(label = \"Baseline\")\n\n# simulation with 14-day isolation (at home) upon experiencing symptoms\nscenario = Simulation(label = \"Scenario\")\nself_isolation = IStrategy(\"Self Isolation\", scenario)\nadd_measure!(self_isolation, SelfIsolation(14))\ntrigger = SymptomTrigger(self_isolation)\nadd_symptom_trigger!(scenario, trigger)\n\nrun!(baseline)\nrun!(scenario)\n\nrd_b = ResultData(baseline)\nrd_s = ResultData(scenario)\n\ngemsplot([rd_b, rd_s], type = (:TickCases, :CumulativeDiseaseProgressions, :CumulativeIsolations))","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Plot","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_interventions_self-isolation.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"The results show the difference between daily cases in both scenarios. It also displays that there are around one third of asymptomatic cases in both experiments that would not be affected by this measure. Using the :CumulativeIsolations plot, you can inspect the number of people who are currently in isolation at any given time.","category":"page"},{"location":"tut_npi/#Conditioned-Measures-(Isolation)","page":"9 - Modeling Interventions","title":"Conditioned Measures (Isolation)","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"The execution of measures and strategies can be conditioned. Here's the self-isolation scenario again but it shall only apply to students. School kids that are symptomatic shall be isolated for 14 days. We can achieve this by passing the optional condition-argument to the add_measure!(...) function. The condition itself must be a one-argument predicate function (a function that returns true or false) that is being evaluated once the measure is being triggered. In the example below, we pass the is_student(individual) function that returns true if an individual is a student.","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Scenario Summary:","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Students go into self-isolation for 14 days, immediately upon experiencing symptoms\nIsolation prevents out-household contacts, but not in-household contacts\nStudents end their isolation after 14 days, regardless of their infection state","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"using GEMS\n# simulation without interventions\nbaseline = Simulation(label = \"Baseline\")\n\n# simulation with 14-day isolation (at home)\n# upon experiencing symptoms if you are a student\nscenario = Simulation(label = \"Isolate Students\")\nself_isolation = IStrategy(\"Self Isolation\", scenario)\nadd_measure!(self_isolation, SelfIsolation(14), condition = is_student)\ntrigger = SymptomTrigger(self_isolation)\nadd_symptom_trigger!(scenario, trigger)\n\nrun!(baseline)\nrun!(scenario)\n\nrd_b = ResultData(baseline)\nrd_s = ResultData(scenario)\n\ngemsplot([rd_b, rd_s], type = :TickCases)","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Plot","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_interventions_conditioned-isolation-1.png\" width=\"60%\"/>\n</p>","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"You can also setup a custom condition-function. Here's an example where people who are older than 50 should be isolated.","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Scenario Summary:","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Individuals of age 50+ go into self-isolation for 14 days, immediately upon experiencing symptoms\nIsolation prevents out-household contacts, but not in-household contacts\nStudents end their isolation after 14 days, regardless of their infection state","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"using GEMS\n# simulation without interventions\nbaseline = Simulation(label = \"Baseline\")\n\n# function to evaluate whether an individual is over 50\nfunction is_over_50(individual)\n    return age(individual) >= 50\nend\n\n# simulation with 14-day isolation (at home)\n# upon experiencing symptoms if you are 50+\nscenario = Simulation(label = \"Isolate 50+\")\nself_isolation = IStrategy(\"Self Isolation\", scenario)\nadd_measure!(self_isolation, SelfIsolation(14), condition = is_over_50)\ntrigger = SymptomTrigger(self_isolation)\nadd_symptom_trigger!(scenario, trigger)\n\nrun!(baseline)\nrun!(scenario)\n\nrd_b = ResultData(baseline)\nrd_s = ResultData(scenario)\n\ngemsplot([rd_b, rd_s], type = :TickCases)","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Plot","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_interventions_conditioned-isolation-2.png\" width=\"60%\"/>\n</p>","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"It's also possible to pass (one-argument) lambda functions where the argument will be the individual. In this is example, we only send people into self-isolation who are living in households larger than 5.","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Scenario Summary:","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Individuals living in households of size 5+ go into self-isolation for 14 days, immediately upon experiencing symptoms\nIsolation prevents out-household contacts, but not in-household contacts\nStudents end their isolation after 14 days, regardless of their infection state","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"using GEMS\n# simulation without interventions\nbaseline = Simulation(label = \"Baseline\")\n\n# simulation with 14-day isolation (at home)\n# upon experiencing symptoms if you are a in a 5+ household\nscenario = Simulation(label = \"Isolate if in Large Household\")\nself_isolation = IStrategy(\"Self Isolation\", scenario)\nadd_measure!(self_isolation, SelfIsolation(14),\n    condition = i -> size(household(i, scenario)) > 5)\ntrigger = SymptomTrigger(self_isolation)\nadd_symptom_trigger!(scenario, trigger)\n\nrun!(baseline)\nrun!(scenario)\n\nrd_b = ResultData(baseline)\nrd_s = ResultData(scenario)\n\ngemsplot([rd_b, rd_s], type = :TickCases)","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Plot","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_interventions_conditioned-isolation-3.png\" width=\"60%\"/>\n</p>","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"info: Does it work the same way for SStrategies and SMeasures?\nYes. In the above examples, we condition measures that apply to individuals (IMeasures). The argument in the condition-functions is the focus individual that this measure applies to. For SMeasures, the argument for the condition-functions is the respective setting.","category":"page"},{"location":"tut_npi/#Household-Isolation","page":"9 - Modeling Interventions","title":"Household Isolation","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"The previous examples let a symptomatic individual stay at home but did not force the other household members to do too. If you want to isolate the entire household of symptomatic individuals, the following code will help you. It is very similar to the previous example but instead of triggering the isolation strategy directly, an individual becoming symptomatic will trigger the \"find_household_members\" strategy that contains a FindSettingMembers measure. This measure is parameterized to detect all members of the individual's Household setting. The members are then all isolated individually, the same way as in the previous example. This can also be considered a form of contact tracing.","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Scenario Summary:","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"One individual experiencing symptoms will cause all household members to go into isolation for 14 days\nThis prevents all out-household contacts, within household contacts are still possible\nAfter 14 days, all household members end their isolation, regardless of any of their infection states","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"using GEMS\n# simulation without interventions\nbaseline = Simulation(label = \"Baseline\")\n\n# simulation with 14-day isolation for all household members\nscenario = Simulation(label = \"Scenario\")\nself_isolation = IStrategy(\"Self Isolation\", scenario)\nadd_measure!(self_isolation, SelfIsolation(14))\n# identify list of household members\nfind_household_members = IStrategy(\"Find Household Members\", scenario)\nadd_measure!(find_household_members, FindSettingMembers(Household, self_isolation))\n# trigger \"household tracing\"\ntrigger = SymptomTrigger(find_household_members)\nadd_symptom_trigger!(scenario, trigger)\n\nrun!(baseline)\nrun!(scenario)\n\nrd_b = ResultData(baseline)\nrd_s = ResultData(scenario)\n\ngemsplot([rd_b, rd_s], type = (:TickCases, :CumulativeIsolations))","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Plot","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_interventions_household-isolation.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"The numbers suggest, that isolating the entire household prevents more cases, compared to isolating only the symptomatic individual, but also causes more isolations. Using gemsplot, you can compare both scenarios and the baseline. The following code combines the previous two examples:","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"using GEMS\n# simulation without interventions\nbaseline = Simulation(label = \"Baseline\")\n\n# simulation with 14-day isolation (at home) upon experiencing symptoms\nscenario_1 = Simulation(label = \"Symptomatic Isolation\")\nself_isolation = IStrategy(\"Self Isolation\", scenario_1)\nadd_measure!(self_isolation, SelfIsolation(14))\ntrigger = SymptomTrigger(self_isolation)\nadd_symptom_trigger!(scenario_1, trigger)\n\n# simulation with 14-day isolation for all household members\nscenario_2 = Simulation(label = \"Household Isolation\")\nself_isolation = IStrategy(\"Self Isolation\", scenario_2)\nadd_measure!(self_isolation, SelfIsolation(14))\nfind_household_members = IStrategy(\"Find Household Members\", scenario_2)\nadd_measure!(find_household_members, FindSettingMembers(Household, self_isolation))\ntrigger = SymptomTrigger(find_household_members)\nadd_symptom_trigger!(scenario_2, trigger)\n\nrun!(baseline)\nrun!(scenario_1)\nrun!(scenario_2)\n\nrd_b = ResultData(baseline)\nrd_s1 = ResultData(scenario_1)\nrd_s2 = ResultData(scenario_2)\n\ngemsplot([rd_b, rd_s1, rd_s2],\n    type = (:TickCases, :CumulativeIsolations, :EffectiveReproduction),\n    legend = :topright)","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Plot","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_interventions_household-isolation2.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_npi/#Testing-and-Isolation","page":"9 - Modeling Interventions","title":"Testing and Isolation","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"GEMS comes with pre-defined building blocks for modeling testing strategies. The following example subjects symptomatic individuals to a test and isolates them for 14 days, once the test is positive. For that, a TestType is being defined, providing a name (\"PCR_Test\"), the pathogen (taken from the Simulation object), and the Simulation object itself. The self-isolation strategy is the same as in the first example. However, it is only fired, once an individual is tested positive. This is configured via a second strategy that we call \"testing\" where we add a Test measure that should use the previously defined \"PCRTest\" and follow a positive test up with the \"self\\isolation\" strategy. A SymptomTrigger fires the \"testing\" strategy once an individual becomes symptomatic.","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Scenario Summary:","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Upon experiencing symptoms, individuals are being tested immediately\nThe test has a 100% sensitivity and 100% specificity\nTest results are available immediately\nIf the test result is positive, the individual goes into isolation for 14 days","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"using GEMS\n# simulation without interventions\nbaseline = Simulation(label = \"Baseline\")\n\n# simulation with 14-day isolation after positive test\nscenario = Simulation(label = \"Scenario\")\n# define test type (PCR test)\nPCR_Test = TestType(\"PCR Test\", pathogen(scenario), scenario)\n# define self isolation strategy\nself_isolation = IStrategy(\"Self Isolation\", scenario)\nadd_measure!(self_isolation, SelfIsolation(14))\n# define testing strategy that triggers self isolation\ntesting = IStrategy(\"Testing\", scenario)\nadd_measure!(testing, Test(\"Test\", PCR_Test, positive_followup = self_isolation))\n\ntrigger = SymptomTrigger(testing)\nadd_symptom_trigger!(scenario, trigger)\n\nrun!(baseline)\nrun!(scenario)\n\nrd_b = ResultData(baseline)\nrd_s = ResultData(scenario)\n\ngemsplot([rd_b, rd_s], type = (:TickCases, :TickTests, :ActiveDarkFigure), size = (800, 800))","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Plot","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_interventions_testing.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"The results are very similar to the first example as all symptomatic individuals are immediately screened with a \"perfect\" test (100% sensitivity & specificity) and immediately sent in isolation. Of course, in reality this not very realistic. Therefore, GEMS offers options to delay measures (e.g., only getting a test one day after symptom onset). Please look up the respective tutorial.","category":"page"},{"location":"tut_npi/#Delayed-Measures-(Testing)","page":"9 - Modeling Interventions","title":"Delayed Measures (Testing)","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"The timing of intervention strategies is crucial in most applications. GEMS has two mechanisms to define the execution time of a measure. Both can be passed as optional arguments to the add_measure!(...) function. The offset defines how many ticks should be between the trigger event of a measure's parent strategy and the execution of the respective measure. It's default value is 0. The delay takes a one-argument function that is being evaluated at runtime and needs to return an integer value. These functions work very similar to the condition-function. Please look up the previous example on conditioned measures. The results of this delay-function is added on top of the offset. It can be used to delay the execution of measures, e.g., based on  an individual's personal characteristics. In the following scenarios, we compare two scenarios: (1) where individuals get a test immediately and go into isolation if the results come back positive (as in the previous tutorial) and (2) where individuals below the age of 50 get the test immediately an 50+ individuals get them one day after.","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Scenario Summary:","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Upon experiencing symptoms, individuals are being tested\nIn scenario 1, tests are being applied immediately. In scenario 2, tests are being applied with a one-day delay for people above the age of 50\nThe test has a 100% sensitivity and 100% specificity\nTest results are available immediately\nIf the test result is positive, the individual goes into isolation for 14 days","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"using GEMS, Plots\n\n# SCENARIO 1: No testing delay\nscenario_1 = Simulation(label = \"No Delay\")\nPCR_Test_1 = TestType(\"PCR Test\", pathogen(scenario_1), scenario_1)\nself_isolation_1 = IStrategy(\"Self Isolation\", scenario_1)\nadd_measure!(self_isolation_1, SelfIsolation(14))\ntesting_1 = IStrategy(\"Testing\", scenario_1)\nadd_measure!(testing_1, Test(\"Test\", PCR_Test_1, positive_followup = self_isolation_1))\ntrigger_1 = SymptomTrigger(testing_1)\nadd_symptom_trigger!(scenario_1, trigger_1)\n\n# SCENARIO 2: 1-day delay for 50+ people\nscenario_2 = Simulation(label = \"1-Day delay for 50+\")\nPCR_Test_2 = TestType(\"PCR Test\", pathogen(scenario_2), scenario_2)\nself_isolation_2 = IStrategy(\"Self Isolation\", scenario_2)\nadd_measure!(self_isolation_2, SelfIsolation(14))\ntesting_2 = IStrategy(\"Testing\", scenario_2)\nadd_measure!(testing_2, Test(\"Test\", PCR_Test_2, positive_followup = self_isolation_2),\n    delay = i -> age(i) >= 50 ? 1 : 0) # delay function\ntrigger_2 = SymptomTrigger(testing_2)\nadd_symptom_trigger!(scenario_2, trigger_2)\n\n# run everything\nb = Batch(scenario_1, scenario_2)\nrun!(b)\nrd = ResultData(b)\n\nplot(\n    gemsplot(rd, type = :TickCases),\n    gemsplot(rd, type = :TimeToDetection, ylims = (0, 6)),\n    layout = (2, 1),\n    size = (800, 800)\n)","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Plot","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_interventions_delayed-testing.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"The above plot shows that just a one-day delay for just a fraction of the individuals can have a substantial impact on the overall daily cases. The Time-To-Detection plot visualizes the average time between exposure and a positive test result. You can see that the average time is around half a day longer in the delayed scenario.","category":"page"},{"location":"tut_npi/#Subpar-Test-(Poor-Specificity)","page":"9 - Modeling Interventions","title":"Subpar Test (Poor Specificity)","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Mass-testing strategies can lead to a large number of individuals in isolation who are not actually infected if the test has a low specificity (false-positive-rate). In GEMS you can easily estimate the impact of subpar testing kits. In the example below, we assume a test with a 20% false-positive-rate (80% specificity). Once an individual experiences symptoms, all members of their household (including themselves) are subjected to a test and sent into household isolation for two weeks if the results are positive.","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Scenario Summary:","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Upon experiencing symptoms, all people in the symptomatc individual's household get tested (including the index individual)\nThe test has a specificity of 80%. It will identify a non-infected individual as infected in 20% of the cases (false positives)\nIf multiple people in the household are infected, each individual will get tested multiple times\nTest results are available immediately\nWith a positive test result, the individual will go into self-isolation for 14 days","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"using GEMS, Plots\n\nscenario = Simulation(label = \"Household Testing\")\n\n# isolation strategy (14 days)\nself_isolation = IStrategy(\"Self Isolation\", scenario)\nadd_measure!(self_isolation, SelfIsolation(14)) \n\n# subpar test (80% specificity)\nantigen_test = TestType(\"Antigen Test\", pathogen(scenario), scenario, specificity = 0.8)\n\n# testing strategy\ntesting = IStrategy(\"Testing\", scenario)\nadd_measure!(testing, Test(\"Household Screening\", antigen_test,\n    positive_followup = self_isolation))\n\n# strategy to detect household members\nfind_household = IStrategy(\"find Household Members\", scenario)\nadd_measure!(find_household, FindSettingMembers(Household, testing))\n\n# trigger houshold member identification\ntrigger = SymptomTrigger(find_household)\nadd_symptom_trigger!(scenario, trigger)\n\n# setup count functions & custom logger\ncnt_isolated_infected(sim) =\n    count(i -> (isquarantined(i) && infected(i)), population(sim))\ncnt_isolated_non_infected(sim) =\n    count(i -> (isquarantined(i) && !infected(i)), population(sim))\ncl = CustomLogger(\n    isolated_infected = cnt_isolated_infected,\n    isolated_non_infected = cnt_isolated_non_infected)\ncustomlogger!(scenario, cl)\n\n# run simulation & plot results\nrun!(scenario)\nrd = ResultData(scenario)\nplot(\n    gemsplot(rd, type = :DetectedCases),\n    gemsplot(rd, type = :CustomLoggerPlot, ylims = (0, 1500)),\n    layout = (2, 1),\n    size = (800, 800))","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Plot","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_interventions_subpar_test.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"The \"detected cases\" plot now shows that there are more reported cases (sum of the stacked areas) than true new cases (black dotted line). This is interesting considering, that only 60% of the individual will trigger the strategy (40% are asymptomatic). The extensive testing strategy combined with the poor test quality leads to a substantial number of double reports (individuals who are tested positive multiple times) and false positives (individuals who tested positive without being infected). It can be seen that the number of isolated non-infected individuals peak higher than actually infected individuals in isolation, even though we only send people into isolation if they produced a positive test result.","category":"page"},{"location":"tut_npi/#*Ghost*-Epidemic","page":"9 - Modeling Interventions","title":"Ghost Epidemic","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"In this example, we show how a test with low specificity can cause a \"ghost\" epidemic. We start with the initial 100 infections in the default model and set the transmission_rate to 0, effectively preventing all further infections. For each of the 100 initial infections, we sample 10 random individuals (\"contacts\") from the GlobalSetting (the setting that contains all individuals in the simulation). We subject these selected contacts to a test with low specificity (85%), which causes a false positive result in 15% of the cases. A positive test will again trigger the selection of 10 more random contacts. We assume that this is a very basic form of \"contact tracing\".","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Note: In the example below, we first define all strategies and add measures later. That's necessary enable the recursive execution of strategies (they have to be \"known\" in order to reference them in measures).","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Scenario Summary:","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"No transmissions, only the initial 100 infections are actually ill\nUpon experiencing symptoms, we select 10 random individuals from the global setting with a 1-5 day delay\nEach individual will be subjected to a 85%-specificity test\nA positive test result will again cause the sampling of 10 random \"contacts\" ","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"using GEMS\n\n# simulation with no transmissions and switched on global setting\nsim = Simulation(transmission_rate = 0.0, global_setting = true)\n# strategy definitions\nfind_globalsetting = IStrategy(\"find setting\", sim)\nfind_contacts = SStrategy(\"find contacts\", sim)\ntesting = IStrategy(\"testing\", sim)\n# test with 85% specificity\npoor_test = TestType(\"Poor Test\", pathogen(sim), sim, specificity = 0.85)\n# identify global setting\nadd_measure!(find_globalsetting, FindSetting(GlobalSetting, find_contacts))\n# sample 10 contacts grom global setting with 1-5 day delay\nadd_measure!(find_contacts,\n    FindMembers(testing, sample_size = 10), delay = x -> rand(1:5))\n# test individual if unreported or last report more than 6 months old\n# run \"contact tracing\" for positive test results\nadd_measure!(testing,\n    Test(\"poor-test\", poor_test, positive_followup = find_globalsetting),\n    condition = i -> (last_reported_at(i) <= 0 || tick(sim) - last_reported_at(i) >= 180))\n\ntrigger = SymptomTrigger(find_globalsetting)\nadd_symptom_trigger!(sim, trigger)\n\nrun!(sim)\nrd = ResultData(sim)\ngemsplot(rd,\n    type = (:CompartmentFill, :EffectiveReproduction, :DetectedCases),\n    legend = :topright)","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Plot","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_interventions_ghost_epidemic.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"The results show that except for the initial 100 infections, no transmission dynamics are present in the simulation. The effective reproduction number is constantly at zero. However, we see an exponential growth in \"detected cases\" that mimicks an epidemic curve and at some point detects more than 2% of the overall individuals as new infections each day although 100% of the \"detection\" are false positives.","category":"page"},{"location":"tut_npi/#Varying-Test-Sensitivity-(or-Specificity)","page":"9 - Modeling Interventions","title":"Varying Test Sensitivity (or Specificity)","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Here's an example of how you can vary intervention-related parameter such as the sensitivity of a test and inspect their influence on the overall dynamics. The code below defines what we call a \"scenario-function\" (testing_scenario!()). It takes the Simulation object and a sensitivity argument to parameterize the test. That way, it is much easier to set up multiple intervention scenarios with varying parameters. Moreover, the example uses the Batch functionality to easily aggregate all simulations and facilitate the execution and post-processing.","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"using GEMS\n\n# to facilitate parameterization, set up a function\n# that adds a scenario to a simulation object\nfunction testing_scenario!(sim, sens)\n    # define test type (PCR test) and pass sensitivity\n    PCR_Test = TestType(\"PCR Test\", pathogen(sim), sim, sensitivity = sens)\n    # define self isolation strategy\n    self_isolation = IStrategy(\"Self Isolation\", sim)\n    add_measure!(self_isolation, SelfIsolation(14))\n    # define testing strategy that triggers self isolation\n    testing = IStrategy(\"Testing\", sim)\n    add_measure!(testing, Test(\"Test\", PCR_Test, positive_followup = self_isolation))\n\n    trigger = SymptomTrigger(testing)\n    add_symptom_trigger!(sim, trigger)\nend\n\n# use batch functionality to compare results\nsims = Simulation[]\npush!(sims, Simulation(label = \"Baseline\"))\n\n# add scenarios with varying test sensitivities between 50% and 100%\nfor i in 0.5:0.1:1.0\n    s = Simulation(label = \"Sensitivity: $(100 * i)%\")\n    testing_scenario!(s, i)\n    push!(sims, s)\nend\n\nb = Batch(sims...)\nrun!(b)\nrd = ResultData(b)\n\ngemsplot(rd, type = (:TickCases, :CumulativeIsolations), legend = :topright)","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Plot","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_interventions_testing2.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"info: Can I run experiments that vary a test's specificity the same way?\nYes. ","category":"page"},{"location":"tut_npi/#Limited-Capacity-(Testing)","page":"9 - Modeling Interventions","title":"Limited Capacity (Testing)","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"In public health practice, working with limited resource capacities is often a challenging factor. This example demonstrates the impact of a capacity limit (regarding tests) on the overall observed progression. We compare two scenarios in which symptomatic individuals are tested (no other intervention applied). However, in the second scenario, only 50 tests can be applied per day.","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Scenario Summary:","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"15% transmission rate (to spread out the curve)\nSymptomatic individuals are tested in both scenarios\nNo further interventions apply\nIn the second scenarios, only the first 50 symptomatic individuals per day are tested ","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"using GEMS, Plots\n\n# BASELINE: simulation with unlimited testing capacity\nbaseline = Simulation(label = \"Unlimited Testing\", transmission_rate = 0.15)\nPCR_Test_b = TestType(\"PCR Test\", pathogen(baseline), baseline)\ntesting_b = IStrategy(\"Testing\", baseline)\nadd_measure!(testing_b, Test(\"Test\", PCR_Test_b))\ntrigger_b = SymptomTrigger(testing_b)\nadd_symptom_trigger!(baseline, trigger_b)\n\n# helper struct to count daily tests\nmutable struct TestCounter\n    tick\n    count\nend\n\n# helper function to add up daily tests\n# returns true until test capacity for the day (50) is used up\nfunction test_available!(sim, tc)\n    if tick(sim) > tc.tick\n        tc.tick = tick(sim)\n        tc.count = 1\n    else\n        tc.count += 1\n    end\n    tc.count < 50 ? true : false\nend\n\n# SCENARIO: simulation with 50 tests per day\ntc = TestCounter(0,0) # test counter (tick, tests)\nscenario = Simulation(label = \"Limited Testing Capacity\", transmission_rate = 0.15)\nPCR_Test_s = TestType(\"PCR Test\", pathogen(scenario), scenario)\ntesting_s = IStrategy(\"Testing\", scenario)\nadd_measure!(testing_s, Test(\"Test\", PCR_Test_s),\n    condition = i -> test_available!(scenario, tc)) # condition \"adds up\" daily tests\ntrigger_s = SymptomTrigger(testing_s)\nadd_symptom_trigger!(scenario, trigger_s)\n\nrun!(baseline)\nrun!(scenario)\n\nrd_b = ResultData(baseline)\nrd_s = ResultData(scenario)\n\ngemsplot([rd_b, rd_s],\n    type = (:TickCases, :EffectiveReproduction, :ObservedReproduction, :ActiveDarkFigure),\n    size = (1000, 1200))","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Plot","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_interventions_limited_capacity.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"We see that both simulations have a very similar true infection- and effective reproduction number curves. The observed reproduction number, however, differs significantly once the daily-testing threshold of 50 cases is reached. In the second scenario, the observed reproduction number is constantly at exactly 1, suggesting that the growth of the epidemic is linear instead of exponential. This is due to the fact that we get the limited 50 positive tests each day, every day. The active dark figure reveals that once the threshold is reached, the number of undetected cases siddenly spikes. While this example considers capacity limits with regard to testing, you can apply the same mechanics to other capacity-constrained measures such as contact-tracing or vaccination.","category":"page"},{"location":"tut_npi/#Pool-Testing","page":"9 - Modeling Interventions","title":"Pool Testing","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Besides individual testing, GEMS also offers the option to perform so-called \"pool tests\". Such tests return a positive result if at least one individual in a given setting is infected. Working with pool tests is very similar to other testing scenarios with the main difference being, that pool tests are applied to settings, not to individuals. Consequently, a positive pool test does not provide any information about whom of the individuals is infected. The example below tests all school classes every seven days and closes the class for the following week if the pool test result is positive. We furthermore add a CustomLogger to track the number of currently closed school classes.","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Scenario Summary:","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Pool-testing every school class once a week\nIf test is positive, school class is closed for the week","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"using GEMS\n# simulation without interventions\nbaseline = Simulation(label = \"Baseline\")\n\nself_isolation = IStrategy(\"Self Isolation\", scenario_1)\nadd_measure!(self_isolation, SelfIsolation(14))\ntrigger = SymptomTrigger(self_isolation)\nadd_symptom_trigger!(scenario_1, trigger)\n\n# simulation with school class closure for 7 days if pool test positive\nscenario = Simulation(label = \"Scenario\")\n# define test type (PCR test)\nPCR_Test = TestType(\"PCR Test\", pathogen(scenario), scenario)\n# strategy that closes classes for the next 6 days\nclass_close_and_reopen = SStrategy(\"Class Close and Reopen\", scenario)\nadd_measure!(class_close_and_reopen, CloseSetting())\nadd_measure!(class_close_and_reopen, OpenSetting(), offset = 6)\n# strategy that tests whether at least one infected individual is in class\nclass_pool_test = SStrategy(\"Class Monday Pool Testing\", scenario)\nadd_measure!(class_pool_test, PoolTest(\"monday_pool_testing\", PCR_Test,\n    positive_followup = class_close_and_reopen))\n# add trigger that is being fired every 7 days for each school class\nstt = STickTrigger(SchoolClass, class_pool_test, interval = Int16(7))\nadd_tick_trigger!(scenario, stt)\n\nb = Batch(baseline, scenario)\n\n# add logger to track number of currently closed school classes\ncl = CustomLogger(closed_classes = sim -> sum(.!is_open.(schoolclasses(sim))))\ncustomlogger!(b, cl)\n\nrun!(b)\nrd = ResultData(b)\n\ngemsplot(rd, type = (:TickCases, :CustomLoggerPlot))","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Plot","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_interventions_pool-testing.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_npi/#Recurrent-Testing","page":"9 - Modeling Interventions","title":"Recurrent Testing","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Let's consider an example where individuals can get tested multiple times. The code below compares two scenarios where individuals go into self-isolation for 10 days upon experiencing symptoms. In the second example, individuals can get tested after five days and leave isolation if the test is negative. With a positive test, individuals can get another test two days later. We neglect the fact that this will cause some tests to be performed on day 11.","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Scenario Summary:","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"A symptomatic individual goes into self-isolation for 10 days\nAfter day 5, they can get a test\nIf the test is negative, the individual may leave isolation\nIf the test is positive, the individual remains isolated and may test again after 48 hours\nIndividuals will get tested in a two-day interval as long as they are infected","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"using GEMS\n\n# SCENARIO 1: simulation with self-isolation only\nscenario_1 = Simulation(label = \"Isolation Only\")\nself_isolation = IStrategy(\"Self Isolation\", scenario_1)\nadd_measure!(self_isolation, SelfIsolation(14))\ntrigger_1 = SymptomTrigger(self_isolation)\nadd_symptom_trigger!(scenario_1, trigger_1)\n\n# SCENARIO 2: simulation with self-isolation and recurrent testing\nscenario_2 = Simulation(label = \"Recurrent Testing\")\n# define test type (PCR test)\nPCR_test = TestType(\"PCR Test\", pathogen(scenario_2), scenario_2)\n# strategy that ends isolation\nend_isolation = IStrategy(\"End Isolation\", scenario_2)\nadd_measure!(end_isolation, CancelSelfIsolation())\n# testing strategy that triggers itself after two days if positive\nrecurrent_test = IStrategy(\"Recurrent Testing\", scenario_2)\nadd_measure!(recurrent_test,\n    Test(\"Recurrent Test\", PCR_test,\n        positive_followup = recurrent_test,\n        negative_followup = end_isolation),\n    offset = 2)\n# self-isolation and initial testing strategy\nisolation_and_test = IStrategy(\"Self Isolation\", scenario_2)\nadd_measure!(isolation_and_test, SelfIsolation(10))\nadd_measure!(isolation_and_test,\n    Test(\"First Test\", PCR_test,\n        positive_followup = recurrent_test,\n        negative_followup = end_isolation),\n    offset = 5)\ntrigger_2 = SymptomTrigger(isolation_and_test)\nadd_symptom_trigger!(scenario_2, trigger_2)\n\nb = Batch(scenario_1, scenario_2)\nrun!(b)\nrd = ResultData(b)\n\ngemsplot(rd, type = (:DetectedCases, :CumulativeIsolations))","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Plot","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_intreventions_recurrent_tests.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"The results show that the overall case numbers are similar in both scenarios. The extensive testing can lower the person-days spent in isolation as not all individuals will stay in isolation for the full 10 days. However, as all positive tests lead to a reported new case, we observe a substantial number of double reports (green area in the \"Detected Cases\"-plot). The testing measure only tests an individual for a pathogen but cannot differentiate whether it is the same infection or not. It is possible to specify that a test should not lead to a new case being reported. Please look up the Test measure's parameterization options. The next tutorial considers two test types where one of them does not lead to a reported case (self-applied test).","category":"page"},{"location":"tut_npi/#Multiple-Test-Types","page":"9 - Modeling Interventions","title":"Multiple Test Types","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Tutorial coming soon ...","category":"page"},{"location":"tut_npi/#Contact-Reduction","page":"9 - Modeling Interventions","title":"Contact Reduction","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Tutorial coming soon ...","category":"page"},{"location":"tut_npi/#Setting-Closure","page":"9 - Modeling Interventions","title":"Setting Closure","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Tutorial coming soon ...","category":"page"},{"location":"tut_npi/#Custom-Measures","page":"9 - Modeling Interventions","title":"Custom Measures","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Tutorial coming soon ...","category":"page"},{"location":"tut_npi/#Varying-Mandate-Adherence","page":"9 - Modeling Interventions","title":"Varying Mandate Adherence","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Tutorial coming soon ...","category":"page"},{"location":"tut_npi/#Adapting-Behavior","page":"9 - Modeling Interventions","title":"Adapting Behavior","text":"","category":"section"},{"location":"tut_npi/","page":"9 - Modeling Interventions","title":"9 - Modeling Interventions","text":"Tutorial coming soon ...","category":"page"},{"location":"base-contacts/#Base-Contact-Model","page":"Contacts","title":"Base Contact Model","text":"","category":"section"},{"location":"base-contacts/","page":"Contacts","title":"Contacts","text":"GEMS is a discrete time simulation which means that time is explicitly modeled in timesteps (so-called ticks). A tick, in the default configuration, has the duration of one day. All contacts and the following infections that happen during one tick are calculated before incrementing to the next timestep. The figure below illustrates what the GEMS engine does during one timestep.","category":"page"},{"location":"base-contacts/","page":"Contacts","title":"Contacts","text":"<p align=\"center\">\n    <img src=\"../assets/base-contacts.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"base-contacts/","page":"Contacts","title":"Contacts","text":"We go through all active settings which are the ones that hold an infectious agent (explanation here). In each of the settings, we draw contacts just for the infected individuals as we are only interested in potentially infectious interactions. Contacts between two non-infectious individuals are not being simulated. The contacts for the individuals are drawn using the contact_sampling_method that was defined for the respective setting type. In the default model, contacts are drawn randomly from the list of setting members. After a contact was drawn, the pathogen's transmission_function will determine the probability of infection. In the default model, this is a fixed rate for each contact. However, a custom function can be used to reflect varying transmission probabilities based on agent characteristics (e.g., age or vaccinations). Please look up the tutorials on advanced parameterization to learn about the available options.","category":"page"},{"location":"api_interventions/#Interventions","page":"Interventions","title":"Interventions","text":"","category":"section"},{"location":"api_interventions/#Overview-Structs","page":"Interventions","title":"Overview Structs","text":"","category":"section"},{"location":"api_interventions/","page":"Interventions","title":"Interventions","text":"Pages   = [\"api_interventions.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_interventions/#Overview-Functions","page":"Interventions","title":"Overview Functions","text":"","category":"section"},{"location":"api_interventions/","page":"Interventions","title":"Interventions","text":"Pages   = [\"api_interventions.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_interventions/#Triggers","page":"Interventions","title":"Triggers","text":"","category":"section"},{"location":"api_interventions/#Structs","page":"Interventions","title":"Structs","text":"","category":"section"},{"location":"api_interventions/#GEMS.HospitalizationTrigger","page":"Interventions","title":"GEMS.HospitalizationTrigger","text":"HospitalizationTrigger <: ITrigger\n\nA struct defining an IStrategy that shall be fired upon an individual's admittance to hospital.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.ITickTrigger","page":"Interventions","title":"GEMS.ITickTrigger","text":"ITickTrigger <: TickTrigger\n\nA struct defining an IStrategy with timed execution for all individuals in the model. The switch_tick sets a threshold for the onset of strategy execution based on the current tick. The interval defines a reoccurence (optional). If no switch_tick is given, the  strategy will be fired in each tick. If only the interval is given, the strategy will be fired from tick 1 onwards in the specified interval.\n\nParameters\n\nstrategy::IStrategy: Strategy that will be triggered\nswitch_tick::Int16 = Int16(-1) (optional): Threshold for the strategy onset\ninterval::Int16 = Int16(-1) (optional): Trigger strategy in reoccuring intervals\n\nExamples\n\nITickTrigger(my_daily_testing_strategy)\n\nwill trigger my_daily_testing_strategy each tick for each individuals.\n\nITickTrigger(my_home_office_strategy, switch_tick = Int16(20), interval = Int16(7))\n\nwill trigger my_home_office_strategy from tick 20 in a 7-tick interval for each individuals.\n\nITickTrigger(my_lockdown_strategy, switch_tick = Int16(50)\n\nwill trigger the my_lockdown_strategy once on tick 50.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.STickTrigger","page":"Interventions","title":"GEMS.STickTrigger","text":"STickTrigger <: TickTrigger\n\nA struct defining an SStrategy with timed execution for all settings of a specified settingtype in the model. The switch_tick sets a threshold for the onset of strategy execution based on the current tick. The interval defines a reoccurence (optional). If no switch_tick is given, the  strategy will be fired in each tick. If only the interval is given, the strategy will be fired from tick 1 onwards in the specified interval.\n\nParameters\n\nsettingtype::DataType: Type of settings (e.g. Household) that the triggered strategy will be applied to\nstrategy::SStrategy: Strategy that will be triggered\nswitch_tick::Int16 = Int16(-1) (optional): Threshold for the strategy onset\ninterval::Int16 = Int16(-1) (optional): Trigger strategy in reoccuring intervals\n\nExamples\n\nSTickTrigger(School, my_daily_testing_strategy)\n\nwill trigger my_daily_testing_strategy each tick for each school.\n\nSTickTrigger(Office, my_pool_testing_strategy, switch_tick = Int16(20), interval = Int16(7))\n\nwill trigger my_pool_testing_strategy from tick 20 in a 7-tick interval for each office.\n\nSTickTrigger(School, my_schhool_closure_strategy, switch_tick = Int16(50)\n\nwill trigger the my_schhool_closure_strategy once on tick 50 for all schools.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.SymptomTrigger","page":"Interventions","title":"GEMS.SymptomTrigger","text":"SymptomTrigger <: ITrigger\n\nA struct defining an IStrategy that shall be fired upon an individual experiencing symptoms.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#Functions","page":"Interventions","title":"Functions","text":"","category":"section"},{"location":"api_interventions/#GEMS.strategy","page":"Interventions","title":"GEMS.strategy","text":"strategy(trigger::SymptomTrigger)\n\nReturns the IStrategy object associated with a SymptomTrigger.\n\n\n\n\n\nstrategy(trigger::HospitalizationTrigger)\n\nReturns the IStrategy object associated with a HospitalizationTrigger.\n\n\n\n\n\nstrategy(trigger::TickTrigger)\n\nReturns the intervention strategy associated with a TickTrigger.\n\n\n\n\n\n","category":"function"},{"location":"api_interventions/#GEMS.switch_tick","page":"Interventions","title":"GEMS.switch_tick","text":"switch_tick(trigger::TickTrigger)\n\nReturns the switch_tick associated with a TickTrigger.\n\n\n\n\n\n","category":"function"},{"location":"api_interventions/#Strategies","page":"Interventions","title":"Strategies","text":"","category":"section"},{"location":"api_interventions/#Constructors","page":"Interventions","title":"Constructors","text":"","category":"section"},{"location":"api_interventions/#GEMS.IStrategy-Tuple{String, Simulation}","page":"Interventions","title":"GEMS.IStrategy","text":"IStrategy(name::String, sim::Simulation; condition::Function = x -> true)\n\nCreates an IStrategy object.\n\nParameters\n\nname::String: Name of the strategy\nsim::Simulation: Simulation object (required to interlink test with simulation)\ncondition::Function = x -> true (optional): Predicate function than can be used to limit the execution of this strategy to only cerain individuals.\n\nExamples\n\nmy_str = IStrategy(\"self-isolation\", sim)\nadd_measure!(my_str, SelfIsolation(14))\n\ns_trigger = SymptomTrigger(my_str)\nadd_symptom_trigger!(sim, s_trigger) \n\nThe above code will create a new strategy called, 'self-isolation'. Using the add_measure! function, you can now begin to populate your strategy with specific intervention measures, e.g. with a SelfIsolation measure. The second part creates a SymptomTrigger that will now fire your  strategy once an individual experiences symptoms.\n\nIf you want to limit the execution of your strategy to only certain individuals e.g. based on their age, you can do that be adding a condition predicate function, such as:\n\nmy_str = IStrategy(\"self-isolation\", sim, condition = i -> age(i) > 65)\nadd_measure!(my_str, SelfIsolation(14))\n\ns_trigger = SymptomTrigger(my_str)\nadd_symptom_trigger!(sim, s_trigger) \n\nThe added condition will cause the strategy only to be executed for individuals who experience symptoms and are 65 or older.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.SStrategy-Tuple{String, Simulation}","page":"Interventions","title":"GEMS.SStrategy","text":"SStrategy(name::String, sim::Simulation; condition::Function = x -> true)\n\nCreates an SStrategy object.\n\nParameters\n\nname::String: Name of the strategy\nsim::Simulation: Simulation object (required to interlink test with simulation)\ncondition::Function = x -> true (optional): Predicate function than can be used to limit the execution of this strategy to only cerain settings.\n\nExamples\n\nmy_str = SStrategy(\"close-offices\", sim)\nadd_measure!(my_str, CloseSetting())\n\nt_trigger = STickTrigger(Office, my_str, switch_tick = Int16(20))\nadd_tick_trigger!(sim, t_trigger)\n\nThe above code will create a new strategy called, 'close-offices'. Using the add_measure! function, you can now begin to populate your strategy with specific intervention measures, e.g. with a CloseSetting measure. The second part creates a STickTrigger for the setting type Office and the switch_tick 20. Therefore, this trigger will call your strategy for all settings of type Office at tick 20, closing them indefinitely.\n\nIf you want to limit the execution of your strategy to only certain settings e.g. based on their size, you can do that be adding a condition predicate function, such as:\n\nmy_str = SStrategy(\"close-offices\", sim, condition = s -> size(s) > 10)\nadd_measure!(my_str, CloseSetting())\n\nt_trigger = STickTrigger(Office, my_str, switch_tick = Int16(20))\nadd_tick_trigger!(sim, t_trigger)\n\nThe added condition will cause the strategy only to be executed for settings that have more than 10 individuals associated.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.MeasureEntry","page":"Interventions","title":"GEMS.MeasureEntry","text":"MeasureEntry{T <: Measure}\n\nThis struct represents a tuple of an intervention-measure, an integer-offset, a delay-function and a condition. It is the internal data structure for Strategies.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#Functions-2","page":"Interventions","title":"Functions","text":"","category":"section"},{"location":"api_interventions/#GEMS.add_measure!","page":"Interventions","title":"GEMS.add_measure!","text":"add_measure!(str::Strategy, measure::Measure; offset::Int64 = 0, delay::Function = x -> 0, condition::Function = x -> true)\n\nAdds IMeasures to IStrategys and SMeasures to SStrategys.\n\nParameters:\n\nstr::Strategy: Strategy that the measure will be added to\nmeasure::Measure: Measure that will be added to te strategy\noffset::Int64 = 0 (optional): The number of ticks between the time the measure was triggered and the time the measure will be executed.\ndelay::Function = x -> 0 (optional): Single-argument function that must resolve to an integer. The delay will extend the offset.\ncondition::Function = x -> true (optional): Predicate function conditioning the exeuction of a measure.\n\nExamples\n\nmy_str = IStrategy(\"self-isolation\", sim)\nadd_measure!(my_str, SelfIsolation(14), offset = 2)\n\ns_trigger = SymptomTrigger(my_str)\nadd_symptom_trigger!(sim, s_trigger) \n\nThe above code shows how a SelfIsolation measure, putting an individual in self-isolation for 14 days, is added to a custom IStrategy. The strategy is triggered once an individual experiences symptoms (SymptomTrigger). The offset argument, however, specifies that it takes another two ticks before the individual is put into self-isolation.\n\nmy_str = IStrategy(\"self-isolation\", sim)\nadd_measure!(my_str, SelfIsolation(14), delay = i -> age(i) > 65 ? 2 : 0)\n\nThis example starts the self-isolation measure with a delay of two ticks if the individual is above 65 and otherwise immediately.\n\nmy_str = IStrategy(\"self-isolation\", sim)\nadd_measure!(my_str, SelfIsolation(14), condition = i -> age(i) > 65)\n\nThis example only lets individuals go into self-isolation who are 65 and above. All these optional arguments and predicate functions can be combined. The calculated delay is added to the offset (if specified).\n\n\n\n\n\n","category":"function"},{"location":"api_interventions/#GEMS.condition","page":"Interventions","title":"GEMS.condition","text":"condition(me::MeasureEntry)\n\nReturns the condition function associated with a MeasureEntry.\n\n\n\n\n\ncondition(str::Strategy)\n\nReturns the condition function of a Strategy.\n\n\n\n\n\n","category":"function"},{"location":"api_interventions/#GEMS.delay-Tuple{MeasureEntry}","page":"Interventions","title":"GEMS.delay","text":"delay(me::MeasureEntry)\n\nReturns the delay function associated with a MeasureEntry.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.measure-Tuple{MeasureEntry}","page":"Interventions","title":"GEMS.measure","text":"measure(me::MeasureEntry)\n\nReturns the measure associated with a MeasureEntry.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.measures-Tuple{Strategy}","page":"Interventions","title":"GEMS.measures","text":"measures(str::Strategy)\n\nReturns the measures encapsulated in a Strategy; A vector of MeasureEntrys\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.name-Tuple{Strategy}","page":"Interventions","title":"GEMS.name","text":"name(str::Strategy)\n\nReturns the name of a Strategy.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.offset-Tuple{MeasureEntry}","page":"Interventions","title":"GEMS.offset","text":"offset(me::MeasureEntry)\n\nReturns the offset associated with a MeasureEntry.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#Measures","page":"Interventions","title":"Measures","text":"","category":"section"},{"location":"api_interventions/#Constructors-2","page":"Interventions","title":"Constructors","text":"","category":"section"},{"location":"api_interventions/#GEMS.CancelSelfIsolation","page":"Interventions","title":"GEMS.CancelSelfIsolation","text":"CancelSelfIsolation <: IMeasure\n\nIntervention struct to cancel an individual's (household isolation).\n\nExample\n\nmy_str = IStrategy(\"cancel-isolation\", sim)\nadd_measure!(my_str, CancelSelfIsolaton())\n\nThe above example creates an IStrategy called 'my_str' and adds an instance of the CancelSelfIsolation measure to the strategy.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.ChangeContactMethod","page":"Interventions","title":"GEMS.ChangeContactMethod","text":"ChangeContactMethod <: SMeasure\n\nIntervention struct to replace a setting's contact sampling method. Needs to be initialized with an argument of type ContactSamplingMethod.\n\nExample\n\n    my_str = SStrategy(\"reduce-contacts\", sim)\n    add_measure!(my_str, ChangeContactMethod(ContactparameterSampling(1)))\n\nThe above example creates an SStrategy called 'my_str' and adds an instance of the ChangeContactMethod measure that should change the contact sampling method to a ContactparameterSampling method with  1 contact per tick. We call this strategy 'reduce-contacts', of course assuming that the previous contact sampling methdod generated more contacts per tick (which of course depends on your particular initial configuration)\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.CloseSetting","page":"Interventions","title":"GEMS.CloseSetting","text":"CloseSetting <: SMeasure\n\nIntervention struct to close a setting, effectively preventing all contacts from happening during closure.\n\nExample\n\nmy_str = SStrategy(\"close-school\", sim)\nadd_measure!(my_str, CloseSetting())\n\nThe above example creates an SStrategy called 'my_str' and adds an instance of the CloseSetting measure which will close the respective setting once called. You can, for example, use an STickTrigger to close all schools at a given simulation time. The following code would close all schools at tick 20:\n\nstt = STickTrigger(SchoolClass, my_str, switch_tick = Int16(20))\nadd_tick_trigger!(sim, stt)\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.CustomIMeasure","page":"Interventions","title":"GEMS.CustomIMeasure","text":"CustomIMeasure <: IMeasure\n\nIntervention struct to apply custom logic to an indivudal when this measure is executed. The field measure_logic must contain a two-argument function where the first argument is an Individual and the second argument is the Simulation struct. Upon execution of the measure, this function will be called with these two arguments.\n\nExample\n\nmy_str = IStrategy(\"change-risk-behavior\", sim)\nadd_measure!(my_str, CustomIMeasure((i, simobj) -> mandate_compliance!(i, .8)))\n\nThe above example creates an IStrategy called 'my_str' and adds an instance of the CustomIMeasure measure that is being instantiated with a function changing an individual's mandate_compliance attribute to 80%. This could, for example, be used to model changing risk perceptions over time. While the above example does not require the Simulation object, it is still being passed, to make the whole simulation state available at all times.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.CustomSMeasure","page":"Interventions","title":"GEMS.CustomSMeasure","text":"CustomSMeasure <: SMeasure\n\nIntervention struct to apply custom logic to a setting when this measure is executed. The field measure_logic must contain a two-argument function where the first argument is a Setting and the second argument is the Simulation struct. Upon execution of the measure, this function will be called with these two arguments.\n\nExample\n\nmy_str = SStrategy(\"close-large-settings\", sim)\nadd_measure!(my_str, CustomSMeasure((s, simobj) -> (size(s) > 50 ? close!(s) : nothing)))\n\nThe above example creates an SStrategy called 'my_str' and adds an instance of the CustomSMeasure measure that is being instantiated with a function closing the setting if it contains more than 50 individuals. While the above example does not require the Simulation object, it is still being passed, to make the whole simulation state available at all times. The example above contains conditioned logic to demonstrate how the CustomSMeasure works. You can, of course, achieve the same effect as in the example, if you use a regular CloseSetting measure and limit its execution to large settings by supplying the condition keyword to the add_measure! function.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.FindMembers","page":"Interventions","title":"GEMS.FindMembers","text":"FindMembers <: SMeasure\n\nIntervention struct to detect individuals that are associated with a setting and apply a follow-up strategy to the respective individuals. This  measure effecively allows to switch between SStrategy and IStrategy.\n\nOptional Arguments\n\nsample_size::Int64: Limiting the number of individuals to an integer maximum\nsample_fraction::Float64: Limiting the number of individuals to a fraction of the overall assigned members. Must be between (0-1)\nselectionfilter::Function: Filters individuals based on their characteristics\n\nExample\n\nisolate_str = IStrategy(\"self-isolation\", sim)\nadd_measure!(isolate_str, SelfIsolation(14))\n\nmy_str = SStrategy(\"find-coworkers\", sim)\nadd_measure!(my_str, FindMembers(isolate_str))\n\nThe above example first creates an individual strategy (IStrategy) called 'isolate_str' and adds an instance of the SelfIsolation measure which will send  the respective individual in self-isolation if excuted. It then creates an SStrategy called 'my_str' and adds an instance of the FindMembers measure that detects the setting's members and calls the previously defined 'isolate_str' on all of them. This mechanism can, for example, be used to send all individuals in self-isolation who are associated with a particular office (maybe beause a symptomatic case was detected).\n\nThe FindMembers struct can also be used to sample a subset of individuals from a setting. During the COVID-19 pandemic, many restaurants required a negative antigen test in  order to serve customers. From a modeling perspective, this is a case where the Test-measure is not triggered by surrounding infection dynamics, but rather randomly. The FindMembers measure can be used to represent these mechanics:\n\nFindMembers(my_follow_up_str, sample_size = 5)\n\nThe above measure will always apply the 'my_follow_up_str' to exactly 5 individuals sampled from the setting.\n\nFindMembers(my_follow_up_str, sample_fraction = 0.01)\n\nThis measure will apply the 'my_follow_up_str' to 1% of the members in the setting. It can be used to randomly  draw individuals, e.g., from a geographic region (Municipality).\n\nFindMembers(my_follow_up_str, selectionfilter = i -> age(i) >= 65)\n\nThis measure will apply the 'my_follow_up_str' only  to individuals of the setting who are 65 years or older. The filter is always applied before the sample_size or sample_fraction.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.FindSetting","page":"Interventions","title":"GEMS.FindSetting","text":"FindSetting <: IMeasure\n\nIntervention struct to detect a particular setting of an individual and apply follow-up strategy to the respective setting. This  measure effecively allows to switch between IStrategy and SStrategy. \n\nExample\n\nclose_str = SStrategy(\"close-office\", sim)\nadd_measure!(close_str, CloseSetting())\n\nmy_str = IStrategy(\"find-office\", sim)\nadd_measure!(my_str, FindSetting(Office, close_str))\n\ns_trigger = SymptomTrigger(my_str)\nadd_symptom_trigger!(sim, s_trigger) \n\nThe above example first creates a setting strategy (SStrategy) called 'close_str' and adds an instance of the CloseSetting measure which will close the respective setting indefinitely if excuted. It then creates an IStrategy called 'my_str' and adds an instance of the FindSetting measure that detects the individual's office setting and calls the previously defined 'close_str' on it. Lastly, a SymptomTrigger is defined to run this cascade of strategy once an individual experiences symptoms. The example will close the office an individual is associated with if it experiences symptoms.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.FindSettingMembers","page":"Interventions","title":"GEMS.FindSettingMembers","text":"FindSettingMembers <: IMeasure\n\nIntervention struct that returns members of a setting which is associated with an index-individual, e.g., 'People I know at work'. It requires a settingtype, defining which of the individual's settings shall be  quieried, as well as a follow_up IStrategy that will be applied to all found setting members. An optional nonself boolean flag indicates whether this measure shall also return the index individual. \n\nExamples\n\nmy_str = IStrategy(\"identify-household-members\", sim)\nadd_measure!(my_str, FindSettingMembers(Household, my_other_strategy, nonself = true))\n\nThe above example creates an IStrategy called 'my_str' and adds an instance of the FindSettingMembers measure that should return all household members except the index individual (all people that the individual lives with). It will trigger the follow-up strategy 'my_other_strategy' for all members.\n\nmy_str = IStrategy(\"identify-household-members\", sim)\nadd_measure!(my_str, FindSettingMembers(Office, my_other_strategy))\n\nThe above example creates an IStrategy called 'my_str' and adds an instance of the FindSettingMembers measure that should return all Office members including the index individual. It will trigger the follow-up strategy 'my_other_strategy' for everyone in that office.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.IsOpen","page":"Interventions","title":"GEMS.IsOpen","text":"IsOpen <: SMeasure\n\nIntervention struct to differentiate follow-up setting strategies for currently open or currently closed settings. You can pass a positive_followup- or a negative_followup stategy via the respective optional arguments.\n\nExample\n\nisolate_str = IStrategy(\"self-isolation\", sim)\nadd_measure!(isolate_str, SelfIsolation(14))\n\nfind_coworkers_str = SStrategy(\"find-coworkers\", sim)\nadd_measure!(find_coworkers_str, FindMembers(isolate_str))\n\nmy_str = SStrategy(\"is-open?\", sim)\nadd_measure!(my_str, IsOpen(positive_followup = find_coworkers_str)))\n\nThe above example first creates an individual strategy (IStrategy) called 'isolate_str' and adds an instance of the SelfIsolation measure which will send  the respective individual in self-isolation if excuted. It then creates an SStrategy called 'find_coworkers_str' and adds an instance of the FindMembers measure that detects the setting's members and calls the previously defined 'isolate_str' on all of them. We now only want to send all co-workers, if the setting is open (and thus might have induced infectious conctacts). Therefore, another SStrategy called 'my_str' is instantiated and an instance of the IsOpen measure is added with the 'find_coworkers_str' strategy being the positive follow-up.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.OpenSetting","page":"Interventions","title":"GEMS.OpenSetting","text":"OpenSetting <: SMeasure\n\nIntervention struct to open a setting, effectively re-enabling the setting and allow contacts.\n\nExample\n\nmy_str = SStrategy(\"reopen-school\", sim)\nadd_measure!(my_str, OpenSetting())\n\nThe above example creates an SStrategy called 'my_str' and adds an instance of the OpenSetting measure which will open the respective setting once called. You can, for example, use an STickTrigger to reopen all schools at a given simulation time (after they were closed earlier). The following code would open all schools at tick 20:\n\nstt = STickTrigger(SchoolClass, my_str, switch_tick = Int16(20))\nadd_tick_trigger!(sim, stt)\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.PoolTest","page":"Interventions","title":"GEMS.PoolTest","text":"PoolTest <: SMeasure\n\nIntervention struct to apply a pathogen pool test to all individuals in a specified setting. Instantiate a PoolTest measure with a name and a type. A PoolTest will return a positive result if at least one of the individuals present at a given setting is infected. The name will determine the labeling of the test series in the logger and can be chosen arbitrarily. The type must be a TestType object that you need to define beforehand. It contains information, e.g., about the sensitivity and specificity of the respective test type.\n\nThe PoolTest measure is different from the TestAll measure as the former just uses one test to evaluate whether any of the individuals is infected and the latter applies a separate test to all individuals.\n\nOptional Arguments\n\npositive_followup::SStrategy: What to do with the setting if the test is positive\nnegative_followup::SStrategy: What to do with the setting if the test is negative\n\nExample\n\npcr_test = TestType(\"PCR Test\", pathogen(sim), sim)\n\nmy_str = SStrategy(\"school-pool-test\", sim)\nadd_measure!(my_str, PoolTest(\"pool-test\", pcr_test, positive_followup = my_close_school_str))\n\nThe above example first instantiates a TestType for the pathogen  registered in the Simulation object, creates an SStrategy called 'my_str' and adds an instance of the PoolTest measure to the strategy. The PoolTest measure has a follow-up strategy called 'my_close_school_str' in case the test result is positive. A follow-up strategy could, for example, be a school-closure strategy. While the above example does not have a follow-up strategy for a negative test, you can ofcouse have both.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.SelfIsolation","page":"Interventions","title":"GEMS.SelfIsolation","text":"SelfIsolation <: IMeasure\n\nIntervention struct to put an individual into self-isolation (household isolation) for the time (in ticks) specified in duration\n\nExample\n\nmy_str = IStrategy(\"self-isolation\", sim)\nadd_measure!(my_str, SelfIsolation(14))\n\nThe above example creates an IStrategy called 'my_str' and adds an instance of the SelfIsolation measure that should last for 14 days to the strategy.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.Test","page":"Interventions","title":"GEMS.Test","text":"Test <: IMeasure\n\nIntervention struct to apply a pathogen test to an individual. Instantiate a Test measure with a name and a type. The name will determine the labeling of the test series in the logger and can be chosen arbitrarily. The type must be a TestType object that you need to define beforehand. It contains information, e.g., about the sensitivity and specificity of the respective test type. Tests are generally separated into 'reportable' tests that contribute to the statistics of 'detected cases' or non-'reportable' which might still change an individual's behavior (such as a rapid-self-test at home) but will not be reported to the authorities.\n\nOptional Arguments\n\npositive_followup::IStrategy: What to do with the individual if the test is positive\nnegative_followup::IStrategy: What to do with the individual if the test is negative\nreportable::Bool: Whether a positive result should contribute to the statistics of 'detected cases'. The default is true.\n\nExample\n\nantigen_test = TestType(\"Antigen Test\", pathogen(sim), sim)\n\nmy_str = IStrategy(\"self-test\", sim)\nadd_measure!(my_str, Test(\"self-test\", antigen_test, positive_followup = my_other_strategy))\n\nThe above example first instantiates a TestType for the pathogen  registered in the Simulation object, creates an IStrategy called 'my_str' and adds an instance of the Test measure to the strategy. The Test measure has a follow-up strategy called 'my_other_strategy' in case the test result is positive. A follow-up strategy could, for example, be a self-isolation strategy. While the above example does not have a follow-up strategy for a negative test, you can of couse have both.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.TestAll","page":"Interventions","title":"GEMS.TestAll","text":"TestAll <: SMeasure\n\nIntervention struct to apply a pathogen test to each individual in a specified setting. Instantiate a TestAll measure with a name and a type. A TestAll will return a positive result if at least one of the individuals present at a given setting has a positive test result. However, the logger will contain test results for each of the individuals. The name will determine the labeling of the test series in the logger and can be chosen arbitrarily. The type must be a TestType object that you need to define beforehand. It contains information, e.g., about the sensitivity and specificity of the respective test type.\n\nThe TestAll measure is different from the PoolTest measure as the latter just uses one test to evaluate whether any of the individuals is infected and the former applies a separate test to all individuals.\n\nOptional Arguments\n\npositive_followup::SStrategy: What to do with the setting if the test is positive\nnegative_followup::SStrategy: What to do with the setting if the test is negative\nreportable::Bool: Whether a positive result should contribute to the statistics of 'detected cases'. The default is true.\n\nExample\n\npcr_test = TestType(\"PCR Test\", pathogen(sim), sim)\n\nmy_str = SStrategy(\"test-household-members\", sim)\nadd_measure!(my_str, TestAll(\"pcr-test\", pcr_test, positive_followup = my_isolate_household_str))\n\nThe above example first instantiates a TestType for the pathogen  registered in the Simulation object, creates an SStrategy called 'my_str' and adds an instance of the PoolTest measure to the strategy. The PoolTest measure has a follow-up strategy called 'my_isolate_household_str' in case the test result is positive. A follow-up strategy could, for example, be a hosuehold-isolation strategy. While the above example does not have a follow-up strategy for a negative test, you can of couse have both.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.TestType","page":"Interventions","title":"GEMS.TestType","text":"TestType <: AbstractTestType\n\nA type to specify a type of pathogen test (e.g. 'PCR Test') and its parameterization.\n\nFields\n\nname::String: Name of the test (e.g. 'Rapid Test' or 'PCR Test')\npathogen::Pathogen: Pathogen that this test will detect\nsensitivity::Float64 = 1.0: Probability (0-1) that this test will positively identify an infection (true positive rate) \nspecificity::Float64 = 1.0: Probability (0-1) that this test will negatively identify a non-infection (true negative rate)\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.TraceInfectiousContacts","page":"Interventions","title":"GEMS.TraceInfectiousContacts","text":"TraceInfectiousContacts <: IMeasure\n\nIntervention struct to trace individuals that have been  infected by the index individual, this measure is called with. The follow_up argument provides an IStrategy that is being exceuted for all detected contacts. The optional success_rate (0-1) argument can be used to model sub-perfect tracing (the default is 100%).\n\nExample\n\nmy_str = IStrategy(\"contact-tracing\", sim)\nadd_measure!(my_str, TraceInfectiousContacts(my_other_str, success_rate = 0.5))\n\nThe above example creates an IStrategy called 'my_str' and adds an instance of the TraceInfectiousContacts measure that will trigger the 'my_other_str' for all detected infections. The success_rate is 50%.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#Functions-3","page":"Interventions","title":"Functions","text":"","category":"section"},{"location":"api_interventions/#GEMS.apply_pool_test","page":"Interventions","title":"GEMS.apply_pool_test","text":"apply_pool_test(setting::Setting, testtype::TestType, sim::Simulation; subset::Union{Vector{Individual}, Nothing} = nothing)\n\nSubjects a collection of individuals to a pool test of the specified TestType and logs the result in the simulation's  PoolTestLogger. Returns a boolean; true if test was positive (at least one infected individual) and false otherwise. Note that this fuction might return false positives and false negatives, depending on the TestType parameterization. If no subset of individuals (as a vector) is provided, this function will take all individuals assigned to the specified setting.\n\nParameters\n\nsetting::Setting: Setting that is being pool-tested\ntesttype::TestType: type of test that will be used (e.g. 'PCR'; needs to be defined as TestType beforehand)\nsim::Simulation: Simulation object\nsubset::Union{Vector{Individual}, Nothing} = nothing (optional): Provide a subset of individuals to apply the pool test to\n\nReturns\n\nBool: Test result (Note: Pay attention to test sensitivity and specificity of the respective TestType as this   might lead to false negatives or false positives)\n\n\n\n\n\n","category":"function"},{"location":"api_interventions/#GEMS.apply_test","page":"Interventions","title":"GEMS.apply_test","text":"apply_test(ind::Individual, testtype::TestType, sim::Simulation, reportable::Bool)\n\nSubjects the individual to a test of the specified TestType and logs the result in the simulation's  TestLogger. Returns a boolean; true if test was positive and false otherwise. Note that this fuction might return false positives and false negatives, depending on the TestType parameterization. If the reportable attribute is true, a positive test will lead to the detection of a previously undetected individual.\n\nParameters\n\nind::Individual: Individual to be tested\ntesttype::TestType: type of test that will be used (e.g. 'PCR'; needs to be defined as TestType beforehand)\nsim::Simulation: Simulation object\nreportable::Bool: If true, a positive test result will be 'reported'\n\nReturns\n\nBool: Test result (Note: Pay attention to test sensitivity and specificity of the respective TestType as this   might lead to false negatives or false positives)\n\n\n\n\n\n","category":"function"},{"location":"api_interventions/#GEMS.duration-Tuple{SelfIsolation}","page":"Interventions","title":"GEMS.duration","text":"duration(si::SelfIsolation)\n\nReturns the duration attribute from a SelfIsolation struct. \n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.follow_up","page":"Interventions","title":"GEMS.follow_up","text":"follow_up(h::Handover)\n\nReturns the follow-up strategy  associated with a Handover struct.\n\n\n\n\n\nfollow_up(fs::FindSetting)\n\nReturns the follow_up strategy attribute from a FindSetting struct. \n\n\n\n\n\nfollow_up(fsm::FindSettingMembers)\n\nReturns the follow_up strategy attribute from a FindSettingMembers struct. \n\n\n\n\n\nfollow_up(tic::TraceInfectiousContacts)\n\nReturns the follow_up strategy attribute from a TraceInfectiousContacts struct. \n\n\n\n\n\nfollow_up(fs::FindMembers)\n\nReturns the follow_up strategy attribute of a FindMembers measure struct.\n\n\n\n\n\n","category":"function"},{"location":"api_interventions/#GEMS.i_measuretypes","page":"Interventions","title":"GEMS.i_measuretypes","text":"i_measuretypes()\n\nReturns a list of all IMeasure types available.\n\n\n\n\n\n","category":"function"},{"location":"api_interventions/#GEMS.measure_logic","page":"Interventions","title":"GEMS.measure_logic","text":"measure_logic(measure::CustomIMeasure)\n\nReturns the measure_logic (function) attribute from a CustomIMeasure struct. \n\n\n\n\n\nmeasure_logic(measure::CustomSMeasure)\n\nReturns the measure_logic (function) attribute from a CustomSMeasure struct. \n\n\n\n\n\n","category":"function"},{"location":"api_interventions/#GEMS.name-Tuple{PoolTest}","page":"Interventions","title":"GEMS.name","text":"name(t::PoolTest)\n\nReturns the name of a test-series from a PoolTest measure struct.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.name-Tuple{TestAll}","page":"Interventions","title":"GEMS.name","text":"name(t::TestAll)\n\nReturns the name of a test-series from a TestAll measure struct.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.name-Tuple{TestType}","page":"Interventions","title":"GEMS.name","text":"name(tt::TestType)\n\nReturns the TestType's name.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.name-Tuple{Test}","page":"Interventions","title":"GEMS.name","text":"name(t::Test)\n\nReturns the name of a test-series from a Test measure struct.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.negative_followup","page":"Interventions","title":"GEMS.negative_followup","text":"negative_followup(t::Test)\n\nReturns the negative_followup strategy from a Test measure struct.\n\n\n\n\n\nnegative_followup(t::IsOpen)\n\nReturns the negative_followup strategy attribute of an IsOpen measure struct.\n\n\n\n\n\nnegative_followup(t::PoolTest)\n\nReturns the negative_followup strategy from a PoolTest measure struct.\n\n\n\n\n\nnegative_followup(t::TestAll)\n\nReturns the negative_followup strategy from a TestAll measure struct.\n\n\n\n\n\n","category":"function"},{"location":"api_interventions/#GEMS.nonself-Tuple{FindSettingMembers}","page":"Interventions","title":"GEMS.nonself","text":"nonself(fsm::FindSettingMembers)\n\nReturns the nonself strategy attribute from a FindSettingMembers struct. \n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.positive_followup","page":"Interventions","title":"GEMS.positive_followup","text":"positive_followup(t::Test)\n\nReturns the positive_followup strategy from a Test measure struct.\n\n\n\n\n\npositive_followup(t::IsOpen)\n\nReturns the positive_followup strategy attribute of an IsOpen measure struct.\n\n\n\n\n\npositive_followup(t::PoolTest)\n\nReturns the positive_followup strategy from a PoolTest measure struct.\n\n\n\n\n\npositive_followup(t::TestAll)\n\nReturns the positive_followup strategy from a TestAll measure struct.\n\n\n\n\n\n","category":"function"},{"location":"api_interventions/#GEMS.process_measure","page":"Interventions","title":"GEMS.process_measure","text":"Abstract wrapper function for intervention processing. Requires contrete subtype implementation\n\n\n\n\n\nAbstract wrapper function for intervention processing. Requires contrete subtype implementation\n\n\n\n\n\nprocess_measure(sim::Simulation, ind::Individual, cancel::CancelSelfIsolation)\n\nCancels an individuals self-isolation (household isolation) by setting the individual's quarantine_release_tick to 'now'.\n\nParameters\n\nsim::Simulation: Simulation object\nind::Individual: Individual that this measure will be applied to (focus individual)\ncancel::CancelSelfIsolation: Measure instance\n\n\n\n\n\nprocess_measure(sim::Simulation, ind::Individual, custom::CustomIMeasure)\n\nApplies a custom logic to the individual as specified in the CustomIMeasure's measure_logic field.\n\nParameters\n\nsim::Simulation: Simulation object\nind::Individual: Individual that this measure will be applied to (focus individual)\ncustom::CustomIMeasure: Measure instance\n\n\n\n\n\nprocess_measure(sim::Simulation, ind::Individual, measure::FindSetting)\n\nDetects a particular setting (specified by the FindSetting measure's settingtype attribute) for an individual and hands over a follow_up strategy for the respective setting object.\n\nParameters\n\nsim::Simulation: Simulation object\nind::Individual: Individual that this measure will be applied to (focus individual)\nmeasure::FindSetting: Measure instance\n\nReturns\n\nHandover: Struct that contains the detected setting and the   followup SStrategy defined in the input FindSetting measure.\n\n\n\n\n\nprocess_measure(sim::Simulation, ind::Individual, measure::FindSettingMembers)\n\nFinds all members of one of the settings an individual is associated with. the measure's  field settingtype specifies which kind of setting shall be queried, the nonself  boolean flag indicates whether the index individual shall be among the returning members. The follow_up strategy is handed over to all found members (and enqueued in the EventQueue in a subsequent step)\n\nParameters\n\nsim::Simulation: Simulation object\nind::Individual: Individual that this measure will be applied to (focus individual)\nmeasure::FindSettingMembers: Measure instance\n\nReturns\n\nHandover: Struct that contains the list of detected setting members and the   followup IStrategy defined in the input FindSettingMemers measure.\n\n\n\n\n\nprocess_measure(sim::Simulation, ind::Individual, isolation::SelfIsolation)\n\nPuts an individual into self-isolation (household isolation) for the time (in ticks) specified in the SelfIsolation's duration attribute.\n\nParameters\n\nsim::Simulation: Simulation object\nind::Individual: Individual that this measure will be applied to (focus individual)\nisolation::SelfIsolation: Measure instance\n\n\n\n\n\nprocess_measure(sim::Simulation, ind::Individual, test::Test)\n\nApply a test of TestType (as specified in the Test measure) to an individual. The test will automatically be logged in the Simulation's internal loggers. If a follow-up strategy is set (for either positive or negative results), the  follow-up strategy is handed over to the EventQueue for this individual.\n\nParameters\n\nsim::Simulation: Simulation object\nind::Individual: Individual that this measure will be applied to (focus individual)\ntest::Test: Measure instance\n\nReturns\n\nHandover: Struct that contains the focus individual (ind) and the respective    followup IStrategy defined in the input Test measure depending   on whether the test returned a positive or negative result.\n\n\n\n\n\nprocess_measure(sim::Simulation, ind::Individual, measure::TraceInfectiousContacts)\n\nDetects individuals that have been infected by the index individual. The TraceInfectiousContacts measure's success_rate argument can be used to model sub-perfect tracing (the default is 100%). The follow_up strategy of the TraceInfectiousContacts measure is handed over to all detected contacts.\n\nParameters\n\nsim::Simulation: Simulation object\nind::Individual: Individual that this measure will be applied to (focus individual)\nmeasure::TraceInfectiousContacts: Measure instance\n\nReturns\n\nHandover: Struct that contains the list of detected infectious individuals and the   followup IStrategy defined in the input TraceInfectiousContacts measure.\n\n\n\n\n\nprocess_measure(sim::Simulation, s::Setting, measure::ChangeContactMethod)\n\nReplaces the contact sampling method in the setting that was passed with a new sampling method specified in the ChangeContactMethod measure.\n\nParameters\n\nsim::Simulation: Simulation object\ns::Setting: Setting that this measure will be applied to (focus setting)\nmeasure::ChangeContactMethod: Measure instance\n\n\n\n\n\nprocess_measure(sim::Simulation, s::Setting, close::CloseSetting)\n\nCloses the passed setting s indefinitely, effectively preventing all contacts.\n\nParameters\n\nsim::Simulation: Simulation object\ns::Setting: Setting that this measure will be applied to (focus setting)\nclose::CloseSetting: Measure instance\n\n\n\n\n\nprocess_measure(sim::Simulation, s::Setting, custom::CustomSMeasure)\n\nApplies a custom logic to the setting as specified in the CustomSMeasure's measure_logic field.\n\nParameters\n\nsim::Simulation: Simulation object\ns::Setting: Setting that this measure will be applied to (focus setting)\ncustom::CustomSMeasure: Measure instance\n\n\n\n\n\nprocess_measure(sim::Simulation, s::Setting, measure::FindMembers)\n\nReturns the individuals (members) associated with setting s and hands over the  follow_up strategy as specified in the FindMembers measure. The sample_size, sample_fraction, and selectionfilter attributes of the FindMembers measure can be used to condition or limit the results.\n\nParameters\n\nsim::Simulation: Simulation object\ns::Setting: Setting that this measure will be applied to (focus setting)\nmeasure::FindMembers: Measure instance\n\nReturns\n\nHandover: Struct that contains the list of setting members and the   followup IStrategy defined in the input FindMembers measure.\n\n\n\n\n\nprocess_measure(sim::Simulation, s::Setting, measure::IsOpen)\n\nEvaluates whether the setting s is currently open and hands over the respective follow-up strategies as specified in the IsOpen measure.\n\nParameters\n\nsim::Simulation: Simulation object\ns::Setting: Setting that this measure will be applied to (focus setting)\nmeasure::IsOpen: Measure instance\n\nReturns\n\nHandover: Struct that contains the focus setting (s) and the respective    followup SStrategy defined in the input IsOpen measure depending   on whether the setting is open or closed.\n\n\n\n\n\nprocess_measure(sim::Simulation, s::Setting, close::OpenSetting)\n\n(Re-)Opens the passed setting s indefinitely, again allowing contacts to happen.\n\nParameters\n\nsim::Simulation: Simulation object\ns::Setting: Setting that this measure will be applied to (focus setting)\nclose::OpenSetting: Measure instance\n\n\n\n\n\nprocess_measure(sim::Simulation, s::Setting, measure::PoolTest)\n\nApply a test of TestType (as specified in the PoolTest measure) to a setting. The test will automatically be logged in the Simulation's internal loggers. If a follow-up strategy is set (for either positive or negative results), the  follow-up strategy is handed over to the EventQueue for this setting.\n\nParameters\n\nsim::Simulation: Simulation object\ns::Setting: Setting that this measure will be applied to (focus setting)\nmeasure::PoolTest: Measure instance\n\nReturns\n\nHandover: Struct that contains the focus setting (s) and the respective    followup SStrategy defined in the input PoolTest measure depending   on whether the test returned a positive or negative result.\n\n\n\n\n\nprocess_measure(sim::Simulation, s::Setting, measure::TestAll)\n\nApply a test of TestType (as specified in the TestAll measure) to each individual of a setting. The test results will automatically be logged in the Simulation's internal loggers. If a follow-up strategy is set (for either positive or negative results), the  follow-up strategy is handed over to the EventQueue for this setting.\n\nParameters\n\nsim::Simulation: Simulation object\ns::Setting: Setting that this measure will be applied to (focus setting)\nmeasure::TestAll: Measure instance\n\nReturns\n\nHandover: Struct that contains the focus setting (s) and the respective    followup SStrategy defined in the input TestAll measure depending   on whether the test returned a at least one positive or all negative result.\n\n\n\n\n\n","category":"function"},{"location":"api_interventions/#GEMS.reportable-Tuple{Test}","page":"Interventions","title":"GEMS.reportable","text":"reportable(t::Test)\n\nReturns the reportable boolean flag from a Test measure struct.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.reportable-Tuple{TestAll}","page":"Interventions","title":"GEMS.reportable","text":"reportable(t::TestAll)\n\nReturns the reportable boolean flag from a TestAll measure struct.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.s_measuretypes","page":"Interventions","title":"GEMS.s_measuretypes","text":"s_measuretypes()\n\nReturns a list of all SMeasure types available.\n\n\n\n\n\n","category":"function"},{"location":"api_interventions/#GEMS.sample_fraction-Tuple{FindMembers}","page":"Interventions","title":"GEMS.sample_fraction","text":"sample_fraction(fs::FindMembers)\n\nReturns the sample_fraction attribute of a FindMembers measure struct.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.sample_size-Tuple{FindMembers}","page":"Interventions","title":"GEMS.sample_size","text":"sample_size(fs::FindMembers)\n\nReturns the sample_size attribute of a FindMembers measure struct.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.sampling_method-Tuple{ChangeContactMethod}","page":"Interventions","title":"GEMS.sampling_method","text":"sampling_method(measure::ChangeContactMethod)\n\nReturns the sampling_method attribute from a ChangeContactMethod struct. \n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.selectionfilter-Tuple{FindMembers}","page":"Interventions","title":"GEMS.selectionfilter","text":"selectionfilter(fs::FindMembers)\n\nReturns the selectionfilter attribute of a FindMembers measure struct.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.sensitivity-Tuple{TestType}","page":"Interventions","title":"GEMS.sensitivity","text":"sensitivity(tt::TestType)\n\nReturns the TestType's sensitivity.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.specificity-Tuple{TestType}","page":"Interventions","title":"GEMS.specificity","text":"specificity(tt::TestType)\n\nReturns the TestType's specificity.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.success_rate-Tuple{TraceInfectiousContacts}","page":"Interventions","title":"GEMS.success_rate","text":"success_rate(tic::TraceInfectiousContacts)\n\nReturns the success_rate attribute from a TraceInfectiousContacts struct. \n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.type","page":"Interventions","title":"GEMS.type","text":"type(t::Test)\n\nReturns the test type from a Test measure struct.\n\n\n\n\n\ntype(t::PoolTest)\n\nReturns the test type from a PoolTest measure struct.\n\n\n\n\n\ntype(t::TestAll)\n\nReturns the test type from a TestAll measure struct.\n\n\n\n\n\n","category":"function"},{"location":"api_interventions/#Event-Handling","page":"Interventions","title":"Event Handling","text":"","category":"section"},{"location":"api_interventions/#Constructors-3","page":"Interventions","title":"Constructors","text":"","category":"section"},{"location":"api_interventions/#GEMS.EventQueue","page":"Interventions","title":"GEMS.EventQueue","text":"EventQueue\n\nData structure to store intervention events.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.Handover","page":"Interventions","title":"GEMS.Handover","text":"Handover\n\nThe Handover struct provides a standard data structure for handling outputs of the process_measure() functions. It is being used to pass follow-up strategies to focal objects that are being determined within the process_measure() functions. The Handovers organize how follow-up strategies are passed to the event queue. There is no application for Handovers outside of process_measure() functions.\n\nFields\n\nfocal_objects::Union{Vector{<:Individual},Vector{<:Setting}}:   List of focal objects (either all Individuals or all Settings)\nfollow_up::Union{<:Strategy, Nothing}: Strategy that shall be   triggered for all focus objects in the focal_objects list\n\nExamples\n\nThe code below defines how a Test measure shall be processed. First, the passed individual ind is being tested. The function then returns a new Handover with the focus object (the individual) and the either positive- or negative-follow-up stategy that are defined in the Test measure. \n\nfunction process_measure(sim::Simulation, ind::Individual, test::Test)\n    test_pos = apply_test(ind, test |> type, sim, test |> reportable)\n    return Handover(ind, test_pos ? test |> positive_followup : test |> negative_followup)\nend\n\nThe handovers can be instantiated with single focal objects (Individuals or Settings) as well as vectors of focal objects (Vector{Individual} or Vector{Setting}). It's also possible to instantiate a Handover with nothing as the follow_up strategy which is sometimmes helpful if you don't know whether there will be a  subsequent strategy or not.\n\nHere are some more examples on how to instantiate Handovers:\n\ni1 = Indiviual(...)\ni2 = Indiviual(...)\ns = Household(...)\nistr = IStrategy(\"my_istr\", sim)\nsstr = SStrategy(\"my_sstr\", sim)\n\nh1 = Handover(i1, istr)\nh2 = Handover([i1, i2], istr)\nh3 = Handover(s, nothing)\nh4 = Handover([s], sstr)\n\nNote: Naturally, A Handover must either have all Individuals and an IStrategy or  all Settingss and an SStrategy.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.IMeasureEvent","page":"Interventions","title":"GEMS.IMeasureEvent","text":"IMeasureEvent <: Event\n\nStruct associate a specific Individual with a specific IMeasure which is stored in the intervention event queue.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#GEMS.SMeasureEvent","page":"Interventions","title":"GEMS.SMeasureEvent","text":"SMeasureEvent <: Event\n\nStruct associate a specific Setting with a specific SMeasure which is stored in the intervention event queue.\n\n\n\n\n\n","category":"type"},{"location":"api_interventions/#Functions-4","page":"Interventions","title":"Functions","text":"","category":"section"},{"location":"api_interventions/#GEMS.dequeue!-Tuple{EventQueue}","page":"Interventions","title":"GEMS.dequeue!","text":"dequeue!(queue::EventQueue)\n\nRemoves and returns the first Event of the EventQueue.\n\n\n\n\n\n","category":"method"},{"location":"api_interventions/#GEMS.enqueue!-Tuple{EventQueue, Event, Int16}","page":"Interventions","title":"GEMS.enqueue!","text":"enqueue!(queue::EventQueue, event::Event, tick::Int16)\n\nAdds a new Event to the EventQueue at the specified tick.\n\n\n\n\n\n","category":"method"},{"location":"tut_advanced/#10-Advanced-Simulations","page":"10 - Advanced Simulations","title":"10 - Advanced Simulations","text":"","category":"section"},{"location":"tut_advanced/","page":"10 - Advanced Simulations","title":"10 - Advanced Simulations","text":"tbd","category":"page"},{"location":"tut_movie/#9-Infection-Dynamics","page":"9 - Infection Dynamics","title":"9 - Infection Dynamics","text":"","category":"section"},{"location":"tut_movie/","page":"9 - Infection Dynamics","title":"9 - Infection Dynamics","text":"movie","category":"page"},{"location":"tut_customs/#7-Customization","page":"7 - Customization","title":"7 - Customization","text":"","category":"section"},{"location":"tut_customs/","page":"7 - Customization","title":"7 - Customization","text":"customization creating customized reports & plots","category":"page"},{"location":"tut_plotting/#3-Plotting","page":"3 - Plotting","title":"3 - Plotting","text":"","category":"section"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"GEMS offers a large variety of plotting options, mainly built upon the Plots.jl package.","category":"page"},{"location":"tut_plotting/#Plotting-Results","page":"3 - Plotting","title":"Plotting Results","text":"","category":"section"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"The powerful gemsplot() function is the central element of GEMS' output visualization options. It requires a ResultData object that was generated from a finished simulation and can be parameterized in many ways. By passing the type argument, you can select from a large range of graphs. Run plottypes() to see the list of available types.","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"using GEMS\nsim = Simulation()\nrun!(sim)\nrd = ResultData(sim)\ngemsplot(rd, type = :CumulativeCases)","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Plot","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_plotting_CumulativeCases.png\" width=\"60%\"/>\n</p>","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"info: Where do I find an explanation available plot types?\nPut a ? into the Julia REPL and call help?> gemsplot to get an overview of graphs you can generate using the gemsplot function or look up the Plotting section of the API documentation.","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Additonally, it is possible to pass multiple types as a tuple to make them appear in the same plot:","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"gemsplot(rd, type = (:CumulativeCases, :EffectiveReproduction))","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Plot","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_plotting_CumulativeCases-EffectiveReproduction.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Finally, you can customize your plot with the keyword arguments that are available to the Plots.jl package. In this example, we want to see the cumulative infections for the first 100 days and remove the legend:","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"gemsplot(rd, type = :CumulativeCases, xlims = (0, 100), legend = false)","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Plot","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_plotting_CumulativeCases-no-legend.png\" width=\"60%\"/>\n</p>","category":"page"},{"location":"tut_plotting/#Custom-Plots","page":"3 - Plotting","title":"Custom Plots","text":"","category":"section"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"If there is a plot that is not readily available via gemsplot(), it's always possible to create your own plot (using the Plots.jl package), e.g., to visualize properties of the Simulation object, rather than the ResultData object. This example plots a histogram of the total age distribution:","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"using GEMS, Plots\nsim = Simulation()\ninds = individuals(sim)\nages = age.(inds)\nhistogram(ages, xlabel = \"Age\", ylabel = \"Number of Individuals\", label = \"Individuals per Age\")","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Plot","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_plotting_histogram.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_plotting/#Plotting-Maps","page":"3 - Plotting","title":"Plotting Maps","text":"","category":"section"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"If you are working with a geo-referential model (e.g., by loading one of the inbuilt models of a German federal state), you can plot geographical maps of your simulation using the gemsmap() function. The type keyword provides various data options (and needs to be passed as there is no default). Run maptypes() to see the list of available types.","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"If you try to plot any gemsmap for the first time, it will trigger the download of a required shapefile.","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"using GEMS\nsim = Simulation(population = \"MV\")\ngemsmap(sim, type = :PopDensityMap, clims = (0, 100))","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Plot","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_plotting_gemsmap.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"info: Where do I find an explanation available map types?\nPut a ? into the Julia REPL and call help?> gemsmap to get an overview of maps you can generate using the gemsmap() function or look up the Mapping section of the API documentation.","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Many maps are available on varying geographical resolutions (state (1)-, county (2)-, or municipality (3)-level). You can pass the level argument to trigger the aggregation for many maps. Here's an example to get the average age of people per county:","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"gemsmap(sim, type = :AgeMap, level = 2)","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Plot","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_plotting_gemsmap-level2.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_plotting/#Custom-Maps","page":"3 - Plotting","title":"Custom Maps","text":"","category":"section"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"You can also generate custom maps by passing a dataframe to the agsmap() function. This dataframe requires two columns with the first column being a (unique) vector of community identification numbers (AGS) and the second column being a vector of numerical values. The code below loads the inbuilt model of Mecklenburg-Vorpommern (MV) and extracts all households from the model. It then creates a dataframe that stores the households' AGS and size attributes. As the dataframe requires a unique vector of community identification numbers, we group the dataframe by the ags column and calculate the mean for each group. Lastly, the map is being printed:","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"using GEMS, DataFrames, Statistics\nsim = Simulation(population = \"MV\")\nhhlds = households(sim)\n\n# prepare dataframe\ndf = DataFrame(ags = ags.(hhlds), size = size.(hhlds))\ngrouped_df = groupby(df, :ags)\ncombined_df = combine(grouped_df, :size => mean => :avg_size)\n\n# print map\nagsmap(combined_df)","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Plot","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_plotting_agsmap.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"The agsmap function infers the geographical level (municipality, county or state) from the input data. If you want to show a map on any higher-order geographical resolution, you need to transform the input data slightly:","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"using GEMS, DataFrames, Statistics\nsim = Simulation(population = \"MV\")\nhhlds = households(sim)\n\ndf = DataFrame(ags = ags.(hhlds), size = size.(hhlds))\ndf.ags = county.(df.ags) # get the \"county part\" of the community number (AGS)\ngrouped_df = groupby(df, :ags)\ncombined_df = combine(grouped_df, :size => mean => :avg_size)\n\n# print map\nagsmap(combined_df)","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Plot","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_plotting_agsmap2.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_plotting/#Combining-Plots","page":"3 - Plotting","title":"Combining Plots","text":"","category":"section"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Both gemsplots and gemsmaps are compatible with any plot from the Plots.jl package and can therefore be combined in subplots. Here's an example where we want to combine the age-histogram, the cumulative infections curve, and the population density map and the in the same plot:","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"using GEMS, Plots\nsim = Simulation(population = \"MV\")\ninds = individuals(sim)\nages = age.(inds)\n\nrun!(sim)\nrd = ResultData(sim)\n\n# pass as many plots to the \"plot\" functions as you want\nplot(\n    histogram(ages, xlabel = \"Age\", ylabel = \"Number of Individuals\", label = \"Individuals per Age\"),\n    gemsmap(sim, type = :PopDensityMap, clims = (0, 100)),\n    gemsplot(rd, type = :CumulativeCases, xlims = (0, 100)),\n    layout = (3, 1),\n    size = (400, 1000)\n)","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Plot","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_plotting_combined.png\" width=\"60%\"/>\n</p>","category":"page"},{"location":"tut_plotting/#Saving-Plots","page":"3 - Plotting","title":"Saving Plots","text":"","category":"section"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Use the Plots.jl package's png() function to save plots and maps to your harddrive:","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"using GEMS, Plots\nsim = Simulation()\nrun!(sim)\nrd = ResultData(sim)\ngp = gemsplot(rd, type = :CumulativeCases)\npng(gp, \"cumulative_cases.png\") # specify a path and filename","category":"page"},{"location":"tut_plotting/#Custom-Plot-Types","page":"3 - Plotting","title":"Custom Plot Types","text":"","category":"section"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"In the previous chapters you have seen, that you can pass a variety of types to the gemsplot() function. GEMS allows you to also define your own plot types that can then be used by the gemsplot() function.","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"As shown in the code below, you need to import the GEMS.generate function. Then, define a new keyworded struct of the name of your new type with three fields (title, description, and filename). Make it inherit from GEMS.SimulationPlot. Define a generate() function for your new plot type.  The generate() function actually generates the plot object from the ResultData object that was passed. In the example below, we want to have a simple time-series of total infections over time. Make sure that the generate() function actually returns a plot object. You can call plottypes() to verify that your new plot has been added. Now you can use :TotalInfections as a new type of a gemsplot.","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"using GEMS, Parameters, DataFrames, Plots\nimport GEMS.generate\n\n# This struct needs to be defined with the @with_kw macro\n# and have default values for \"title\", \"description\", and \"filename\" \n@with_kw mutable struct TotalInfections <: GEMS.SimulationPlot\n    title::String = \"Total Infections\"\n    description::String = \"This plot shows the total number of infections \n        throughout the span of the simulation.\" \n    filename::String = \"total_infections.png\"\nend\n\n# this function needs to take the new plot type, a ResultData object and optional plotargs...\nfunction GEMS.generate(plt::TotalInfections, rd::ResultData; plotargs...)\n    csum = rd |> tick_cases |>\n        x -> transform(x, :exposed_cnt => cumsum => :exposed_cumsum)\n\n    plot_cumsum = plot(xlabel=\"Ticks\", ylabel=\"Total Infections\")\n    plot!(plot_cumsum, csum[!,\"exposed_cumsum\"], label=\"Infections\")\n    plot!(plot_cumsum; plotargs...) # optional, but let's the user pass custom arguments such as \"xlims\", etc...\n    return(plot_cumsum)\nend\n\n# TESTING\nsim = Simulation()\nrun!(sim)\nrd = ResultData(sim)\ngp = gemsplot(rd, type = :TotalInfections)","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"Plot","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"<p align=\"center\">\n    <img src=\"../assets/tutorials/tut_plotting_custom.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"tut_plotting/","page":"3 - Plotting","title":"3 - Plotting","text":"You might have seen that the gemsplot() function can also work with multiple ResultData objects. If you want multiple simulation runs in one custom plot, you need to define a generate-function with this signature: generate(plt::YourNewType, rd::Vector{ResultData}; plotargs...). This function can exsist additionally to the single-ResultData implementation. It does not have to replace it. If no multi-ResultData generate-function is available for a particular type, calling gemsplot() with this type and multiple ResultData objects will cause the function to return a multi-plot with one subplot for each ResultData object.","category":"page"},{"location":"base-population/#Base-Population-Model","page":"Population","title":"Base Population Model","text":"","category":"section"},{"location":"base-population/","page":"Population","title":"Population","text":"GEMS is a discrete-time static individual-based model with a superimposed network structure. As such, all actions (contacts, infections, deaths, etc...) are being calculated for each timestep (e.g., a day) before incrementing to the next timestep.","category":"page"},{"location":"base-population/#Individuals-and-Settings","page":"Population","title":"Individuals and Settings","text":"","category":"section"},{"location":"base-population/","page":"Population","title":"Population","text":"The only two entities in GEMS are Individuals and Settings. Individuals are people that have personal characteristics, such as age, sex, and many more. Look up the documentation of the Individual object to get a full list of parameters.","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"<p align=\"center\">\n    <img src=\"../assets/base-agents-and-settings.png\" width=\"80%\"/>\n</p>","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"Settings are the (physical or social) contexts in which contacts can occur. A setting does always have a type (e.g., Household or SchoolClass) and can be geolocated. Individuals can belong to an arbitrary number of settings but only one of each type. Settings can hold an arbitrary number of individuals.","category":"page"},{"location":"base-population/#pop-layers","page":"Population","title":"Layered Architecture","text":"","category":"section"},{"location":"base-population/","page":"Population","title":"Population","text":"GEMS' base model architecture was designed with parallelization in mind. The model is segmented in disjunctive layers by setting type. We assume that each individual is only assigned to one setting of a particular setting type (no individual is assigned to two households, for example). This setup allows us to calculate all contacts and infections that happen during one timestep (e.g., one day) for all settings of a given type concurrently. The image below illustrates how individuals of the base population (green dots on the bottom layer) can be assigned to settings on each of the layers. A layer contains all settings of a given type (e.g., households). The edges between individuals on any of the upper layers indicates that these individuals each belong to the same setting of the respective type.","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"(Image: GEMS Base Population Model)","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"Moreover, we only simulate infections in so-called Active Settings. These are settings that contain infectious individuals and can therefore produce infections during the current timestep. Settings without infectious individuals (in-active settings) are not being simulated as they do not contribute to the overall infection dynamics. Active Settings in the image above are visualized with a white glow around the individuals. Red circles are infectious individuals.","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"This approach cuts the simulation execution time drastically. In our benchmarks, we were able to simulate 80 million agents for one year with 75% total infections in roughly 30 minutes on a 24 core machine. We discuss these ideas in:","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"Ponge, J., Horstkemper, D., Hellingrath, B., Bayer, L., Bock, W. and Karch, A., 2023, December. Evaluating Parallelization Strategies for Large-Scale Individual-based Infectious Disease Simulations. In 2023 Winter Simulation Conference (WSC) (pp. 1088-1099). IEEE. https://doi.org/10.1109/WSC60868.2023.10407633","category":"page"},{"location":"base-population/#setting-hierarchy","page":"Population","title":"Hierarchical Setting Structure","text":"","category":"section"},{"location":"base-population/","page":"Population","title":"Population","text":"Many places, such as schools or workplaces, can be very large. However, daily contacts often just occur between class mates or office colleauges. GEMS arranges settings hierarchically to represent these nested structures.","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"<p align=\"center\">\n    <img src=\"../assets/base-setting-hierarchy.png\" width=\"70%\"/>\n</p>","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"We differentiate between IndividualSettings and ContainerSettings. The former are the settings that individuals have direct connections with. They are the lowest-level settings (e.g., School classes, offices, or households). The latter are the settings that aggregate the low-level settings to bigger ones (e.g., SchoolYears, Schools or Workplaces).","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"Individual Settings in GEMS are Household, SchoolClass, Office, and Municipality. Container Settings are available for school classes and offices on four layers each: SchoolClass -> SchoolYear -> School -> SchoolComplex and Office -> Department -> Workplace -> WorkplaceSite.","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"You can run a simulation with only Individual Settings. Container Settings are added via so-called \"settings files\".","category":"page"},{"location":"base-population/#pop-generator","page":"Population","title":"Inbuilt Population Generator","text":"","category":"section"},{"location":"base-population/","page":"Population","title":"Population","text":"If you setup a simulation without a custom population file like sim = Simulation(), GEMS will generate a non-representative baseline population on-the-fly. You can pass arguments pop_size (called n in the explanation below), avg_household_size, avg_office_size, and avg_school_size to the engine.","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"<p align=\"center\">\n    <img src=\"../assets/base-sample-population-generation.png\" width=\"100%\"/>\n</p>","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"The population generator will first set up an empty dataframe with one row per individual (Step 1) and add the required number of households with one index individual per household (Step 2). Their ages will be randomly sampled from the German age distribution. We then iteratevly create the remainig individuals. To get a somewhat realistic household age-coupling of individuals, we first select on of the index individuals and sample the age for a new household member based on household contact data from the COVIMOD study (Step 3). In the last step, we sample a school ID for every agent between the ages of 6 and 18, and an office for all agents between the ages of 18 and 65. While the example refers to \"schools\", they are internally handled as SchoolClasses.","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"Here's a code snippet that visualizes the age- and household size distributions of such a generated population:","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"using GEMS, Plots\nsim = Simulation()\nages = age.(individuals(sim))\nhh_sizes = size.(households(sim))\n\nplot(\n    histogram(ages, label = \"Age\", title = \"Age Distribution\"),\n    histogram(hh_sizes, label = \"Size\", title = \"Household Sizes\",\n        bins=1:maximum(hh_sizes) + 1,\n        xticks = 1:maximum(hh_sizes) + 1),\n    size = (800, 300)\n)","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"<p align=\"center\">\n    <img src=\"../assets/base-sample-population-properties.png\" width=\"60%\"/>\n</p>","category":"page"},{"location":"base-population/","page":"Population","title":"Population","text":"warning: This does only apply to the on-the-fly genrated populations!\nIf you are using any of the pre-built population models, e.g., via Simulation(population = \"NRW\"), you will get a model that is based on the Gesyland Project","category":"page"},{"location":"tut_infections/#12-Infections-and-Immunity","page":"12 - Infections & Immunity","title":"12 - Infections & Immunity","text":"","category":"section"},{"location":"api_batch/#Batches","page":"Batches","title":"Batches","text":"","category":"section"},{"location":"api_batch/#Overview-Structs","page":"Batches","title":"Overview Structs","text":"","category":"section"},{"location":"api_batch/","page":"Batches","title":"Batches","text":"Pages   = [\"api_batch.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_batch/#Overview-Functions","page":"Batches","title":"Overview Functions","text":"","category":"section"},{"location":"api_batch/","page":"Batches","title":"Batches","text":"Pages   = [\"api_batch.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_batch/#Batch","page":"Batches","title":"Batch","text":"","category":"section"},{"location":"api_batch/#Constructors","page":"Batches","title":"Constructors","text":"","category":"section"},{"location":"api_batch/#GEMS.Batch-Tuple{}","page":"Batches","title":"GEMS.Batch","text":"Batch(;n_runs::Integer = 0, print_infos::Bool = false, simargs...)\n\nCreates a Batch object with a number of Simulation objects as specified in n_runs. The Simulation objects are not passed but rather instantiated inside this function. Therefore, you can specify any keyworded argument using simargs..., that you would otherwise pass to the Simulation() constructor.\n\nThis function suppresses the console info outputs of the Simulation() function. If you want to enable them, set the optional print_info argument to True. \n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.Batch-Tuple{Vararg{Simulation}}","page":"Batches","title":"GEMS.Batch","text":"Batch(simulations::Simulation...)\n\nCreates a Batch object from Simulation objects. Note: All Simulation objects must be unique. You cannot pass the same simulation twice.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.Batch-Tuple{Vector{Simulation}}","page":"Batches","title":"GEMS.Batch","text":"Batch(simulations::Vector{Simulation})\n\nCreates a Batch object from a vector of Simulation objects. Note: All Simulation objects must be unique. You cannot pass the same simulation twice.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.Batch-Tuple{Vararg{Batch}}","page":"Batches","title":"GEMS.Batch","text":"Batch(batches::Batch...)\n\nMerge multiple Batches into one.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.Batch-Tuple{Vector{Batch}}","page":"Batches","title":"GEMS.Batch","text":"Batch(batches::Vector{Batch})\n\nMerge multiple Batches into one.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#Functions","page":"Batches","title":"Functions","text":"","category":"section"},{"location":"api_batch/#GEMS.add!-Tuple{Simulation, Batch}","page":"Batches","title":"GEMS.add!","text":"add!(sim::Simulation, batch::Batch)\n\nAdds a Simulation to a Batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#Base.append!-Tuple{Batch, Batch}","page":"Batches","title":"Base.append!","text":"append!(batch1::Batch, batch2::Batch)\n\nAppends all simulations of batch2 to batch1.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.customlogger!-Tuple{Batch, CustomLogger}","page":"Batches","title":"GEMS.customlogger!","text":"customlogger!(batch::Batch, cl::CustomLogger)\n\nAdds a CustomLogger to each of the Simulation objects that are contained in this batch. Note: This function will generate a duplicate of the passed logger for each of the simulation objects as otherwise, als data from all simulations would  we written to the same logger.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#Base.merge-Tuple{Vararg{Batch}}","page":"Batches","title":"Base.merge","text":"merge(batches::Batch...)\nmerge(batches::Vector{Batch})\n\nGenerates a new Batch that contains all simulations of the input Batches. \n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.remove!-Tuple{Simulation, Batch}","page":"Batches","title":"GEMS.remove!","text":"remove!(sim::Simulation, batch::Batch)\n\nRemoves a Simulation from a Batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.run!-Tuple{Batch}","page":"Batches","title":"GEMS.run!","text":"run!(batch::Batch; stepmod!::Function = x -> x)\n\nRun all simulations within a Batch. You can pass a stepmod! function that is being executed for each simulation in each step. But be aware that it will be the same instance of the stepmod! function. So if you have any internal data collection, this might cause inconsistencies.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.simulations-Tuple{Batch}","page":"Batches","title":"GEMS.simulations","text":"simulations(batch::Batch)\n\nReturns the list of Simulations associated with a Batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#BatchProcessor","page":"Batches","title":"BatchProcessor","text":"","category":"section"},{"location":"api_batch/#SConstructors","page":"Batches","title":"SConstructors","text":"","category":"section"},{"location":"api_batch/#GEMS.BatchProcessor-Tuple{Vector{ResultData}}","page":"Batches","title":"GEMS.BatchProcessor","text":"BatchProcessor(rundata::Vector{ResultData})\n\nCreates a BatchProcessor object for a vector of ResultData objects.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.BatchProcessor-Tuple{Batch}","page":"Batches","title":"GEMS.BatchProcessor","text":"BatchProcessor(batch::Batch; stysle::String = \"LightRD\", print_infos::Bool = false)\n\nCreates a BatchProcessor object from a Batch object. This constructor generates the ResultData object for each of the Simulations contained in the Batch. It supresses the usual info outputs that are being made during the ResultData generation. If you want to enable them, pass print_infos = true.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#Functions-2","page":"Batches","title":"Functions","text":"","category":"section"},{"location":"api_batch/#GEMS.allocations-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.allocations","text":"allocations(batchProcessor::BatchProcessor)\n\nReturns a dataframe for the memory allocations of the associated simulation runs in this batch. The columns correspond to the names of the inner timers while each row corresponds to one run. (Note: This data is only available if the simulation runs were done via the main() function)\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.attack_rate-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.attack_rate","text":"attack_rate(batchProcessor::BatchProcessor)\n\nReturns a vector of the attack_rate accross the simulation runs in this batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.config_files-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.config_files","text":"config_files(batchProcessor::BatchProcessor)\n\nReturns the associated config file.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.cumulative_disease_progressions-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.cumulative_disease_progressions","text":"cumulative_disease_progressions(batchProcessor::BatchProcessor)\n\nReturns cumulative quarantines per tick accross the simulation runs in this batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.cumulative_quarantines-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.cumulative_quarantines","text":"cumulative_quarantines(batchProcessor::BatchProcessor)\n\nReturns cumulative quarantines per tick accross the simulation runs in this batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.effectiveR-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.effectiveR","text":"effectiveR(batchProcessor::BatchProcessor)\n\nReturns the effective R value for each tick accross the simulation runs in this batch. It returns mean, standard deviation, range, and confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.number_of_individuals-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.number_of_individuals","text":"number_of_individuals(batchProcessor::BatchProcessor)\n\nReturns a vector of number_of_individuals that were used in the associated simulations. Values are unique and can originate from multiple simulation runs.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.pathogens-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.pathogens","text":"pathogens(batchProcessor::BatchProcessor)\n\nReturns a vector of pathogens that were used in the associated simulations. Values are unique and can originate from multiple simulation runs.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.pathogens_by_name-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.pathogens_by_name","text":"pathogens_by_name(batchProcessor::BatchProcessor)\n\nReturns a {name, pathogen[]} dictionary of pathogens that were used in the associated simulations. This is done to keep multiple pathogen configurations of the same name with varying parameters. Names are unique and can originate from multiple simulation runs.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.population_files-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.population_files","text":"population_files(batchProcessor::BatchProcessor)\n\nReturns the associated population file.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.population_pyramid-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.population_pyramid","text":"population_pyramid(batchProcessor::BatchProcessor)\n\nReturns a {String, DataFrame} dictionary containing data to generate a population pyramid for each population files of this batch. \n\nDataframe Columns\n\nName Type Description\nage Int8 1-year age classes\nsex Int8 Sex according to population DataFame (0 = female, 1 = male)\ngender String String variant of Sex [Female, Male]\nsum Int64 Total of all genders in all ages (females multiplied by -1)\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.run_ids-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.run_ids","text":"run_ids(batchProcessor::BatchProcessor)\n\nReturns the vector of simulation run IDs that are associated with this batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.rundata-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.rundata","text":"rundata(batchProcessor::BatchProcessor)\n\nReturns the vector of ResultData objects of simulation runs that are associated with this batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.runtime-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.runtime","text":"runtime(batchProcessor::BatchProcessor)\n\nReturns dataframe of the runtimes of the associated simulation runs in this batch. The columns correspond to the names of the inner timers while each row corresponds to one run. (Note: This data is only available if the simulation runs were done via the main() function)\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.setting_age_contacts-Tuple{BatchProcessor, DataType}","page":"Batches","title":"GEMS.setting_age_contacts","text":"setting_age_contacts(batchProcessor::BatchProcessor, settingtype::DataType)\n\nReturns a {String, DataFrame} dictionary containing an age X age matrix with sampled contacts for a provided settingtype (i.e. Households) for each population files of this batch. \n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.settingdata-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.settingdata","text":"settingdata(batchProcessor::BatchProcessor)\n\nReturns a {String, DataFrame} dictionary containing information about setting types in the population files in the simulation runs of this batch. Populations are distinguished by their population file name stored in the key of the result dictionary.\n\nDataframe Columns\n\nName Type Description\nsetting_type String Setting type identifier (name)\nnumber_of_settings Int64 Overall number of settings of that type\nmin_individuals Float64 Lowest number of individuals assigned to a setting of this type\nmax_individuals Float64 Highest number of individuals assigned to a setting of this type\navg_individuals Float64 Average number of individuals assigned to a setting of this type\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.start_conditions-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.start_conditions","text":"start_conditions(batchProcessor::BatchProcessor)\n\nReturns a vector of start_conditions that were used in the associated simulations. Values are unique and can originate from multiple simulation runs.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.stop_criteria-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.stop_criteria","text":"stop_criteria(batchProcessor::BatchProcessor)\n\nReturns a vector of stop_criteria that were used in the associated simulations. Values are unique and can originate from multiple simulation runs.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.strategies-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.strategies","text":"strategies(batchProcessor::BatchProcessor)\n\nReturns a vector of the strategies accross the simulation runs in this batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.symptom_triggers-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.symptom_triggers","text":"symptom_triggers(batchProcessor::BatchProcessor)\n\nReturns a vector of the symptom_triggers accross the simulation runs in this batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.tests-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.tests","text":"tests(batchProcessor::BatchProcessor)\n\nReturns newly exposed inviduals per tick accross the simulation runs in this batch. It returns mean, standard deviation, range, and confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.testtypes-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.testtypes","text":"testtypes(batchProcessor::BatchProcessor)\n\nReturns a vector of the testtypes accross the simulation runs in this batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.tick_cases-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.tick_cases","text":"tick_cases(batchProcessor::BatchProcessor)\n\nReturns newly exposed inviduals per tick accross the simulation runs in this batch. It returns mean, standard deviation, range, and confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.tick_unit-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.tick_unit","text":"tick_unit(batchProcessor::BatchProcessor)\n\nReturns a vector of tick_units that were used in the associated simulations. Values are unique and can originate from multiple simulation runs.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.total_infections-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.total_infections","text":"total_infections(batchProcessor::BatchProcessor)\n\nReturns a vector of the total_infections accross the simulation runs in this batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.total_quarantines-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.total_quarantines","text":"total_quarantines(batchProcessor::BatchProcessor)\n\nReturns a vector of the total_quarantines accross the simulation runs in this batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.total_tests-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.total_tests","text":"total_tests(batchProcessor::BatchProcessor)\n\nReturns a Dict of vectors of the total_tests per TestType accross the simulation runs in this batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#BatchData","page":"Batches","title":"BatchData","text":"","category":"section"},{"location":"api_batch/#Constructors-2","page":"Batches","title":"Constructors","text":"","category":"section"},{"location":"api_batch/#GEMS.BatchData-Tuple{BatchProcessor}","page":"Batches","title":"GEMS.BatchData","text":"BatchData(batchProcessor::BatchProcessor; style::String = \"DefaultBatchData\")\n\nCreate a BatchData object using a BatchProcessor and a style, that defines which calculations should be done. Post Processing requires a simulation to be done.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.BatchData-Tuple{Batch}","page":"Batches","title":"GEMS.BatchData","text":"BatchData(batch::Batch; style::String = \"DefaultBatchData\", rd_style = \"LightRD\")\n\nCreate a BatchData object using a Batch and a style, that defines which calculations should be done during batch processing. As the provided batch has unprocessed simulation runs inside, this function also triggers post processing for the individual simulation runs. The rd_style argument defines the calculations that should be done during post processing of the individual runs. Post processing requires a simulation to be done.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.BatchData-Tuple{Vector{ResultData}}","page":"Batches","title":"GEMS.BatchData","text":"BatchData(rds::Vector{ResultData}; style::String = \"DefaultBatchData\")\n\nCreate a BatchData object using a vector of ResultData objects and a style, that defines which calculations should be done during batch processing.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.BatchData-Tuple{Vararg{BatchData}}","page":"Batches","title":"GEMS.BatchData","text":"BatchData(bds::BatchData...; style::String = \"DefaultBatchData\")\n\nCalls the merge() function for the input BatchData objects.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.BatchData-Tuple{Vector{BatchData}}","page":"Batches","title":"GEMS.BatchData","text":"BatchData(bds::Vector{BatchData}; style::String = \"DefaultBatchData\")\n\nCalls the merge() function for the input vector of BatchData objects.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#Functions-3","page":"Batches","title":"Functions","text":"","category":"section"},{"location":"api_batch/#GEMS.allocations-Tuple{BatchData}","page":"Batches","title":"GEMS.allocations","text":"allocations(bd::BatchData)\n\nReturns allocation data of the simulation runs in this batch. (Note: This data is only available if the simulation runs were done via the main() function)\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.attack_rate-Tuple{BatchData}","page":"Batches","title":"GEMS.attack_rate","text":"attack_rate(bd::BatchData)\n\nReturns aggregated values for the attack_rate accross the simulation runs in this batch. It returns mean, standard deviation, range, and confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.cpu_data-Tuple{BatchData}","page":"Batches","title":"GEMS.cpu_data","text":"cpu_data(bd::BatchData)\n\nReturns the processor information (not available for ARM Macs)\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.cumulative_disease_progressions-Tuple{BatchData}","page":"Batches","title":"GEMS.cumulative_disease_progressions","text":"cumulative_disease_progressions(bd::BatchData)\n\nReturns aggregated values for cumulativediseaseprogressions per tick accross the simulation runs in this batch. It returns mean, standard deviation, range, and confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.cumulative_quarantines-Tuple{BatchData}","page":"Batches","title":"GEMS.cumulative_quarantines","text":"cumulative_quarantines(bd::BatchData)\n\nReturns aggregated values cumulative_quarantines per tick accross the simulation runs in this batch. It returns mean, standard deviation, range, and confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.dataframes-Tuple{BatchData}","page":"Batches","title":"GEMS.dataframes","text":"dataframes(batchData)\n\nReturns the dataframes dict of the batch data object.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.effectiveR-Tuple{BatchData}","page":"Batches","title":"GEMS.effectiveR","text":"effectiveR(bd::BatchData)\n\nReturns aggregated values for the effective R value for each tick accross the simulation runs in this batch. It returns mean, standard deviation, range, and confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.execution_date-Tuple{BatchData}","page":"Batches","title":"GEMS.execution_date","text":"execution_date(bd::BatchData)\n\nReturns the timestamp of batch data generation.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.exportJLD-Tuple{BatchData, AbstractString}","page":"Batches","title":"GEMS.exportJLD","text":"exportJLD(batchData, directory)\n\nExports the BatchData object as a JLD2 file, storing it in the specified directory.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.free_mem_size-Tuple{BatchData}","page":"Batches","title":"GEMS.free_mem_size","text":"free_mem_size(bd::BatchData)\n\nReturns the available system memory\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.GEMS_version-Tuple{BatchData}","page":"Batches","title":"GEMS.GEMS_version","text":"GEMS_version(bd::BatchData)\n\nReturns the GEMS version this BatchData object was generated with. \n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.git_branch-Tuple{BatchData}","page":"Batches","title":"GEMS.git_branch","text":"git_branch(bd::BatchData)\n\nReturns the current git branch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.git_commit-Tuple{BatchData}","page":"Batches","title":"GEMS.git_commit","text":"git_commit(bd::BatchData)\n\nReturns the current git commit.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.git_repo-Tuple{BatchData}","page":"Batches","title":"GEMS.git_repo","text":"git_repo(bd::BatchData)\n\nReturns the current git repository.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.id-Tuple{BatchData}","page":"Batches","title":"GEMS.id","text":"id(bd::BatchData)\n\nReturns the stringified SHA1 hash that serves as a unique identifier.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.import_batchdata-Tuple{AbstractString}","page":"Batches","title":"GEMS.import_batchdata","text":"import_batchdata(filepath::AbstractString)\n\nImport the BatchData object from a jld2 file. Returns the BatchData object.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.info-Tuple{BatchData}","page":"Batches","title":"GEMS.info","text":"info(bd::BatchData)\n\nPrints info about available fields in the BatchData object.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.julia_version-Tuple{BatchData}","page":"Batches","title":"GEMS.julia_version","text":"julia_version(bd::BatchData)\n\nReturns the Julia version that was used to generate this result data object.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.kernel-Tuple{BatchData}","page":"Batches","title":"GEMS.kernel","text":"kernel(bd::BatchData)\n\nReturns the system kernel information\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#Base.merge-Tuple{Vararg{BatchData}}","page":"Batches","title":"Base.merge","text":"merge(bds::BatchData...; style::String = \"DefaultBatchData\")\nmerge(bds::Vector{BatchData}; style::String = \"DefaultBatchData\")\n\nGenerates a new BatchData object from the union of all ResultData objects out of all the passed BatchData objects. Naturally, this requires the input BatchData objects to have internal ResultData objects. This requirement is met if the default style (DefaultBatchData) was used during the creation of the input objects. Simply: If you didn't apply any custom style, this should work.\n\nReturns\n\nBatchData: (New) combined BatchData object with all internal ResultData objects\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.meta_data-Tuple{BatchData}","page":"Batches","title":"GEMS.meta_data","text":"meta_data(bd::BatchData)\n\nReturns the metadata dict of the batch data object.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.number_of_runs-Tuple{BatchData}","page":"Batches","title":"GEMS.number_of_runs","text":"number_of_runs(bd::BatchData)\n\nReturns the number of runs in this batch.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.runs-Tuple{BatchData}","page":"Batches","title":"GEMS.runs","text":"runs(bd::BatchData)\n\nReturns the ResultData objects of each of the runs in the the batch data object.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.runtime-Tuple{BatchData}","page":"Batches","title":"GEMS.runtime","text":"runtime(bd::BatchData)\n\nReturns runtime data of the simulation runs in this batch. (Note: This data is only available if the simulation runs were done via the main() function)\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.sim_data-Tuple{BatchData}","page":"Batches","title":"GEMS.sim_data","text":"sim_data(bd::BatchData)\n\nReturns the simdata dict of the batch data object.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.system_data-Tuple{BatchData}","page":"Batches","title":"GEMS.system_data","text":"system_data(bd::BatchData)\n\nReturns the systemdata dict of the batch data object.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.tests-Tuple{BatchData}","page":"Batches","title":"GEMS.tests","text":"tests(bd::BatchData)\n\nReturns aggregated values for tests per tick accross the simulation runs in this batch. It returns mean, standard deviation, range, and confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.tick_cases-Tuple{BatchData}","page":"Batches","title":"GEMS.tick_cases","text":"tick_cases(bd::BatchData)\n\nReturns aggregated values for newly exposed inviduals per tick accross the simulation runs in this batch. It returns mean, standard deviation, range, and confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.threads-Tuple{BatchData}","page":"Batches","title":"GEMS.threads","text":"threads(bd::BatchData)\n\nReturns the number of threads this Julia instance was started with\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.total_infections-Tuple{BatchData}","page":"Batches","title":"GEMS.total_infections","text":"total_infections(bd::BatchData)\n\nReturns aggregated values for total_infections accross the simulation runs in this batch. It returns mean, standard deviation, range, and confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.total_mem_size-Tuple{BatchData}","page":"Batches","title":"GEMS.total_mem_size","text":"total_mem_size(bd::BatchData)\n\nReturns the total system memory\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.total_quarantines-Tuple{BatchData}","page":"Batches","title":"GEMS.total_quarantines","text":"total_quarantines(batchData)\n\nReturns aggregated values for total_quarantines accross the simulation runs in this batch. It returns mean, standard deviation, range, and confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.total_tests-Tuple{BatchData}","page":"Batches","title":"GEMS.total_tests","text":"total_tests(bd::BatchData)\n\nReturns aggregated values for total_tests accross the simulation runs in this batch. It returns mean, standard deviation, range, and confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#GEMS.word_size-Tuple{BatchData}","page":"Batches","title":"GEMS.word_size","text":"word_size(bd::BatchData)\n\nReturns the system word size\n\n\n\n\n\n","category":"method"},{"location":"api_batch/#BatchDataStyle","page":"Batches","title":"BatchDataStyle","text":"","category":"section"},{"location":"api_batch/#GEMS.DefaultBatchData","page":"Batches","title":"GEMS.DefaultBatchData","text":"DefaultBatchData <: BatchDataStyle\n\nThe default style for BatchData objects. It contains all that can currently be calculated in the BatchProcessor and all ResultData objects of the  individual runs.\n\nFields\n\ndata::Dict{String, Any}\nmeta_data::Dict{String, Any}\nexecution_date::String: Time this BatchData object was generated\nGEMS_version::VersionNumber: GEMS version this BatchData object was generated with \nsystem_data::Dict{String, Any}\nkernel::String: System kernel\njulia_version::String: Julia version that was used to generate this data object\nword_size::Int64: System word size\nthreads::Int64: Number of threads this Julia instance was started with\ncpu_data::Markdown.MD: Information on the processor (not available for ARM Macs)\ntotal_mem_size::Float64: Total system memory\nfree_mem_size::Float64: Available system memory\ngit_repo::SubString{String}: Current Git repository\ngit_branch::SubString{String}: Current Git branch\ngit_commit::SubString{String}: Current Git commit ID\nsim_data::Dict{String, Any}\nruns::Vector{ResultData}: ResultData objects of individual simulation runs runs\nnumber_of_runs::Int64: Number of simulation runs\ntotal_infections::Dict{String, Real}: Summary statistics on total infections across simulation runs\nattack_rate::Dict{String, Real}: Summary statistics on attack rates across simulation runs\ntotal_quarantines::Dict{String, Real}: Summary statistics on total quarantines across simulation runs\ntotal_tests::Dict{String, Real}: Summary statistics on total tests across simulation runs\ndataframes::Dict{String, Any}\ntick_cases::Dataframe: Aggregated data on infections per tick across simulation runs\neffectiveR::Dataframe: Aggregated data on the effective reproduction number per tick across simulation runs\ntests::Dataframe: Aggregated data on tests per tick across simulation runs\ncumulative_quarantines::Dataframe: Aggregated data on cumulative quarantines per tick across simulation runs\ncumulative_disease_progressions::Dataframe: Aggregated data on cumulative disease progressions per tick across simulation runs\n\n\n\n\n\n","category":"type"},{"location":"api_contacts/#Contacts","page":"Contacts","title":"Contacts","text":"","category":"section"},{"location":"api_contacts/","page":"Contacts","title":"Contacts","text":"contact sampling","category":"page"},{"location":"api_contacts/#Overview-Structs","page":"Contacts","title":"Overview Structs","text":"","category":"section"},{"location":"api_contacts/","page":"Contacts","title":"Contacts","text":"Pages   = [\"api_contacts.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_contacts/#Overview-Functions","page":"Contacts","title":"Overview Functions","text":"","category":"section"},{"location":"api_contacts/","page":"Contacts","title":"Contacts","text":"Pages   = [\"api_contacts.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_contacts/#Structs","page":"Contacts","title":"Structs","text":"","category":"section"},{"location":"api_contacts/#GEMS.AgeContactDistribution","page":"Contacts","title":"GEMS.AgeContactDistribution","text":"AgeContactDistribution\n\nWrapper for a 'Age x Age Contact Distribution'.\n\nAttributes\n\ndistribution_data::Vector{Int64}: Vector containing the numbers of contacts from each individual of ego_age with individuals of age contact_age.\nego_age::Int8: Age of the \"Ego\" individual.\ncontact_age::Int8: Age of the \"Contact\" individual\n\n\n\n\n\n","category":"type"},{"location":"api_contacts/#GEMS.AgeGroupContactDistribution","page":"Contacts","title":"GEMS.AgeGroupContactDistribution","text":"AgeGroupContactDistribution\n\nWrapper for a 'AgeGroup x AgeGroup Contact Distribution'.\n\nAttributes\n\ndistribution_data::Vector{Int64}: Vector containing the numbers of contacts from each individual of ego_age_group with individuals of contact_age_group.\nego_age_group::Tuple{Int8, Int8}: Lower and Upper bound of the Age Group of \"Ego\" individuals. The upper bound is excluded (ego_age_group=(0,5) corresponds to the ages 0 till 4).\ncontact_age_group::Tuple{Int8, Int8}: Lower and Upper bound of the Age Group of \"Contact\" individuals. The upper bound is excluded (ego_age_group=(0,5) corresponds to the ages 0 till 4).\n\n\n\n\n\n","category":"type"},{"location":"api_contacts/#GEMS.ContactMatrix","page":"Contacts","title":"GEMS.ContactMatrix","text":"ContactMatrix{T <: Number}\n\nInterface for epidemiologic contact matrices. Contact Matrices are important for simulation models of infectious diseases, as they contain information about contact behavior of individuals inside a population. Contact matrices are symmetric matrices that show the aggregated number of contacts of individuals. The aggregation of ContactMatrix in GEMS is \"by age\". By providing interval_steps = 1, the matrix isn't aggregated and represents contacts between two ages.\n\nFields\n\ndata::Matrix{T}: Raw data of the contact matrix. Each cell has to represent an age group with the same step size as interval_steps\ninterval_steps::Int64: Steps size of each age group\naggregation_bound::Int64: Maximum age up to which the contact matrix is aggregated. This is often used if the last age group is smaller than interval_steps. This parameter is optional.\n_size::Int64: Internal attribute. Defines the size of one matrix dimension.\n\nExample\n\nIn this example, we create a 3x3 matrix where each column/row represents an age group of 10 but the last age group only goes until 26 (these numbers are made up!), so we cap it at 20 (see \"[0-10), [10-20), 20+\").\n\nHere [1 4 7] represent age group [0-10), [2 5 8] age group [10-20) and [3 6 9] age group 20+.\n\njulia> matrix = [1 2 3; 4 5 6; 7 8 9]\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> ContactMatrix{Int64}(matrix, 10, 20)\nContactMatrix{Int64}([1 2 3; 4 5 6; 7 8 9], 10, 20, 3)\n\n\n\n\n\n\n","category":"type"},{"location":"api_contacts/#GEMS.ContactSamplingMethod","page":"Contacts","title":"GEMS.ContactSamplingMethod","text":"ContactSamplingMethod\n\nSupertype for all contact sampling methods. This type is intended to be extended by providing different sampling methods suitable for the structure of the simulation model.\n\n\n\n\n\n","category":"type"},{"location":"api_contacts/#GEMS.ContactparameterSampling","page":"Contacts","title":"GEMS.ContactparameterSampling","text":"ContactparameterSampling <: ContactSamplingMethod\n\nSample random contacts based on a Poisson-Distribution spread around contactparameter.\n\n\n\n\n\n","category":"type"},{"location":"api_contacts/#GEMS.RandomSampling","page":"Contacts","title":"GEMS.RandomSampling","text":"RandomSampling <: ContactSamplingMethod\n\nSample exactly one contact per individual inside a Setting. The sampling will be random.\n\n\n\n\n\n","category":"type"},{"location":"api_contacts/#Constructors","page":"Contacts","title":"Constructors","text":"","category":"section"},{"location":"api_contacts/#GEMS.AgeContactDistribution-Tuple{Vector{Int64}, Int8, Int8}","page":"Contacts","title":"GEMS.AgeContactDistribution","text":"AgeContactDistribution(distribution_data::Vector{Int64}, ego_age::Int8, contact_age::Int8)\n\nDefault constructor for AgeContactDistribution.\n\nParameters\n\ndistribution_data::Vector{Int64}: Vector containing the numbers of contacts from each individual of ego_age with individuals of age contact_age.\nego_age::Int8: Age of the \"Ego\" individual.\ncontact_age::Int8: Age of the \"Contact\" individual\n\n\n\n\n\n","category":"method"},{"location":"api_contacts/#GEMS.AgeGroupContactDistribution-Tuple{Vector{Int64}, Tuple{Int8, Int8}, Tuple{Int8, Int8}}","page":"Contacts","title":"GEMS.AgeGroupContactDistribution","text":"AgeGroupContactDistribution(distribution_data::Vector{Int64}, ego_age_group::Tuple{Int8, Int8}, contact_age_group::Tuple{Int8, Int8})\n\nDefault constructor for AgeGroupContactDistribution.\n\nParameters\n\ndistribution_data::Vector{Int64}: Vector containing the numbers of contacts from each individual of ego_age_group with individuals of contact_age_group.\nego_age_group::Tuple{Int8, Int8}: Lower and Upper bound of the Age Group of \"Ego\" individuals. The upper bound is excluded (ego_age_group=(0,5) corresponds to the ages 0 till 4).\ncontact_age_group::Tuple{Int8, Int8}: Lower and Upper bound of the Age Group of \"Contact\" individuals. The upper bound is excluded (contact_age_group=(0,5) corresponds to the ages 0 till 4).\n\n\n\n\n\n","category":"method"},{"location":"api_contacts/#Functions","page":"Contacts","title":"Functions","text":"","category":"section"},{"location":"api_contacts/#GEMS.aggregate_matrix","page":"Contacts","title":"GEMS.aggregate_matrix","text":"aggregate_matrix(matrix::Matrix, interval_steps::Int64)\n\nCalculate an aggregated matrix by providing the length of the interval to aggregate. Each interval will have the same length. If the dimension of the given matrix isn't divisible by interval_steps, the last interval will contain the rest of the values (this causes the last interval to be shorter than every other interval).\n\nAssumptions:\n\nThe input matrix has to be of shape n x n, where n is an Int64.\n\nExample:\n\njulia> matrix = [1 1  2 2 3 ; 1 1  2 2 3 ; 3 3 4 4 3; 3 3 4 4 3; 3 3 3 3 3]\n5×5 Matrix{Int64}:\n 1  1  2  2  3\n 1  1  2  2  3\n 3  3  4  4  3\n 3  3  4  4  3\n 3  3  3  3  3\n\njulia> aggregate_matrix(matrix,2) # intervals would be [1:3), [3:5), [5:5]\n3×3 Matrix{Int64}:\n  4   8  6\n 12  16  6\n  6   6  3\n\n\n\n\n\n\naggregate_matrix(vector::Vector, interval_steps::Int64)::Matrix\n\nAggregate values in a Vector by a given interval (defined by interval_steps). If the dimension of the given Vector isn't divisible by interval_steps, the last interval will contain the rest of the values (this causes the last interval to be shorter than every other interval).\n\nExample\n\njulia> vector = [1, 1, 8, 5, 3]\n5-element Vector{Int64}:\n 1\n 1\n 8\n 5\n 3\n\n# intervals would be [1:3), [3:5), [5:5]\njulia> aggregate_matrix(vector,2)\n3×1 Matrix{Int64}:\n  2\n 13\n  3\n\n\n\n\n\n\naggregate_matrix(matrix::Matrix, interval_steps::Int64, aggregation_bound::Int64)\n\nAggregate values in a matrix by a given interval (defined by interval_steps). aggregation_bound sets a upper boundary. In the interval [1:aggregation_bound), values are aggregated in sub-intervals defined by interval_steps. In the interval [aggregation_bound:length(matrix[1,:])] all values will be summed up.\n\nAssumptions:\n\nThe input matrix has to be of shape n x n, where n is an Int64.\n\nExample:\n\njulia> matrix = [1 1  2 2 3 ; 1 1  2 2 3 ; 3 3 4 4 3; 3 3 4 4 3; 3 3 3 3 3]\n5×5 Matrix{Int64}:\n 1  1  2  2  3\n 1  1  2  2  3\n 3  3  4  4  3\n 3  3  4  4  3\n 3  3  3  3  3\n\n# intervals would be [1:3), 3+\njulia> aggregate_matrix(matrix, 2, 3)\n2×2 Matrix{Int64}:\n  4  14\n 18  31\n\n\n\n\n\n\naggregate_matrix(vector::Vector, interval_steps::Int64, aggregation_bound::Int64)::Matrix\n\nAggregate values in a Vector by a given interval (defined by interval_steps). aggregation_bound sets a upper boundary. In the interval [1:aggregation_bound), values are aggregated in sub-intervals, defined by interval_steps. In the interval [aggregation_bound:length(vector)] all values will be summed up.\n\nExample\n\njulia> vector = [1, 1, 8, 5, 3, 5, 8, 7 ,9]\n9-element Vector{Int64}:\n 1\n 1\n 8\n 5\n 3\n 5\n 8\n 7\n 9\n\n# intervals would be [1:3), [3:5), 5+\njulia> aggregate_matrix(vector, 2, 5)\n3×1 Matrix{Int64}:\n  2\n 13\n 32\n\n\n\n\n\n\n","category":"function"},{"location":"api_contacts/#GEMS.aggregate_populationDF_by_age","page":"Contacts","title":"GEMS.aggregate_populationDF_by_age","text":"aggregate_populationDF_by_age(population_df::DataFrame, interval_steps::Int64)::Matrix\n\nHelper function (it's not intended for direct use, its's rather called by other functions), to aggregate a populationDF by age. interval_steps describes the size of each age group to aggregate.  The aggregated populationDF will be returned as a Matrix.\n\n\n\n\n\naggregate_populationDF_by_age(population_df::DataFrame, interval_steps::Int64, max_age::Int64)::Vector\n\nHelper function (it's not intended for direct use, its's rather called by other functions, to aggregate a populationDF by age. interval_steps describes the size of each age group to aggregate.  max_age sets a maximum age until which the matrix should be aggregated.\n\nReturns\n\nThe aggregated populationDF will be returned as a Matrix.\n\n\n\n\n\n","category":"function"},{"location":"api_contacts/#GEMS.aggregated_setting_age_contacts","page":"Contacts","title":"GEMS.aggregated_setting_age_contacts","text":"aggregated_setting_age_contacts(rd::ResultData)\n\nReturns an age group X age group contact matrix for the specified settingtype (e.g. Households) based on sampled data Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\naggregated_setting_age_contacts(rd::ResultData, settingtype::DataType)\n\nReturns an age group X age group contact matrix for the specified settingtype (e.g. Households) based on sampled data Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"function"},{"location":"api_contacts/#GEMS.calculate_absolute_error-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:Number","page":"Contacts","title":"GEMS.calculate_absolute_error","text":"calculate_absolute_error(matrix1::Matrix{T}, matrix2::Matrix{T})::Matrix{T} where T <: Number\n\nCalculate the absolute difference between matrix1 and matrix2.\n\nExample\n\njulia> m1 = [2 2; 2 2]\n2×2 Matrix{Int64}:\n 2  2\n 2  2\n\njulia> m2 = [3 1; 4 2]\n2×2 Matrix{Int64}:\n3  1\n4  2\n\ncalculate_absolute_error(m1,m2)\n2×2 Matrix{Int64}:\n 1  1\n 2  0\n\n\n\n\n\n","category":"method"},{"location":"api_contacts/#GEMS.calculate_ageGroup_contact_distribution","page":"Contacts","title":"GEMS.calculate_ageGroup_contact_distribution","text":"Utitility function. Calculates the number of contacts an individuals in the age group ego_age_group have with individuals in the age group contact_age_group. Each entry is the number of contacts one individual in the age group ego_age_group has with individuals in the age group contact_age_group.\n\nParameters\n\ncontactdata: DataFrame containing data about contacts between an 'ego' and a 'contact'.\nego_age_group::Tuple{Int,Int}: Defines the age interval that should be aggregated for the \"ego age group\". The upper age bound (the second entry of the Tuple) will be excluded like \"[egolowerbound, egoupperbound)\"\ncontact_age_group::Tuple{Int,Int}: Defines the age interval that should be aggregated for the \"contact age group\". The upper age bound (the second entry of the Tuple) will be excluded like \"[contactlowerbound, contactupperbound)\"\nego_id_column: Index indicating which column of contactdata stores information about each ego's id.\nego_age_column: Index indicating which column of contactdata stores information about each ego's age.\ncontact_age_column: Index indicating which column of contactdata stores information about each contact's age.\n\n\n\n\n\n","category":"function"},{"location":"api_contacts/#GEMS.calculate_age_contact_distribution","page":"Contacts","title":"GEMS.calculate_age_contact_distribution","text":"Utitility function. Calculates the number of contacts an individual of age ego_age has with an individual of age contact_age. Each entry is the number of contacts one individual of age ego_age has.\n\nParameters\n\ncontactdata: DataFrame containing data about contacts between an 'ego' and a 'contact'.\nego_age: Age of the 'Ego', that should be included in this distribution.\ncontact_age: Age of the 'Contact', that should be included in this distribution.  \nego_id_column: Index indicating which column of contactdata stores information about each ego's id.\nego_age_column: Index indicating which column of contactdata stores information about each ego's age.\ncontact_age_column: Index indicating which column of contactdata stores information about each contact's age.\n\n\n\n\n\n","category":"function"},{"location":"api_contacts/#GEMS.calculate_zero_contact_distribution","page":"Contacts","title":"GEMS.calculate_zero_contact_distribution","text":"Utitility function. Get how many individuals of a specific age have no contact. An Individiual with no contact, has an entry in contactdata where the columns for data about the contact are \"-1\".\n\nParameters\n\ncontactdata: DataFrame containing data about contacts between an 'ego' and a 'contact'.\nego_age: Age of the 'Ego', that should be included in this distribution.\nego_id_column: Index indicating which column of contactdata stores information about each ego's id.\nego_age_column: Index indicating which column of contactdata stores information about each ego's age.\ncontact_age_column: Index indicating which column of contactdata stores information about each contact's age.\n\n\n\n\n\n","category":"function"},{"location":"api_contacts/#GEMS.ContactMatrix-Union{Tuple{T}, Tuple{Matrix{T}, Int64, Union{Nothing, Int64}}} where T<:Number","page":"Contacts","title":"GEMS.ContactMatrix","text":"ContactMatrix{T}(data::Matrix{T}, interval_steps::Int64, aggregation_bound::Union{Int64, Nothing}) where T <: Number\n\nCreate a ContactMatrix with interval_steps and aggregation_bound. _size will be derived from data.\n\n\n\n\n\n","category":"method"},{"location":"api_contacts/#GEMS.ContactMatrix-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T<:Number","page":"Contacts","title":"GEMS.ContactMatrix","text":"ContactMatrix{T}(data::Matrix{T}, interval_steps::Int64) where T <: Number\n\nCreate a ContactMatrix with interval_steps. _size will be derived from data.\n\n\n\n\n\n","category":"method"},{"location":"api_contacts/#GEMS.contact_samples","page":"Contacts","title":"GEMS.contact_samples","text":"contact_samples(simulation::Simulation, settingtype::DataType, include_non_contacts::Bool)::DataFrame\n\nReturns a dataframe with data on two individuals per row (contact). The contacts are sampled for a provided setting type according to the  ContactSamplingMethod of the desired setting. This also defines, how many contacts will be sampled per individual. If include_non_contacts is true, also the number of \"non-contacts\" (individuals for which the number of sampled contacts is zero) will be included in this dataframe. In this case, b_id, b_age and b_sex will have the value -1. The number of sampled contacts is limited by the global CONTACT_SAMPLES flag in the constants.jl file. It default is 100_000. If you need more samples, change the flag using GEMS.CONTACT_SAMPLES = your_new_int_value.\n\nColumns\n\nName Type Description\na_id Int32 Ego id\na_age Int8 Ego age\na_sex Int8 Ego sex\nb_id Int32 Contact id\nb_age Int8 Contact age\nb_sex Int8 Contact sex\nsetting_type Char Setting, in which the contact occured\n\nReturns\n\nDataframe containing the sampled contacts for the given settingstype. \n\nIf no settings exist for settingtype, an empty DataFrame with the Columns defined above is returned.\n\nIf no contacts are sampled in GEMS.CONTACT_SAMPLES many iterations, an empty DataFrame with the Columns defined above is returned.\n\n\n\n\n\n","category":"function"},{"location":"api_contacts/#GEMS.get_ageGroup_contact_distribution","page":"Contacts","title":"GEMS.get_ageGroup_contact_distribution","text":"get_ageGroup_contact_distribution(contact_distribution_matrix::Matrix{AgeContactDistribution}; ego_age_group::Tuple{Int,Int}, contact_age_group::Tuple{Int,Int})::AgeGroupContactDistribution\n\nAggregates a number of 'Age x Age Contact Distribution's to one new 'AgeGroup x AgeGroup Contact Distribution'.\n\nParameters\n\ncontact_distribution_matrix::Matrix: Contains \"Age x Age Contact Distributions\".\nego_age_group::Tuple{Int,Int}: Defines the age interval that should be aggregated for the \"ego age group\". The upper age bound (the second entry of the Tuple) will be excluded like \"[ego_lower_bound, ego_upper_bound)\"\ncontact_age_group::Tuple{Int,Int}: Defines the age interval that should be aggregated for the \"contact age group\". The upper age bound (the second entry of the Tuple) will be excluded like \"[contact_lower_bound, contact_upper_bound)\"\n\nReturns\n\n'AgeGroup x AgeGroup Contact Distribution'\n\n\n\n\n\nget_ageGroup_contact_distribution(contactdata::DataFrame; ego_age_group::Tuple{Int,Int}, contact_age_group::Tuple{Int,Int}, ego_id_column::Int64, ego_age_column::Int64, contact_age_column::Int64)::AgeGroupContactDistribution\n\nCalculate a 'AgeGroup x AgeGroup' contact distribution for two given age groups defined by ego_age_group and contact_age_group. The correct columns of the input dataframes can be defined by ego_id_column, ego_age_column and contact_age_column.\n\nThe dataframe must contain data of a (artificial) contact survey, where each row represents a contact between two individuals.\n\nParameters\n\ncontactdata: DataFrame containing data about contacts between a 'ego' and 'contacts'.\nego_age_group::Tuple{Int,Int}: Defines the age interval that should be aggregated for the \"ego age group\". The upper age bound (the second entry of the Tuple) will be excluded like \"[ego_lower_bound, ego_upper_bound)\"\ncontact_age_group::Tuple{Int,Int}: Defines the age interval that should be aggregated for the \"contact age group\". The upper age bound (the second entry of the Tuple) will be excluded like \"[contact_lower_bound, contact_upper_bound)\"\nego_id_column::Int64: Index indicating which column of contactdata stores information about each ego's id.\nego_age_column::Int64: Index indicating which column of contactdata stores information about each ego's age.\ncontact_age_column::Int64: Index indicating which column of contactdata stores information about each contact's age.\n\nReturns\n\n'AgeGroup x AgeGroup Contact Distribution'\n\n\n\n\n\n","category":"function"},{"location":"api_contacts/#GEMS.get_age_contact_distribution","page":"Contacts","title":"GEMS.get_age_contact_distribution","text":"get_age_contact_distribution(contactdata::DataFrame; ego_age::Int64, contact_age::Int64, ego_id_column::Int64, ego_age_column::Int64, contact_age_column::Int64)::AgeContactDistribution\n\nCalculate a 'Age x Age' contact distribution for two given ages defined by ego_age and contact_age. The correct columns of the input dataframes can be defined by ego_id_column, ego_age_column and contact_age_column.\n\nThe dataframe must contain data of a (artificial) contact survey, where each row represents a contact between two individuals.\n\nParameters\n\ncontactdata: DataFrame containing data about contacts between an 'ego' and a 'contact'.\nego_age: Age of the 'Ego', that should be included in this distribution.\ncontact_age: Age of the 'Contact', that should be included in this distribution.  \nego_id_column: Index indicating which column of contactdata stores information about each ego's id.\nego_age_column: Index indicating which column of contactdata stores information about each ego's age.\ncontact_age_column: Index indicating which column of contactdata stores information about each contact's age.\n\nReturns\n\nA Distribution of contacts between individuals of age \"Ego Age\" and \"Contact Age\"\n\n\n\n\n\n","category":"function"},{"location":"api_contacts/#GEMS.get_age_contact_distribution_matrix","page":"Contacts","title":"GEMS.get_age_contact_distribution_matrix","text":"get_age_contact_distribution_matrix(contactdata::DataFrame)::Matrix{AgeContactDistribution}\n\nCreate a matrix of contact distributions between individuals of two ages until a given maximum age maxage.\n\n\n\n\n\n","category":"function"},{"location":"api_contacts/#GEMS.get_contacts","page":"Contacts","title":"GEMS.get_contacts","text":"get_contacts(contact_matrix::ContactMatrix{T}, individual::Individual)::T where T <: Number\n\nGet the number of contacts an Individual has, based on its age and an associated contact matrix containing the numbers of contacts per age group.\n\nThe number of contacts is based on a vector of contacts an individual of the age group of individual would have. The concrete number of contacts is then derived by taking the mean of this vector.\n\n\n\n\n\n","category":"function"},{"location":"api_contacts/#GEMS.mean_contacts_per_age_group","page":"Contacts","title":"GEMS.mean_contacts_per_age_group","text":"mean_contacts_per_age_group(post_processor::PostProcessor, settingtype::DataType, interval_steps::Int64)::ContactMatrix{Float64}\n\nCalculates the mean number of contacts between two age groups. The age gropus are defined by the size of interval_steps. The population data is accessed via the postProcessor object to get the number of individuals per age group.\n\nReturns\n\nReturns a ContactMatrix object containing the calculated mean contacts per age group and the interval steps.\n\n\n\n\n\nmean_contacts_per_age_group(post_processor::PostProcessor, settingtype::DataType, interval_steps::Int64, max_age::Int64)::ContactMatrix{Float64}\n\nCalculates the mean number of contacts between two age groups. The age gropus are defined by the size of interval_steps. The population data is accessed via the postProcessor object to get the number of individuals per age group.\n\nmax_age sets a maximum age until which the matrix should be aggregated.\n\nReturns\n\nReturns a ContactMatrix object containing the calculated mean contacts per age group and the interval steps and max age for aggregation.\n\n\n\n\n\n","category":"function"},{"location":"api_contacts/#GEMS.sample_contacts","page":"Contacts","title":"GEMS.sample_contacts","text":"sample_contacts(contact_sampling_method::ContactSamplingMethod, setting::Setting, individual::Individual, tick::Int16; rng::AbstractRNG = Random.default_rng())::ErrorException\n\nAbstract function as Fallback if no specific method is available.\n\n\n\n\n\nsample_contacts(random_sampling_method::RandomSampling, setting::Setting, individual::Individual, tick::Int16)::Vector{Individual}\n\nSample exactly 1 random contact from the individuals in setting.\n\n\n\n\n\nsample_contacts(contactparameter_sampling::ContactparameterSampling, setting::Setting, individual::Individual, tick::Int16)::Vector{Individual}\n\nSample random contacts based on a Poisson-Distribution spread around contactparameter_sampling.contactparameter.\n\n\n\n\n\n","category":"function"},{"location":"api_contacts/#GEMS.setting_age_contacts","page":"Contacts","title":"GEMS.setting_age_contacts","text":"setting_age_contacts(postProcessor::PostProcessor, settingtype::DataType)\n\nReturns an age X age matrix containing sampled contacts for a provided settingtype (i.e. Households)\n\nReturns\n\nMatrix{Int32}: Sampled contacts in age-age matrix\n\n\n\n\n\nsetting_age_contacts(rd::ResultData)\n\nReturns the settingagecontacts dictionary from the ResultData object. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\nsetting_age_contacts(rd::ResultData, settingtype::DataType)\n\nReturns an age X age contact matrix for the specified settingtype (e.g. Households) based on sampled data. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\nsetting_age_contacts(batchProcessor::BatchProcessor, settingtype::DataType)\n\nReturns a {String, DataFrame} dictionary containing an age X age matrix with sampled contacts for a provided settingtype (i.e. Households) for each population files of this batch. \n\n\n\n\n\n","category":"function"},{"location":"api_infections/#Infections-and-Immunity","page":"Infections and Immunity","title":"Infections and Immunity","text":"","category":"section"},{"location":"api_infections/#Overview-Structs","page":"Infections and Immunity","title":"Overview Structs","text":"","category":"section"},{"location":"api_infections/","page":"Infections and Immunity","title":"Infections and Immunity","text":"Pages   = [\"api_infections.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_infections/#Overview-Functions","page":"Infections and Immunity","title":"Overview Functions","text":"","category":"section"},{"location":"api_infections/","page":"Infections and Immunity","title":"Infections and Immunity","text":"Pages   = [\"api_infections.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_infections/#Structs","page":"Infections and Immunity","title":"Structs","text":"","category":"section"},{"location":"api_infections/#GEMS.AgeDependentTransmissionRate","page":"Infections and Immunity","title":"GEMS.AgeDependentTransmissionRate","text":"AgeDependentTransmissionRate <: TransmissionFunction\n\nA TransmissionFunction type that allows to define transmission probabilities for specific age groups.\n\n\n\n\n\n","category":"type"},{"location":"api_infections/#GEMS.ConstantTransmissionRate","page":"Infections and Immunity","title":"GEMS.ConstantTransmissionRate","text":"ConstantTransmissionRate <: TransmissionFunction\n\nA TransmissionFunction type that uses a constant transmission rate.\n\n\n\n\n\n","category":"type"},{"location":"api_infections/#GEMS.TransmissionFunction","page":"Infections and Immunity","title":"GEMS.TransmissionFunction","text":"TransmissionFunction\n\nAbstract type for all transmission functions.\n\n\n\n\n\n","category":"type"},{"location":"api_infections/#Constructors","page":"Infections and Immunity","title":"Constructors","text":"","category":"section"},{"location":"api_infections/#GEMS.AgeDependentTransmissionRate-Tuple{}","page":"Infections and Immunity","title":"GEMS.AgeDependentTransmissionRate","text":"AgeDependentTransmissionRate(;transmission_rate, ageGroups, ageTransmissions, distribution)\n\nConstructor for the age-dependent transmission rate struct. The parameters for the constructor include:\n\ntransmission_rate::Vector: A vector containing the parameters from which the distribution of the transmission_rate is constructed.\nageGroups::Vector: A vector containing the age groups. Should contain a vector for each age group consisting of two integers.\nageTransmissions::Vector: A vector containing the parameters for the distributions of the transmission rates for the specific age groups.                           Should contain a vector for each age group consisting of as many real number as parameters required for the spec. distribution.\ndistribution::String: A string that corresponds to a distribution of the distribution package. \n\n\n\n\n\n","category":"method"},{"location":"api_infections/#Functions","page":"Infections and Immunity","title":"Functions","text":"","category":"section"},{"location":"api_infections/#GEMS.disease_progression!-Tuple{Individual, Pathogen, Int16}","page":"Infections and Immunity","title":"GEMS.disease_progression!","text":"disease_progression!(infectee::Individual, pathogen::Pathogen, exposedtick::Int16; rng::AbstractRNG = Random.default_rng())\n\nAssigns a disease progression to the infectee by assigning event ticks based on the  exposedtick.\n\n\n\n\n\n","category":"method"},{"location":"api_infections/#GEMS.estimate_disease_progression-Tuple{DiseaseProgressionStrat, Individual}","page":"Infections and Immunity","title":"GEMS.estimate_disease_progression","text":"estimate_disease_progression(dpr::DiseaseProgressionStrat, indiv::Individual; rng::AbstractRNG = Random.default_rng())\n\nEstimates the final status an individual reaches during the progression of a disease.\n\n\n\n\n\n","category":"method"},{"location":"api_infections/#GEMS.infect!","page":"Infections and Immunity","title":"GEMS.infect!","text":"infect!(infectee::Individual, tick::Int16, pathogen::Pathogen;\n    sim::Union{Simulation, Nothing} = nothing,\n    rng::AbstractRNG = Random.default_rng(),\n    infecter_id::Int32 = Int32(-1), setting_id::Int32 = Int32(-1), lon::Float32 = NaN32,\n    lat::Float32 = NaN32, setting_type::Char = '?', ags::Int32 = Int32(-1),\n    source_infection_id::Int32 = DEFAULT_INFECTION_ID)\n\nInfect infectee with the specified pathogen and calculate time to infectiousness and time to recovery. Optional arguments infecter_id. setting_id, and setting_type can be passed for logging. It's not required to calulate the infection. The infection can only be logged, if Simulation object is passed (as this object holds the logger).\n\nParameters\n\ninfectee::Individual: Individual to infect\ntick::Int16: Infection tick\npathogen::Pathogen: Pathogen to infect the individual with\nsim::Simulation: Simulation object (used to get logger and current tick)\nsim::Union{Simulation, Nothing} = nothing (optional) = Simulation object (used to get logger)\ninfecter_id::Int32 = Int32(-1) (optional): Infecting individual\nsetting_id::Int32 = Int32(-1) (optional): ID of setting this infection happens in\nlon::Float32 = NaN32 (optional): Longitude of the infection infection location (setting) \nlat::Float32 = NaN32 (optional): Latitude of the infection infection location (setting)\nsetting_type::Char = '?' (optional): Setting type as char (e.g. \"h\" for Household)\nags::Int32 = Int32(-1) (optional): Amtlicher Gemeindeschlüssel (community identification number) of the region this infection happened in as Integer value\nsource_infection_id::Int32 = DEFAULT_INFECTION_ID (optional): Current infection ID of the infecting individual\n\nReturns\n\nInt32: New infection ID\n\n\n\n\n\n","category":"function"},{"location":"api_infections/#GEMS.spread_infection!-Tuple{Setting, Simulation, Pathogen}","page":"Infections and Immunity","title":"GEMS.spread_infection!","text":"spread_infection!(setting::Setting, sim::Simulation, pathogen::Pathogen)\n\nSpreads the infection of pathogen inside the provided setting. This will simulate the infection dynamics at the time tick(sim) inside setting within the context of the simulation sim. This will also update all settings, the individual is part of, if the infection is successful.\n\nParameters\n\nsetting::Setting: Setting in which the pathogen shall be spreaded\nsim::Simulation: Simulation object\npathogen::Pathogen: Pathogen to spread\n\n\n\n\n\n","category":"method"},{"location":"api_infections/#GEMS.transmission_probability","page":"Infections and Immunity","title":"GEMS.transmission_probability","text":"transmission_probability(transFunc::TransmissionFunction, infecter::Individual, infected::Individual, setting::Setting, tick::Int16; rng::AbstractRNG = Random.default_rng())\n\nGeneral function for TransmissionFunction struct. Should be overwritten for newly created structs, as it only serves to catch undefined transmission_probability functions.\n\n\n\n\n\ntransmission_probability(transFunc::ConstantTransmissionRate, infecter::Individual, infected::Individual, setting::Setting, tick::Int16; rng::AbstractRNG = Random.default_rng())\n\nCalculates the transmission probability for the ConstantTransmissionRate. Returns the transmission_rate for all individuals who have not been infected in the past. If the individual has already recovered, the function returns 0.0, assuming full indefinite natural immunity.\n\nParameters\n\ntransFunc::ConstantTransmissionRate: Transmission function struct\ninfecter::Individual: Infecting individual\ninfected::Individual: Individual to infect\nsetting::Setting: Setting in which the infection happens\ntick::Int16: Current tick\nrng::AbstractRNG: RNG used for probability. Uses Random's default RNG as default.\n\nReturns\n\nFloat64: Transmission probability p (0 <= p <= 1)\n\n\n\n\n\ntransmission_probability(transFunc::AgeDependentTransmissionRate, infecter::Individual, infected::Individual, setting::Setting, tick::Int16; rng::AbstractRNG = Random.default_rng())\n\nCalculates the transmission probability for the AgeDependentTransmissionRate. Selects the correct distribution  dependent on the age of the potentially infected agent from the AgeDependentTransmissionRate, draws from it and returns the value. If no age group is found for the individual the transmission rate is drawn from the transmission_rate distribution. If the individual has already recovered, the function returns 0.0, assuming full indefinite natural immunity.\n\nParameters\n\ntransFunc::AgeDependentTransmissionRate: Transmission function struct\ninfecter::Individual: Infecting individual\ninfected::Individual: Individual to infect\nsetting::Setting: Setting in which the infection happens\ntick::Int16: Current tick\nrng::AbstractRNG: RNG used for probability. Uses Random's default RNG as default.\n\nReturns\n\nFloat64: Transmission probability p (0 <= p <= 1)\n\n\n\n\n\n","category":"function"},{"location":"api_infections/#GEMS.try_to_infect!","page":"Infections and Immunity","title":"GEMS.try_to_infect!","text":"try_to_infect!(infctr::Individual, infctd::Individual, sim::Simulation, pathogen::Pathogen, setting::Setting;\n    source_infection_id::Int32 = DEFAULT_INFECTION_ID)\n\nTries to infect the infctd with the given pathogen transmitted by infctrat time tick(sim) with sim  being the simulation. Success depends on whether the agent is alive, not already infected an whether an infection event was sampled using the provided distribution or probability. Returns true if infection was successful.\n\nParameters\n\ninfctr::Individual: Infecting individual\ninfctd::Individual: Individual to infect\nsim::Simulation: Simulation object\npathogen::Pathogen: Pathogen to infect the individual with\nsetting::Setting: Setting this infection happens in\nsource_infection_id::Int32 = DEFAULT_INFECTION_ID (optional): Current infection ID of the infecting individual\n\nReturns\n\nBool: True if infection was successful, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"api_infections/#GEMS.update_individual!-Tuple{Individual, Int16, Simulation}","page":"Infections and Immunity","title":"GEMS.update_individual!","text":"update_individual!(indiv::Individual, tick::Int16, sim::Simulation)\n\nUpdate the individual disease progression, handle its recovery and log its possible death. If the individual is not infected, this function will just return.\n\nParameters\n\nindiv::Individual: Individual to update\ntick::Int16: Current tick\nsim::Simulation: Simulation object\n\n\n\n\n\n","category":"method"},{"location":"tut_configfiles/#advanced","page":"6 - Advanced Parameterization","title":"6 - Advanced Parameterization","text":"","category":"section"},{"location":"tut_configfiles/","page":"6 - Advanced Parameterization","title":"6 - Advanced Parameterization","text":"The Simulation() function provides a large varitey of optional arguments to parameterize models. However, in some cases, you might want to change how disease progressions are calculated, how contacts are sampled, or how infections happen. In those cases, we use so-called config files to pass advanced parameterizations to the GEMS engine. Config files are also useful to keep track of all your custom parameters in one file. This tutorial shows you how what you can do with them.","category":"page"},{"location":"tut_configfiles/#Using-Config-Files","page":"6 - Advanced Parameterization","title":"Using Config Files","text":"","category":"section"},{"location":"tut_configfiles/","page":"6 - Advanced Parameterization","title":"6 - Advanced Parameterization","text":"Config files use the *.TOML notation. When working with the Simulation() function to create a simulation, you can either use keyword arguments or a config file. Therefore, when you use a config file, you need to make sure that all parameters you want to pass are contained in the file. Please look up the config file documentation to learn how to construct config files.","category":"page"},{"location":"tut_configfiles/","page":"6 - Advanced Parameterization","title":"6 - Advanced Parameterization","text":"If you have a config file, here's how you load it in GEMS:","category":"page"},{"location":"tut_configfiles/","page":"6 - Advanced Parameterization","title":"6 - Advanced Parameterization","text":"using GEMS\nsim = Simulation(\"path/to/my/config-file.toml\")","category":"page"},{"location":"tut_configfiles/#Age-Stratified-Disease-Progression","page":"6 - Advanced Parameterization","title":"Age-Stratified Disease Progression","text":"","category":"section"},{"location":"tut_configfiles/#Custom-Start-Conditions","page":"6 - Advanced Parameterization","title":"Custom Start Conditions","text":"","category":"section"},{"location":"tut_configfiles/#custom-contacts","page":"6 - Advanced Parameterization","title":"Custom Contact Sampling","text":"","category":"section"},{"location":"tut_configfiles/#custom-transmission","page":"6 - Advanced Parameterization","title":"Custom Transmission Functions","text":"","category":"section"},{"location":"api_settings/#Settings","page":"Settings","title":"Settings","text":"","category":"section"},{"location":"api_settings/#Overview-Structs","page":"Settings","title":"Overview Structs","text":"","category":"section"},{"location":"api_settings/","page":"Settings","title":"Settings","text":"Pages   = [\"api_settings.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_settings/#Overview-Functions","page":"Settings","title":"Overview Functions","text":"","category":"section"},{"location":"api_settings/","page":"Settings","title":"Settings","text":"Pages   = [\"api_settings.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_settings/#Structs","page":"Settings","title":"Structs","text":"","category":"section"},{"location":"api_settings/#GEMS.ContainerSetting","page":"Settings","title":"GEMS.ContainerSetting","text":"Supertype for all simulation settings which act as containers of settings.\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#GEMS.Department","page":"Settings","title":"GEMS.Department","text":"Department <: ContainerSetting\n\nRepresents a department within a workplace in the simulation.\n\nInstantiation\n\nThe instantiation requires at least an id that be supplied as a keyword argument. All other fields are optional parameters.\n\nd1 = Department(id = 1)\nd2 = Department(id = 2, contains = [13, 14, 15]) # contains IDs of Offices\n\nParameters\n\nid::Int32: Unique identifier of the department.\ncontains::Vector{Int32} = [] (optional): List of associated Offices\ncontains_type::DataType = Office (optional): Type of contained settings (Office)\ncontained::Int32 = DEFAULT_SETTING_ID (optional): Parent setting id (Workplace)\ncontained_type::DataType = Workplace (optional): Parent setting type (Workplace)\ntype::Int32 = -1 (optional): Numerical code representing the type of department.\nlast_infectious::Int16 = -1 (optional): The last simulation tick when an infectious individual was present.\ncontact_sampling_method::ContactSamplingMethod = RandomSampling() (optional):   Sampling Method, defining how contacts are drawn.\nisactive::Bool = false (optional): Whether the department is active in the simulation.\nisopen::Bool = true (optional): Whether the setting is open for contacts.\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#GEMS.GlobalSetting","page":"Settings","title":"GEMS.GlobalSetting","text":"GlobalSetting <: IndividualSetting\n\nA type to a setting that contains all individuals at once (mainly for testing purposes). With this type, each individual can theoretically connect with any other individual.\n\nThere should only be one GlobalSetting instance in any simulation.\n\nFields\n\nindividuals::Vector{Individual}: List of associated individuals\ncontact_sampling_method::ContactSamplingMethod: Sampling Method, defining how contacts are drawn.\nisactive::Bool: A flag to represent if the setting is considered active for simulation\nisopen::Bool: Whether the setting is open for contacts.\nlock::ReentrantLock: A lock to use in a parallelized setting to ensure data race free   conditions\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#GEMS.Household","page":"Settings","title":"GEMS.Household","text":"Household <: Geolocated\n\nA type to represent households with associated individuals as members.\n\nInstantiation\n\nThe instantiation requires at least an id that be supplied as a keyword argument. All other fields are optional parameters.\n\nh1 = Household(id = 1)\nh2 = Household(id = 2, individuals = [i1, i2, i3])\n\nParameters\n\nid::Int32: Unique identifier of the household\nindividuals::Vector{Individual} = [] (optional): List of associated individuals\nincome::Int8 = -1 (optional): Category of income for the household\ndwelling::Int8 = -1  *(optional)*: Category of dwelliung size\nlast_infectious::Int16 = -1 (optional): Tick indicating the last presence of an infected individual\ncontact_sampling_method::ContactSamplingMethod = RandomSampling() (optional):   Sampling Method, defining how contacts are drawn.\nags::AGS = AGS() (optional): The Amtlicher Gemeindeschlüssel (AGS) of the Household.\nlon::Float32 = NaN (optional): Longitude of the household\nlat::Float32 = NaN: Latitude of the household\nisactive::Bool = false (optional): A flag to represent if the setting is considered active for simulation\nisopen::Bool = true (optional): Whether the setting is open for contacts.\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#GEMS.IndividualSetting","page":"Settings","title":"GEMS.IndividualSetting","text":"Supertype for all simulation settings which directly contain individuals.\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#GEMS.Municipality","page":"Settings","title":"GEMS.Municipality","text":"Municipality <: IndividualSetting\n\nA type to represent (geographical) municipalities.\n\nInstantiation\n\nThe instantiation requires at least an id that be supplied as a keyword argument. All other fields are optional parameters.\n\nm1 = Municipality(id = 1)\nm2 = Municipality(id = 2, individuals = [i1, i2, i3])\n\nParameters\n\nid::Int32: Unique identifier of the municipality\nindividuals::Vector{Individual} = [] (optional): List of associated individuals\ncontact_sampling_method::ContactSamplingMethod = RandomSampling() (optional): Sampling Method, defining how contacts are drawn.\nags::AGS = AGS() (optional): The Amtlicher Gemeindeschlüssel (AGS) of the municipality.\nisactive::Bool = false (optional): A flag to represent if the setting is considered active for simulation\nisopen::Bool = true (optional): Whether the setting is open for contacts.\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#GEMS.Office","page":"Settings","title":"GEMS.Office","text":"Office <: Geolocated\n\nRepresents an office within a department in the simulation.\n\nInstantiation\n\nThe instantiation requires at least an id that be supplied as a keyword argument. All other fields are optional parameters.\n\no1 = Office(id = 1)\no2 = Office(id = 2, individuals = [i1, i2, i3])\n\nParameters\n\nid::Int32: Unique identifier of the office.\nindividuals::Vector{Individual} = [] (optional): List of individuals associated with this office\ncontained::Int32 = DEFAULT_SETTING_ID (optional): Parent setting id (Department) \ncontained_type::DataType = Department (optional): Parent setting tye (Department)\ntype::Int32 = -1 (optional): Numerical code representing the type of office\nlast_infectious::Int16 = -1 (optional): The last simulation tick when an infectious individual was present\ncontact_sampling_method::ContactSamplingMethod = RandomSampling() (optional):   Sampling Method, defining how contacts are drawn\nags::AGS = AGS() (optional): The Amtlicher Gemeindeschlüssel (AGS) of the office\ninroom::Int8 = -1 (optional): Describes the amount of indoor work done in the office\nworkhome::Int8 = -1 (optional): Describes the amount of work done from home\nlon::Float32 = NaN (optional): Longitude of the office\nlat::Float32 = NaN (optional): Latitude of the office\nisactive::Bool = false (optional): Whether the office is active in the simulation\nisopen::Bool = true (optional): Whether the setting is open for contacts\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#GEMS.School","page":"Settings","title":"GEMS.School","text":"School <: ContainerSetting\n\nA type to represent a school (which has years and classes).\n\nInstantiation\n\nThe instantiation requires at least an id that be supplied as a keyword argument. All other fields are optional parameters.\n\ns1 = School(id = 1)\ns2 = School(id = 2, contains = [13, 14, 15]) # contains IDs of school years\n\nParameters\n\nid::Int32: Unique identifier of the school\ncontains::Vector{Int32} = [] (optional): List of associated SchoolYearss\ncontains_type::DataType = SchoolYear (optional): Type of contained settings (SchoolYear)\ncontained::Int32 = DEFAULT_SETTING_ID (optional):  Parent setting id (SchoolComplex)\ncontained_type::DataType = School (optional): Parent setting tye (SchoolComplex)\ntype::Int32 = -1 (optional): Type of school (e.g. primary, highschool, ...)\ncontact_sampling_method::ContactSamplingMethod = RandomSampling() (optional): Sampling Method, defining how contacts are drawn.\nisactive::Bool = false (optional): A flag to represent if the setting is considered active for simulation\nisopen::Bool = true (optional): Whether the setting is open for contacts.\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#GEMS.SchoolClass","page":"Settings","title":"GEMS.SchoolClass","text":"SchoolClass <: Geolocated\n\nA type to represent school classes. Should always be part of a school.\n\nInstantiation\n\nThe instantiation requires at least an id that be supplied as a keyword argument. All other fields are optional parameters.\n\nc1 = SchoolClass(id = 1)\nc2 = SchoolClass(id = 2, individuals = [i1, i2, i3])\n\nParameters\n\nid::Int32: Unique identifier of the school class\nindividuals::Vector{Individual} = [] (optional): List of associated individuals\ntype::Int32 = -1 (optional): Type of school class (e.g. grade)\ncontained::Int32 = DEFAULT_SETTING_ID (optional): Parent setting id (SchoolYear) \ncontained_type::DataType = SchoolYear (optional): Parent setting tye (SchoolYear)\nlast_infectious::Int16 = -1 (optional): Tick indicating the last presence of an infected individual\ncontact_sampling_method::ContactSamplingMethod = RandomSampling() (optional):   Sampling Method, defining how contacts are drawn.\nags::Int32 = AGS() (optional): The Amtlicher Gemeindeschlüssel (AGS) of the schoolclass.\nlon::Float32 = NaN (optional): Longitude of the schoolclass\nlat::Float32 = NaN (optional): Latitude of the schoolclass\nisactive::Bool = false (optional): A flag to represent if the setting is considered active for simulation\nisopen::Bool = true (optional): Whether the setting is open for contacts.\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#GEMS.SchoolComplex","page":"Settings","title":"GEMS.SchoolComplex","text":"SchoolComplex <: ContainerSetting\n\nA type to represent a school complex (which has schools).\n\nInstantiation\n\nThe instantiation requires at least an id that be supplied as a keyword argument. All other fields are optional parameters.\n\nsc1 = SchoolComplex(id = 1)\nsc2 = SchoolComplex(id = 2, contains = [13, 14, 15]) # contains IDs of schools\n\nParameters\n\nid::Int32: Unique identifier of the school complex\ncontains::Vector{Int32} = [] (optional): List of associated Schools\ncontains_type::DataType = SchoolYear (optional): Type of contained settings (School)\ncontact_sampling_method::ContactSamplingMethod = RandomSampling() (optional): Sampling Method, defining how contacts are drawn.\nisactive::Bool = false (optional): A flag to represent if the setting is considered active for simulation\nisopen::Bool = true (optional): Whether the setting is open for contacts.\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#GEMS.SchoolYear","page":"Settings","title":"GEMS.SchoolYear","text":"SchoolYear <: ContainerSetting\n\nA type to represent a schoolyear (which has classes).\n\nInstantiation\n\nThe instantiation requires at least an id that be supplied as a keyword argument. All other fields are optional parameters.\n\ny1 = SchoolYear(id = 1)\ny2 = SchoolYear(id = 2, contains = [13, 14, 15]) # contains IDs of school classes\n\nParameters\n\nid::Int32: Unique identifier of the schoolyear\ncontains::Vector{Int32} = [] (optional): List of associated SchoolClasses\ncontains_type::DataType = SchoolClass (optional): Type of contained settings (SchoolClass)\ncontained::Int32 = DEFAULT_SETTING_ID (optional):  Parent setting id (School)\ncontained_type::DataType = School (optional): Parent setting tye (School)\ntype::Int32 = -1 (optional): Type of school year (e.g. grade)\ncontact_sampling_method::ContactSamplingMethod = RandomSampling() (optional): Sampling Method, defining how contacts are drawn.\nisactive::Bool = false (optional): A flag to represent if the setting is considered active for simulation\nisopen::Bool = true (optional): Whether the setting is open for contacts.\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#GEMS.Setting","page":"Settings","title":"GEMS.Setting","text":"Supertype for all simulation settings\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#GEMS.SettingsContainer","page":"Settings","title":"GEMS.SettingsContainer","text":"SettingsContainer\n\nA container structure for all settings.\n\nFields\n\nsettings::Dict{DataType, Vector{Setting}}: A dictionary holding all known settings   structured by type\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#GEMS.Workplace","page":"Settings","title":"GEMS.Workplace","text":"Workplace <: ContainerSetting\n\nRepresents a workplace in the simulation.\n\nInstantiation\n\nThe instantiation requires at least an id that be supplied as a keyword argument. All other fields are optional parameters.\n\nws1 = Workplace(id = 1)\nws2 = Workplace(id = 2, contains = [13, 14, 15]) # contains IDs of Departments\n\nParameters\n\nid::Int32: Unique identifier of the workplace.\ncontains::Vector{Int32} = [] (optional): List of associated Departments\ncontains_type::DataType = Department (optional): Type of contained settings (Department)\ncontained::Int32 = DEFAULT_SETTING_ID (optional): Parent setting id (WorkplaceSite)\ncontained_type::DataType = WorkplaceSite (optional): Parent setting type (WorkplaceSite)\ntype::Int32 = -1 (optional): Numerical code representing the type of workplace (e.g., farm, office).\nlast_infectious::Int16 -1 (optional): The last simulation tick when an infectious individual was present.\ncontact_sampling_method::ContactSamplingMethod = RandomSampling() (optional):   Sampling Method, defining how contacts are drawn.\nisactive::Bool = false (optional): Whether the workplace is active in the simulation.\nisopen::Bool = true (optional): Whether the setting is open for contacts.\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#GEMS.WorkplaceSite","page":"Settings","title":"GEMS.WorkplaceSite","text":"WorkplaceSite <: ContainerSetting\n\nRepresents a Workplace site in the simulation.\n\nInstantiation\n\nThe instantiation requires at least an id that be supplied as a keyword argument. All other fields are optional parameters.\n\nws1 = WorkplaceSite(id = 1)\nws2 = WorkplaceSite(id = 2, contains = [13, 14, 15]) # contains IDs of Workplaces\n\nParameters\n\nid::Int32: Unique identifier of the workplace.\ncontains::Vector{Int32} = [] (optional): List of associated Workplaces\ncontains_type::DataType = Workplace (optional): Type of contained settings (Workplace)\ntype::Int32 = -1 (optional): Numerical code representing the type of workplace site.\nlast_infectious::Int16 = -1 (optional): The last simulation tick when an infectious individual was present.\ncontact_sampling_method::ContactSamplingMethod = RandomSampling() (optional): Sampling Method, defining how contacts are drawn.\nisactive::Bool = false (optional): Whether the workplace is active in the simulation.\nisopen::Bool = true (optional): Whether the setting is open for contacts.\n\n\n\n\n\n","category":"type"},{"location":"api_settings/#Functions","page":"Settings","title":"Functions","text":"","category":"section"},{"location":"api_settings/#GEMS.activate!","page":"Settings","title":"GEMS.activate!","text":"activate!(setting::Setting)\n\nSets the setting active for simulation.\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.add!-Tuple{IndividualSetting, Individual}","page":"Settings","title":"GEMS.add!","text":"add!(setting::Setting, individual::Individual)\n\nAdds the given individual to the setting.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.add!-Tuple{SettingsContainer, Setting}","page":"Settings","title":"GEMS.add!","text":"add!(container::SettingsContainer, setting::Setting)\n\nAdd a setting to the container.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.add_type!","page":"Settings","title":"GEMS.add_type!","text":"add_type!(container::SettingsContainer, settingtype::Type)\n\nAdd a settingtype to the container if it is not yet included.  Creates a new vector for the provided type in the settings dictionary.\n\n\n\n\n\nadd_type!(container::SettingsContainer, settingtype::DataType)\n\nAdd a settingtype to the container if it is not yet included.  Creates a new vector for the provided type in the settings dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.add_types!","page":"Settings","title":"GEMS.add_types!","text":"add_types!(container::SettingsContainer, settingtypes::Vector{Type})\n\nAdds settingtypes to the container if they are not yet included.  Calls the add_type! function for each settingtype in the vector.\n\n\n\n\n\nadd_types!(container::SettingsContainer, settingtypes::Vector{DataType})\n\nAdds settingtypes to the container if they are not yet included.  Calls the add_type! function for each settingtype in the vector.\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.ags-Tuple{ContainerSetting, Simulation}","page":"Settings","title":"GEMS.ags","text":"ags(stng::ContainerSetting, sim::Simulation)\n\nGet the ags of a ContainerSetting.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.ags-Tuple{IndividualSetting, Simulation}","page":"Settings","title":"GEMS.ags","text":"ags(stng::IndividualSetting, sim::Simulation)\n\nGet the ags of a IndividualSetting.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.ags-Tuple{IndividualSetting}","page":"Settings","title":"GEMS.ags","text":"ags(stng::IndividualSetting)\n\nGet the ags of a IndividualSetting.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.avg_individuals","page":"Settings","title":"GEMS.avg_individuals","text":"avg_individuals(stngs::Vector{Setting}, simulation::Simulation)\n\nReturns the average number of individuals across all provided settings.\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.close!","page":"Settings","title":"GEMS.close!","text":"close!(setting::Setting)\n\nCloses the setting.\n\n\n\n\n\nclose!(setting::Setting, simulation::Simulation)\n\nSets the setting and all settings contained by it as closed (not open).\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.contact_sampling_method!","page":"Settings","title":"GEMS.contact_sampling_method!","text":"contact_sampling_method(setting::Setting, csm::ContactSamplingMethod)\n\nSets the ContactSamplingMethod of this setting to the provided method.\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.contact_sampling_method","page":"Settings","title":"GEMS.contact_sampling_method","text":"contact_sampling_method(setting::Setting)\n\nReturns ContactSamplingMethod of this setting.\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.contained-Tuple{Setting}","page":"Settings","title":"GEMS.contained","text":"contained(setting::Setting)\n\nReturns the contained value of the given Setting.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.contained_type-Tuple{Setting}","page":"Settings","title":"GEMS.contained_type","text":"contained_type(setting::Setting)\n\nReturns the contained_type value of the given Setting.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.contains_type-Tuple{ContainerSetting}","page":"Settings","title":"GEMS.contains_type","text":"contains_type(setting::ContainerSetting)\n\nReturns the contains_type value of the given ContainerSetting.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.deactivate!-Tuple{Setting}","page":"Settings","title":"GEMS.deactivate!","text":"deactivate!(setting::Setting)\n\nSets the setting as inactive for simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.delete_dangling_ids!-Tuple{SettingsContainer}","page":"Settings","title":"GEMS.delete_dangling_ids!","text":"delete_dangling_ids!(cntnr::SettingsContainer)\n\nSets all dangling IDs, i.e., IDs that do not point to any setting, to the default setting ID.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.geolocation","page":"Settings","title":"GEMS.geolocation","text":"geolocation(stng::ContainerSetting, sim::Simulation)\n\nGet the location of a ContainerSetting by getting the location of the first contained setting.\n\n\n\n\n\ngeolocation(stng::IndividualSetting, sim::Simulation)\n\nGet the location of a IndividualSetting. Fallback for non geolocated settings.\n\n\n\n\n\ngeolocation(stng::IndividualSetting)\n\nGet the location of a IndividualSetting. Fallback for non geolocated settings.\n\n\n\n\n\ngeolocation(stng::IndividualSetting, sim::Simulation)\n\nGet the location of a IndividualSetting.\n\n\n\n\n\ngeolocation(stng::IndividualSetting)\n\nGet the location of a IndividualSetting.\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.get_contained!","page":"Settings","title":"GEMS.get_contained!","text":"get_contained!(stng::Setting, dct::Dict{DataType, Vector{Int32}}, sim::Simulation)\n\nRecursively gets the contained settings of the setting stng and adds them to the dictionary dct.\n\nParameters\n\nstng::ContainerSetting: Setting that may contain more settings on lower levels\ndct::Dict{DataType, Vector{Int32}}: Dictionary that will be filed with the found settings\nsim::Simulation: Simulation object\n\n\n\n\n\nget_contained!(stng::IndividualSetting, dct::Dict, sim::Simulation)\n\nGets the contained settings of an IndividualSetting, i.e., none.\n\nParameters\n\nstng::IndividualSetting: Lowest-level setting\ndct::Dict{DataType, Vector{Int32}}: Dictionary that will be filed with the found settings\nsim::Simulation: Simulation object\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.get_containers!","page":"Settings","title":"GEMS.get_containers!","text":"get_containers!(stng::Setting, dct::Dict{DataType, Int32}, sim::Simulation)\n\nRecursively gets the containers of the setting stng and adds them to the dictionary dct.\n\nParameters\n\nstng::Setting: Setting to get upper-level settings for\ndct::Dict{DataType, Vector{Int32}}: Dictionary that will be filed with the found settings\nsim::Simulation: Simulation object\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.get_open_contained!","page":"Settings","title":"GEMS.get_open_contained!","text":"get_open_contained!(stng::ContainerSetting, dct::Dict{DataType, Vector{Int32}}, sim::Simulation)\n\nRecursively gets the contained settings of the setting stng and adds them to the dictionary dct if the containing setting is open.\n\nParameters\n\nstng::ContainerSetting: Setting that may contain more settings on lower levels\ndct::Dict{DataType, Vector{Int32}}: Dictionary that will be filed with the found settings\nsim::Simulation: Simulation object\n\n\n\n\n\nget_open_contained!(stng::IndividualSetting, dct::Dict{DataType, Vector{Int32}}, sim::Simulation)\n\nAdds the individualsetting to the provided dictionary if it is open.\n\nParameters\n\nstng::IndividualSetting: Lowest-level setting\ndct::Dict{DataType, Vector{Int32}}: Dictionary that will be filed with the found settings\nsim::Simulation: Simulation object\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.household-Tuple{Individual, Simulation}","page":"Settings","title":"GEMS.household","text":"household(i::Individual, sim::Simulation)::Household\n\nReturns the Household instance referenced in an individual. \n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.id-Tuple{Setting}","page":"Settings","title":"GEMS.id","text":"id(setting::Setting)\n\nReturns the unique identifier of the setting.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.individuals!","page":"Settings","title":"GEMS.individuals!","text":"individuals!(setting::IndividualSetting, indivs::Vector{Individual}, simulation::Simulation)\n\nAppends the individuals associated with a given IndividualSetting to the provided indivs vector.\n\nParameters\n\nsetting::IndividualSetting: Setting to get the individuals from\nindivs::Vector{Individual}: List that will be appeneded with the setting's individuals\nsimulation::Simulation: Simulation object\n\n\n\n\n\nindividuals!(setting::ContainerSetting, indivs::Vector{Individual}, simulation::Simulation)\n\nAppends the individuals associated with a given ContainerSetting to the provided indivs vector by recursively calling the individuals! function. \n\nParameters\n\nsetting::ContainerSetting: Setting to get the individuals from\nindivs::Vector{Individual}: List that will be appeneded with the setting's individuals\nsimulation::Simulation: Simulation object\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.individuals-Tuple{IndividualSetting}","page":"Settings","title":"GEMS.individuals","text":"individuals(setting::IndividualSetting)\n\nReturns the individuals associated with the given setting.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.individuals-Tuple{IndividualSetting, Simulation}","page":"Settings","title":"GEMS.individuals","text":"individuals(setting::IndividualSetting, simulation::Simulation)\n\nReturns the individuals associated with a given IndividualSetting.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.individuals-Tuple{ContainerSetting, Simulation}","page":"Settings","title":"GEMS.individuals","text":"individuals(setting::ContainerSetting, indivs::Vector{Individual}, simulation::Simulation)::Vector{Individual}\n\nReturns the individuals associated with a given ContainerSetting by recursively getting the individuals of  all contained settings using the individuals! function.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.is_open-Tuple{Setting}","page":"Settings","title":"GEMS.is_open","text":"isopen(setting::Setting)\n\nReturns wether the setting is opened (contacts can occur) or not. Without considering its containers.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.isactive-Tuple{Setting}","page":"Settings","title":"GEMS.isactive","text":"isactive(setting::Setting)\n\nReturns whether the setting is considered active for simulation, e.g. an infection could spread in the setting.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.lat-Tuple{Geolocated}","page":"Settings","title":"GEMS.lat","text":"lat(stng::Geolocated)\n\nReturns latitude of geolocated setting.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.lon-Tuple{Geolocated}","page":"Settings","title":"GEMS.lon","text":"lon(stng::Geolocated)\n\nReturns longitude of geolocated setting.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.max_individuals-Tuple{Vector{Setting}, Simulation}","page":"Settings","title":"GEMS.max_individuals","text":"max_individuals(stngs::Vector{Setting}, simulation::Simulation)\n\nReturns the maximum number of individuals across all provided settings.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.min_individuals-Tuple{Vector{Setting}, Simulation}","page":"Settings","title":"GEMS.min_individuals","text":"min_individuals(stngs::Vector{Setting}, simulation::Simulation)\n\nReturns the minimum number of individuals across all provided settings.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.min_max_avg_individuals-Tuple{Vector{Setting}, Simulation}","page":"Settings","title":"GEMS.min_max_avg_individuals","text":"min_max_avg_individuals(stngs::Vector{Setting}, simulation::Simulation)\n\nReturns a three-way tuple with (minimum, maximum, mean) number of individuals associated with  a setting in the provided stngs vector.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.new_setting_ids!-Tuple{SettingsContainer, Dict}","page":"Settings","title":"GEMS.new_setting_ids!","text":"new_setting_ids!(cntnr::SettingsContainer, renaming_dict::Dict = Dict())\n\nThis function checks and updates the ids of settings in a SettingsContainer object  to ensure that they are continuous and start from 1. If the ids are not continuous  or do not start from 1, the function will generate a warning and update the ids accordingly. This is then also used to update the contained and contains fields of the settings.\n\nArguments\n\ncntnr::SettingsContainer: The SettingsContainer object containing the settings.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.open!","page":"Settings","title":"GEMS.open!","text":"open!(setting::Setting)\n\nOpens the setting.\n\n\n\n\n\nopen!(setting::Setting, simulation::Simulation)\n\nSets the setting and all settings contained by it as open.\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.present_individuals","page":"Settings","title":"GEMS.present_individuals","text":"present_individuals(setting::IndividualSetting, simulation::Simulation)\n\nReturns the individuals present in a given IndividualSetting, i.e., only those in open settings. \n\n\n\n\n\npresent_individuals(setting::ContainerSetting, simulation::Simulation)\n\nReturns the individuals present in a given ContainerSetting, i.e., only those in open contained settings. \n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.present_individuals!","page":"Settings","title":"GEMS.present_individuals!","text":"present_individuals!(setting::IndividualSetting, indivs::Vector{Individual}, simulation::Simulation)\n\nPushes the individuals present in a given IndividualSetting, i.e., only those in open settings to the provided indivs vector. \n\nParameters\n\nsetting::IndividualSetting: Setting to get the individuals from\nindivs::Vector{Individual}: List that will be appeneded with the setting's individuals\nsimulation::Simulation: Simulation object\n\n\n\n\n\npresent_individuals!(setting::ContainerSetting, indivs::Vector{Individual}, simulation::Simulation)\n\nPushes the individuals present in a given ContainerSetting, i.e., only those in open contained settings to the provided indivs vector.  \n\nParameters\n\nsetting::ContainerSetting: Setting to get the individuals from\nindivs::Vector{Individual}: List that will be appeneded with the setting's individuals\nsimulation::Simulation: Simulation object\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.schoolclass-Tuple{Individual, Simulation}","page":"Settings","title":"GEMS.schoolclass","text":"schoolclass(i::Individual, sim::Simulation)::SchoolClass\n\nReturns the SchoolClass instance referenced in an individual. \n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.sample_individuals","page":"Settings","title":"GEMS.sample_individuals","text":"sample_individuals(individuals::Vector{Individual}, n::Int64; rng::AbstractRNG = Random.default_rng())\n\nReturns a subsample of a vector of Individuals of sample size n.\n\n\n\n\n\nsample_individuals(setting::IndividualSetting, n::Int64; rng::AbstractRNG = Random.default_rng())\n\nReturns a subsample of the setting's Individuals of sample size n.\n\n\n\n\n\n","category":"function"},{"location":"api_settings/#GEMS.setting-Tuple{SettingsContainer, DataType, Int32}","page":"Settings","title":"GEMS.setting","text":"setting(container::SettingsContainer, type::DataType, id::Int32)\n\nReturns a particular setting of a particular type and ID.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.settingchar-Tuple{Setting}","page":"Settings","title":"GEMS.settingchar","text":"settingchar(setting::Setting)\n\nReturns a character that represents the type of setting.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.settings-Tuple{SettingsContainer}","page":"Settings","title":"GEMS.settings","text":"settings(container::SettingsContainer)\n\nReturns a dictionary with all concrete setting types as keys and vectors of all known  settings as values. \n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.settings-Tuple{SettingsContainer, DataType}","page":"Settings","title":"GEMS.settings","text":"settings(container::SettingsContainer, type::DataType)\n\nReturns a vector of all known settings with provided type. \n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.settings_from_jld2!-Tuple{String, SettingsContainer, Dict}","page":"Settings","title":"GEMS.settings_from_jld2!","text":"settings_from_jld2!(jld2file::String, cntnr::SettingsContainer, d::Dict= Dict())\n\nLoads the settings saved in jld2file and add them to the existing SettingsContainer. The renaming dictionary is used to find the correct updated values of the ids of the IndividualSettings and change the values in the containers accordingly. If the jld2file does not correspond to \"\" (corresponding to no settingfile) and does not exist, an error message is printed.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.settings_from_population-Tuple{Population, Bool}","page":"Settings","title":"GEMS.settings_from_population","text":"settings_from_population(population::Population, global_setting::Bool = false)\n\nCreates all settings defined by the attributes of the individuals inside a given population. Return a dictionary with all known concrete setting types as keys and a vector of created settings.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.settingstring-Tuple{Char}","page":"Settings","title":"GEMS.settingstring","text":"settingstring(c::Char)\n\nReturns a string that represents the type of setting based on a char that is returned from  the function settingchar.\n\n\n\n\n\n","category":"method"},{"location":"api_settings/#GEMS.settingtypes","page":"Settings","title":"GEMS.settingtypes","text":"settingtypes(container::SettingsContainer)\n\nReturns all known setting types of the provided container.\n\n\n\n\n\n","category":"function"},{"location":"docstrings-overview/#API","page":"Overview","title":"API","text":"","category":"section"},{"location":"docstrings-overview/","page":"Overview","title":"Overview","text":"This is an overview of all functions, structs, and constructors, i.e., a collection of the docstrings. Please consult the following pages to find information about the respective topics.","category":"page"},{"location":"docstrings-overview/","page":"Overview","title":"Overview","text":"Section Description\nBatches Structs and Functions used for running different scenarios (a batch of simulations).\nContacts Structs and Functions used for creating and analyzing contact structures within the simulation.\nIndividuals Individual agents and all related structs and functions for their behavior and characteristics.\nInfections and Immunity Transmission and infection related functions.\nInterventions Structs and functions used to created and apply intervention strategies (vaccinations, NPIs, measures, strategies).\nLogger Different logger.\nMapping Creating an infection map.\nMisc Misc. Helper functions, AGS-related functions and validation.\nMovie Creating an infection dynamics movie.\nPathogens Structs and functions related to the pathogens of the simulation.\nPlotting Creating plots based on simulation runs and output data.\nPopulation Collections of individuals of a simulation.\nPost Processing Data processing features supplying reports, plots, or other data analyses.\nReporting Creating simulation reports.\nResult Data All processed data of a simulation run.\nSettings Structs and functions to specify the settings (households, schools, workplaces) within one simulation.\nSimulation Management of a simulation run, holding all necessary information.","category":"page"},{"location":"tut_Intro/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tut_Intro/","page":"Tutorials","title":"Tutorials","text":"In this section, step by step tutorials will guide you through the different possibilities of GEMS. ","category":"page"},{"location":"tut_Intro/","page":"Tutorials","title":"Tutorials","text":"Pages = [\n    \"tut_gettingstarted.md\",\n    \"tut_exploring.md\",\n    \"tut_plotting.md\",\n    \"tut_batches.md\",\n    \"tut_pops.md\",\n    \"tut_configfiles.md\",\n    \"tut_postprocessing.md\",\n    \"tut_reporting.md\",\n    \"tut_npi.md\",\n    #\"tut_behavior.md\",\n    #\"tut_contacts.md\",\n    #\"tut_infections.md\",\n    \"cheat-sheet.md\"\n    ]\nDepth = 2","category":"page"},{"location":"api_reporting/#Reporting","page":"Reporting","title":"Reporting","text":"","category":"section"},{"location":"api_reporting/#Overview-Structs","page":"Reporting","title":"Overview Structs","text":"","category":"section"},{"location":"api_reporting/","page":"Reporting","title":"Reporting","text":"Pages   = [\"api_reporting.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_reporting/#Overview-Functions","page":"Reporting","title":"Overview Functions","text":"","category":"section"},{"location":"api_reporting/","page":"Reporting","title":"Reporting","text":"Pages   = [\"api_reporting.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_reporting/#Structs","page":"Reporting","title":"Structs","text":"","category":"section"},{"location":"api_reporting/#GEMS.AbstractSection","page":"Reporting","title":"GEMS.AbstractSection","text":"Supetype for all report sections\n\n\n\n\n\n","category":"type"},{"location":"api_reporting/#GEMS.BatchReport","page":"Reporting","title":"GEMS.BatchReport","text":"BatchReport <: Report\n\nA Type for generating a batch-run simulation report.\n\nFields\n\nBatch Data\n\nbd::BatchData: Batch data object used to generate this report\n\nMeta Information\n\ntitle::String: Report title\nsubtitle::String: Report subtitle\nauthor::String: Report authors\ndate::String: Simulation execution date (post processing)\nabstract::String: Report abstract\n\nConfiguration\n\nglossary::Bool: flag to add or remove glossary with term definitions\ndpi::Int64: dots per inch for report plots (default: 300)\nfontfamily::String: font family for report (default: Times New)\n\n\n\n\n\n","category":"type"},{"location":"api_reporting/#GEMS.PlotSection","page":"Reporting","title":"GEMS.PlotSection","text":"PlotSection <: AbstractSection\n\nThis type wraps a ReportPlot into an AbstractSection struct. Thus the only field is a report plot. Its mainly used to add plots to reports. You can look up the aviailable default report styles to get an idea how that might look like.\n\nYou can either pass an instance of a SimulationPlot to the constructor like:\n\nPlotSection(TickCases())\n\nor pass the SimulationPlot type as a Symbol like:\n\nPlotSection(:TickCases)\n\nThe gemsplot() function contains a comprehensive list on the available plot types.\n\n\n\n\n\n","category":"type"},{"location":"api_reporting/#GEMS.Report","page":"Reporting","title":"GEMS.Report","text":"Supertype for all simulation reports\n\n\n\n\n\n","category":"type"},{"location":"api_reporting/#GEMS.ReportPlot","page":"Reporting","title":"GEMS.ReportPlot","text":"Supertype for all plots that go into reports\n\n\n\n\n\n","category":"type"},{"location":"api_reporting/#GEMS.Section","page":"Reporting","title":"GEMS.Section","text":"Section(title::String = \"\", content::String = \"\", subsections::Vector{AbstractSection} = [])\nSection(rd::ResultData, type::Symbol)\nSection(rd::BatchData, type::Symbol)\n\nA type for Report Sections. All reports consist of (nested) sections. A report section will be parsed into a markdown section (indicated by \"#\"s) during report generation. Each section must have a title and content. It can have an arbitrary number of subsections.\n\nExample\n\nThis code creates two sections. The first one having a title and some content. The second section contains the first  secion as a subsection.\n\nsec_1 = Section(\n    title = \"My Section Title\",\n    content = \"Great section contents\"\n)\n\nsec_2 = Section(\n    title = \"My Second Section\n    subsections = [sec_1]\n)\n\nDefaut Sections\n\nThere are a number of default sections that you can simply plug into your report by calling the Section() constructor and pass a ResultData or BatchData object and a Symbol qualifying the type of section you'd like to get:\n\n# run simulation\nsim = Simulation()\nrun!(sim)\nrd = ResultData(sim)\n\noverview_section = Section(rd, :Overview)\n\nDefault Sections for Single Simulation Reports\n\nInput must be ResultData.\n\nType Title Content\n:Debug Debug Information Contains :Memory, :Processor,:Repo, and :System section.\n:General General Geeral simulation info; tick unit, start conditions, and others.\n:InputFiles Input Files Config- and population file paths.\n:Interventions Interventions Triggers, strategies, and measures.\n:Memory Memory Available and used system memory.\n:Model Model Configuration Contains :InputFiles, :Interventions, :General, :Pathogens, and :Settings\n:Observations Observations Summary of observed progression, detection rate, dark figure, and others.\n:Overview Overview Simulation summmary with initial infections, total attack rate, and others.\n:Pathogens Pathogens Pathogen configuration with one subsection per pathogen.\n:Processor Processor Processor model, cores, and others.\n:Repo Repository Current repo-, branch- and commit-ID.\n:Settings Settings Number of settings per type and min, max, average number of individuals.\n:System System Information Julia config, number of threads, and others.\n\nDefault Sections for Batch Reports\n\nInput must be BatchData.\n\nType Title Content\n:Allocations Allocations Summary statistics on memory usage across simulation runs in BatchData object.\n:Debug Debug Information Contains :Memory, :Processor,:Repo, and :System section.\n:General Genera Geeral simulation info; tick unit, start conditions, and others.\n:Memory Memory Available and used system memory.\n:Overview Overview Summary statistics on total infections, attack rates, and others.\n:Processor Processor Processor model, cores, and others.\n:Repo Repository Current repo-, branch- and commit-ID.\n:Resouces Resources Contains :Runtime and :Allocations sections.\n:Runtime Runtime Summary statistics on runtime across simulation runs in BatchData object.\n:Settings Settings Number of settings per type and min, max, average number of individuals.\n:System System Information Julia config, number of threads, and others.\n\n\n\n\n\n","category":"type"},{"location":"api_reporting/#GEMS.SimulationReport","page":"Reporting","title":"GEMS.SimulationReport","text":"SimulationReport <: Report\n\nA Type for generating a single-run simulation report.\n\nFields\n\nResult Data\n\nrd::ResultData: Result data object used to generate this report\n\nMeta Information\n\ntitle::String: Report title\nsubtitle::String: Report subtitle\nauthor::String: Report authors\ndate::String: Simulation execution date (post processing)\nabstract::String: Report abstract\n\nConfiguration\n\nglossary::Bool: flag to add or remove glossary with term definitions\ndpi::Int64: dots per inch for report plots (default: 300)\nfontfamily::String: font family for report (default: Times New)\n\n\n\n\n\n","category":"type"},{"location":"api_reporting/#Functions","page":"Reporting","title":"Functions","text":"","category":"section"},{"location":"api_reporting/#GEMS.abstract","page":"Reporting","title":"GEMS.abstract","text":"abstract(report::Report)\n\nReturns the abstract of a Report.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.abstract!","page":"Reporting","title":"GEMS.abstract!","text":"abstract!(report::Report, abstract::String)\n\nsetss the abstract of a Report.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.addsection!","page":"Reporting","title":"GEMS.addsection!","text":"addsection!(section::Section, subsection::AbstractSection)\n\nAdds a subsection to a provided section.\n\n\n\n\n\naddsection!(section::Section, subsections::Vector)\n\nAdds multiple subsection to a provided section.\n\n\n\n\n\naddsection!(report::Report, section::AbstractSection)\n\nAdds a Section to a Report. It can either be a regular section or a plot section.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.addtimer!","page":"Reporting","title":"GEMS.addtimer!","text":"addtimer!(rep::SimulationReport, to::TimerOutput)\n\nGenerates a Section from the consolue output of a TimerOutput object and adds it to a SimulationReport.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.author!","page":"Reporting","title":"GEMS.author!","text":"author!(report::Report, author::String)\n\nSets the author of a Report.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.author","page":"Reporting","title":"GEMS.author","text":"author(report::Report)\n\nReturns the author of a Report.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.buildreport","page":"Reporting","title":"GEMS.buildreport","text":"buildreport(data::Union{ResultData,BatchData}, style::String = \"\")\n\nInitializes and configures a simulation report with the tile, abstract, sections etc. provided in config. If config is an empty dictionary all available standard sections, plots, and the glossary etc. will be used. It returns a full SimulationReport object which can then be generated using the generate() function.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.content!","page":"Reporting","title":"GEMS.content!","text":"content!(section::Section, content::String)\n\nSets a section's content.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.content","page":"Reporting","title":"GEMS.content","text":"content(section::Section)\n\nReturns a section's content.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.date!","page":"Reporting","title":"GEMS.date!","text":"date!(report::Report, date::String)\n\nSets the date of a Report.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.date","page":"Reporting","title":"GEMS.date","text":"date(report::Report)\n\nReturns the date of a Report.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.description!-Tuple{ReportPlot, String}","page":"Reporting","title":"GEMS.description!","text":"description!(plot::ReportPlot, description::String)\n\nSetter for report plot description.\n\n\n\n\n\n","category":"method"},{"location":"api_reporting/#GEMS.description-Tuple{ReportPlot}","page":"Reporting","title":"GEMS.description","text":"description(plot::ReportPlot)\n\nReturn description from report plot object.\n\n\n\n\n\n","category":"method"},{"location":"api_reporting/#GEMS.dpi","page":"Reporting","title":"GEMS.dpi","text":"dpi(report)\n\nReturns dpi (dots per inch) from a report object. dpi conditions the resolution of images generated for the report.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.dpi!-Tuple{Report, Int64}","page":"Reporting","title":"GEMS.dpi!","text":"dpi!(report, dpi)\n\nSetter for report dpi (dot per inch) for images.\n\n\n\n\n\n","category":"method"},{"location":"api_reporting/#GEMS.escape_markdown-Tuple{String}","page":"Reporting","title":"GEMS.escape_markdown","text":"escape_markdown(str::String)\n\nReplaces markdown controls (e.g. \"_\" or \"*\") with their escaped version.\n\n\n\n\n\n","category":"method"},{"location":"api_reporting/#GEMS.filename!-Tuple{ReportPlot, String}","page":"Reporting","title":"GEMS.filename!","text":"filename!(plot::ReportPlot, filename::String)\n\nSetter for report plot filename.\n\n\n\n\n\n","category":"method"},{"location":"api_reporting/#GEMS.filename-Tuple{ReportPlot}","page":"Reporting","title":"GEMS.filename","text":"filename(plot::ReportPlot)\n\nReturn filename from report plot object.\n\n\n\n\n\n","category":"method"},{"location":"api_reporting/#GEMS.fontfamily!","page":"Reporting","title":"GEMS.fontfamily!","text":"fontfamily!(report, fontfamily)\n\nSetter for report fontfamily.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.fontfamily","page":"Reporting","title":"GEMS.fontfamily","text":"fontfamily(report)\n\nReturns font family config from a report object.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.generate-Tuple{Report, AbstractString}","page":"Reporting","title":"GEMS.generate","text":"generate(report::Report, directory::AbstractString)\n\nGenerates markdown string from a Report object including its nested subsections. The report will be stored as PDF, HTML, and MD in the provided directory. Images are generated and stored in an \"/img\" subfolder. \n\n\n\n\n\n","category":"method"},{"location":"api_reporting/#GEMS.glossary!","page":"Reporting","title":"GEMS.glossary!","text":"glossary!(report::Report, glossary::Bool)\n\nSets the glossary flag of a Report. If true, the glossary will be copied into the report upon generation.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.glossary","page":"Reporting","title":"GEMS.glossary","text":"glossary(report::Report)\n\nReturns the glossary flag of a Report.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.markdown","page":"Reporting","title":"GEMS.markdown","text":"markdown(infFrac::InfectedFraction)\n\nReturns a markdown string with all parameters (mainly for documentation purposes).\n\n\n\n\n\nmarkdown(tu::TimesUp)\n\nReturns a markdown string with all parameters (mainly for documentation purposes).\n\n\n\n\n\nmarkdown(pathogen::Pathogen)\n\nReturns a markdown string with all parameters (mainly for documentation purposes).\n\n\n\n\n\nmarkdown(unDist::Uniform)\n\nReturns a markdown string with all parameters (mainly for documentation purposes).\n\n\n\n\n\nmarkdown(poisDist::Poisson)\n\nReturns a markdown string with all parameters (mainly for documentation purposes).\n\n\n\n\n\nmarkdown(binDist::Binomial)\n\nReturns a markdown string with all parameters (mainly for documentation purposes).\n\n\n\n\n\nmarkdown(dist::Distribution)\n\nReturn a markdown string with all parameters (mainly for documentation purposes). Fallback function for arbitrary distributions without dedicated formatting.\n\n\n\n\n\nmarkdown(stngs::SettingsContainer, sim::Simulation)\n\nReturns a markdown string with all parameters (mainly for documentation purposes).\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.plotpackage-Tuple{PlotSection}","page":"Reporting","title":"GEMS.plotpackage","text":"plotpackage(ps::PlotSection)\n\nThis function is local to the report.jl script. It extracts the plotting package a PlotSection relies on (:plots, :vega, :gmt, etc...). This information is used to parallelize plot generation. It will return :other, if to package information is available  in the Plot struct.\n\n\n\n\n\n","category":"method"},{"location":"api_reporting/#GEMS.plt","page":"Reporting","title":"GEMS.plt","text":"plt(section::PlotSection)\n\nReturn the nested ReportPlot from a PlotSection object.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.reportdata-Tuple{Report}","page":"Reporting","title":"GEMS.reportdata","text":"reportdata(report::Report)\n\nReturns the associated ReportData object from a Report.\n\n\n\n\n\n","category":"method"},{"location":"api_reporting/#GEMS.savepath-Tuple{String}","page":"Reporting","title":"GEMS.savepath","text":"savepath(str::String)\n\nReplaces all backslashes in a path-string with forward slashes  to prevent weaving issues while generating TeX-PDFs as backslashes indicate control structures in TeX.\n\n\n\n\n\n","category":"method"},{"location":"api_reporting/#GEMS.sections-Tuple{Report}","page":"Reporting","title":"GEMS.sections","text":"sections(report::Report)\n\nReturns the array of sections of a Report.\n\n\n\n\n\n","category":"method"},{"location":"api_reporting/#GEMS.subsections-Tuple{Section}","page":"Reporting","title":"GEMS.subsections","text":"subsections(section::Section)\n\nReturns a section's array of subsections.\n\n\n\n\n\n","category":"method"},{"location":"api_reporting/#GEMS.subtitle!-Tuple{Report, String}","page":"Reporting","title":"GEMS.subtitle!","text":"subtitle!(report::Report, subtitle::String)\n\nSets the subtitle of a Report.\n\n\n\n\n\n","category":"method"},{"location":"api_reporting/#GEMS.subtitle-Tuple{Report}","page":"Reporting","title":"GEMS.subtitle","text":"subtitle(report::Report)\n\nReturns the subtitle of a Report.\n\n\n\n\n\n","category":"method"},{"location":"api_reporting/#GEMS.title!","page":"Reporting","title":"GEMS.title!","text":"title!(plot::ReportPlot, title::String)\n\nSetter for report plot title.\n\n\n\n\n\ntitle!(section::Section, title::String)\n\nSets a section's title.\n\n\n\n\n\ntitle!(report::Report, title::String)\n\nSets the title of a Report.\n\n\n\n\n\n","category":"function"},{"location":"api_reporting/#GEMS.title","page":"Reporting","title":"GEMS.title","text":"title(plot::ReportPlot)\n\nReturns title from report plot object.\n\n\n\n\n\ntitle(section::Section)\n\nReturns a section's title.\n\n\n\n\n\ntitle(report::Report)\n\nReturns the title of a Report.\n\n\n\n\n\n","category":"function"},{"location":"api_constants/#Constants","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"api_constants/","page":"Constants","title":"Constants","text":"constants.jl","category":"page"},{"location":"api_simulation/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"api_simulation/","page":"Simulation","title":"Simulation","text":"alles aus setup folder configuration des sim objects","category":"page"},{"location":"api_simulation/#Overview-Structs","page":"Simulation","title":"Overview Structs","text":"","category":"section"},{"location":"api_simulation/","page":"Simulation","title":"Simulation","text":"Pages   = [\"api_simulation.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_simulation/#Overview-Functions","page":"Simulation","title":"Overview Functions","text":"","category":"section"},{"location":"api_simulation/","page":"Simulation","title":"Simulation","text":"Pages   = [\"api_simulation.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_simulation/#Structs","page":"Simulation","title":"Structs","text":"","category":"section"},{"location":"api_simulation/#GEMS.InfectedFraction","page":"Simulation","title":"GEMS.InfectedFraction","text":"InfectedFraction <: StartCondition\n\nA StartCondition that specifies a fraction of infected individuals (drawn at random).\n\nFields\n\nfraction::Float64: A fraction of the whole population that has ot be infected\npathogen::Pathogen: The pathogen with which the fraction has to be infected\n\n\n\n\n\n","category":"type"},{"location":"api_simulation/#GEMS.NoneInfected","page":"Simulation","title":"GEMS.NoneInfected","text":"NoneInfected <: StopCriterion\n\nA StopCriterion that stops the simulation once no individual is infected.\n\n\n\n\n\n","category":"type"},{"location":"api_simulation/#GEMS.Simulation","page":"Simulation","title":"GEMS.Simulation","text":"Simulation\n\nA struct for the management of a single run, holding all necessary informations.\n\nFields\n\nData Sources\nconfigfile::String: Path to config file\nGeneral\ntick::Int16: Current tick/timestep\ntickunit::Char: Time unit of one simulation step (tick)\nstartdate::Date: Start date of the simulation\nenddate::Date: End date of the simulation\nstart_condition::StartCondition: Starting condition that sets the initial situation\nstop_criterion::StopCriterion: Criterion that terminates a simulation run\nlabel::String: Label for plot visualizations\nModel\npopulation::Population: Container to hold all present individuals\nsettings::SettingsContainer: All settings present in the simulation\npathogen::Pathogen: The pathogen of which infections are simulated\nLogger\ninfectionlogger::InfectionLogger: A logger tracking all infections    \ndeathlogger::DeathLogger: A logger specifically for the deaths of individuals\ntestlogger::TestLogger: A logger tracking all individual tests\npooltestlogger::PoolTestLogger: A logger tracking all pool tests\nquarantinelogger::QuarantineLogger: A tracking cumulative quarantines per tick\ncustomlogger::CustomLogger: A logger running custom methods on the Simulation object in each tick\nInterventions\nsymptom_triggers::Vector{ITrigger}: List of all SymptomTriggers\ntick_triggers::Vector{TickTrigger}: List of all TickTriggers\nhospitalization_triggers::Vector{ITrigger}: List of all HospitalizationTriggers\nevent_queue::EventQueue: Event Queue to apply intervention measures\nstrategies::Vector{Strategy}: List of all registered intervention strategies\ntesttypes::Vector{AbstractTestType}: List of all TestTypes (e.g. Antigen- or PCR-Test)\nRuntime Modifiers\nstepmod::Function: Single-argment function that runs custom code on the simulation object in each tick\n\n\n\n\n\n","category":"type"},{"location":"api_simulation/#GEMS.StartCondition","page":"Simulation","title":"GEMS.StartCondition","text":"supertype for all start conditions\n\n\n\n\n\n","category":"type"},{"location":"api_simulation/#GEMS.StopCriterion","page":"Simulation","title":"GEMS.StopCriterion","text":"supertype for all stop criteria\n\n\n\n\n\n","category":"type"},{"location":"api_simulation/#GEMS.TimesUp","page":"Simulation","title":"GEMS.TimesUp","text":"TimesUp <: StopCriterion\n\nA StopCriterion that specifies a time limit.\n\nFields\n\nlimit::Int16: A time limit. When reached, the simulation should be terminated.\n\n\n\n\n\n","category":"type"},{"location":"api_simulation/#Constructors","page":"Simulation","title":"Constructors","text":"","category":"section"},{"location":"api_simulation/#GEMS.Simulation-Tuple{}","page":"Simulation","title":"GEMS.Simulation","text":"Simulation(; simargs...)\n\nConstructor that creates and initializes a Simulation object based on various parameters.\n\nIt uses the default configuration for the created run which is saved in data/DefaultConf.toml but should not be edited. See Usage and Examples on how to edit the simulation configuration.\n\nThe constructor can be called without any parameters which will create a default simulation.\nA population can be provided. This can either be the path to a population file (.csv or .jdl2) or a Population object created. Either way the poulation will overwrite any population configurations in the config file.\nArguments can be provided overwriting just certain parameters. For all possible arguments see the table below.   These arguments can be used in combination with a custom config file and will overwrite it where possible. Arguments can be combined.\nAll arguments can alse be put into Dictionary and provided to function. This dictionary must have Symbols as keys. The keys must be the same as the argument names.\nAll possibilities above can also be combined. Providing arguments will overwrite custom config file where possible. Custom populations will override custom arguments.\n\nThe optional stepmod argument allows to pass a custom single-argument function that takes the simulation object as its argument and allows to do custom operations on the simulation object in each step.\n\nNote: Be careful with the stepmod option as there's no option to check whether your custom code invalidates simulation outputs or causes internal model inconsistencies. Please only use this option if you are sure you know what you're doing :-)\n\nExamples\n\nsim = Simulation() # returns a default simulation \n\nsim = Simulation(population = \"data/TestPop.csv\") # returns a Simulation using the assigned population file.\n\nsim = Simulation(population = Population()) # returns a Simulation using the created Population.\n\nmy_population = Population(n=1_000);\nsim = Simulation(population = my_population) # returns a Simulation using the created Population that has its own parameters.\n\nsim = Simulation(label = \"My First Simulation\") # returns a Simulation with a custom label\n\nsim = Simulation(startdate = \"2020.1.1\", n = 100_000, transmission_rate = 0.2) # returns a Simulation starting at the 1.1.2020, having 100,000 individuals and a transmission rate of 0.2\n\nmy_arguments = Dict(\n                    :transmission_rate => 0.3,\n                    :pop_size => 10_000_000\n                )\nsim = Simulation(my_arguments) # returns a `Simulation` the arguments provided in the dictionary.\n\nsim = Simulation(population = Population(n=100_000), label = \"My First Simulation\") # returns a Simulation with a custom label and a population partly overwriting the default configuration.\n\nParameters\n\nName Type Description\npopulation String, Population Path to a CSV or JLD2 file containing popultion data or a Population object\nsettingsfile String Path to a setting-file\nlabel String Label used to name simulation runs during analysis\nstepmod Function One-agument function which will be executed each simulation step, called on the Simulation object\nseed Int64 Random seed\nglobal_setting Bool Enable or disable a global setting that contains every individual\nstartdate Date, String Simulation start date (format: YYYY.MM.DD)\nenddate Date, String Simulation end date (format: YYYY.MM.DD)\ninfected_fraction Float64 Fraction of the initially infected agents for the InfectedFraction start condition\ntransmission_rate Float64 Infection probability (0-1) during a contact where one individual is infectious\nonset_of_symptoms Float64 Average time from exposure to onset of symptoms (Poisson-distributed)\nonset_of_severeness Float64 Average time from onset of symptoms to onset of severeness (Poisson-distributed)\ninfectious_offset Float64 Average time from onset of infectiousness to onset of symptoms (Poisson-distributed); cannot be before exposure, obviously.\nmild_death_rate Float64 Probability of dying (0-1) with a mild disease progression\nsevere_death_rate Float64 Probability of dying (0-1) with a severe disease progression\ncritical_death_rate Float64 Probability of dying (0-1) with a critical disease progression\nhospitalization_rate Float64 Probability of being hospitalized (0-1) with a severe disease progression\nventilation_rate Float64 Probability of being ventilated (0-1) with a critical disease progression\nicu_rate Float64 Probability of being admitted to ICU (0-1) with a critical disease progression\ntime_to_recovery Float64 Average time from onset of symptoms to recovery (Poisson-distributed)\ntime_to_hospitalization Float64 Average time from onset of symptoms to hospitalization (Poisson-distributed)\ntime_to_icu Float64 Average time from hospitalization to ICU-addmitance (Poisson-distributed)\nlength_of_stay Float64 Average duration of hospitalization (Poisson-distributed)\nprogression_categories Vector{Float64} Four-value vector indicating the fraction of individuals with an asymptomatic, mild, severe, and critical progression (must sum to 1)\noffice_contact_rate Float64 Average number of office contacts per timestep (Poisson-distributed)\nhousehold_contact_rate Float64 Average number of household contacts per timestep (Poisson-distributed)\nschool_contact_rate Float64 Average number of school contacts per timestep (Poisson-distributed)\nschool_class_contact_rate Float64 Average number of school-class contacts per timestep (Poisson-distributed)\nschool_year_contact_rate Float64 Average number of school-year contacts per timestep (Poisson-distributed)\nschool_complex_contact_rate Float64 Average number of school-complex contacts per timestep (Poisson-distributed)\nworkplace_site_contact_rate Float64 Average number of workplace-site contacts per timestep (Poisson-distributed)\nworkplace_contact_rate Float64 Average number of workplace contacts per timestep (Poisson-distributed)\ndepartment_contact_rate Float64 Average number of department contacts per timestep (Poisson-distributed)\nmunicipality_contact_rate Float64 Average number of municipality contacts per timestep (Poisson-distributed)\nglobal_contact_rate Float64 Average number of contacts in the global per timestep (Poisson-distributed)\nPopulation Parameters  \npop_size Int64 Number of individuals in the population\navg_household_size Int64 Average size of households\navg_office_size Int64 Average size of offices\navg_school_size Int64 Average size of schools\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.Simulation-Tuple{Dict{Symbol}}","page":"Simulation","title":"GEMS.Simulation","text":"Simulation(argsdict::Dict{Symbol, <:Any})\n\nTakes a dict as input.\n\nThe dict contains the custom parameters of the other constructors but combined as Dict with Symbols as keys.\n\nExample\n\n    my_arguments = Dict(\n                        :transmission_rate = 0.3,\n                        :configfile = \"Data/ChangedConfig.toml\",\n                        :n = 10_000_000\n                    )\n    sim = Simulation(my_arguments) # returns a `Simulation` the arguments provided in the dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.Simulation-Tuple{String}","page":"Simulation","title":"GEMS.Simulation","text":"Simulation(file::String; simargs...)\n\nTakes a path to a file as input and checks if it is a population or config file. Creates a simulation with that population or configuration. Further parameters can be defined.\n\nCalls a deeper constructor\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#Functions","page":"Simulation","title":"Functions","text":"","category":"section"},{"location":"api_simulation/#GEMS.add_hospitalization_trigger!","page":"Simulation","title":"GEMS.add_hospitalization_trigger!","text":"add_hospitalization_trigger!(simulation, trigger)\n\nAdds a HospitalizationTrigger to the simulation.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.add_strategy!","page":"Simulation","title":"GEMS.add_strategy!","text":"add_strategy!(simulation, strategy)\n\nAdds an intervention Strategy to the simulation object. A strategy must be added to the simulation object to make it appear in the report. In order to execute a strategy during the simulation run, you  must define a Trigger and link this strategy. Just adding it here  will not execute the strategy.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.add_symptom_trigger!","page":"Simulation","title":"GEMS.add_symptom_trigger!","text":"add_symptom_trigger!(simulation, trigger)\n\nAdds a SymptomTrigger to the simulation.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.add_testtype!","page":"Simulation","title":"GEMS.add_testtype!","text":"add_testtype!(simulation, testtype)\n\nAdds a test type to the simulation.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.add_tick_trigger!","page":"Simulation","title":"GEMS.add_tick_trigger!","text":"add_tick_trigger!(simulation, trigger)\n\nAdds a TickTrigger to the simulation.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.ags-Tuple{PatientZeros}","page":"Simulation","title":"GEMS.ags","text":"ags(patientZeros)\n\nReturns the vector of ags where intial seeds should be planted.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.configfile-Tuple{Simulation}","page":"Simulation","title":"GEMS.configfile","text":"configfile(simulation)\n\nReturns configfile that was used to initialize simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.customlogger!-Tuple{Simulation, CustomLogger}","page":"Simulation","title":"GEMS.customlogger!","text":"customlogger!(simulation, customlogger)\n\nSets the Simulation's CustomLogger.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.customlogger-Tuple{Simulation}","page":"Simulation","title":"GEMS.customlogger","text":"customlogger(simulation)\n\nReturns the CustomLogger of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.customlogs","page":"Simulation","title":"GEMS.customlogs","text":"customlogs(simulation::Simulation)\n\nCalls the dataframe() function on the internal simulation's CustomLogger.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.deaths-Tuple{Simulation}","page":"Simulation","title":"GEMS.deaths","text":"deaths(simulation::Simulation)\n\nCalls the dataframe() function on the internal simulation's DeathLogger.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.deathlogger-Tuple{Simulation}","page":"Simulation","title":"GEMS.deathlogger","text":"deathlogger(simulation)\n\nReturns the DeathLogger of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.evaluate","page":"Simulation","title":"GEMS.evaluate","text":"evaluate(simulation, criterion)\n\nEvaluates whether the specified stop criterion is met for the simulation model.      Return True if criterion was met.     This is an 'abstract' function that must be implemented for concrete criterion types.\n\n\n\n\n\nevaluate(simulation, criterion)\n\nReturns true if specified termination tick has been met.\n\n\n\n\n\nevaluate(simulation, criterion)\n\nReturns true if none of the individuals are infected.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.event_queue-Tuple{Simulation}","page":"Simulation","title":"GEMS.event_queue","text":"event_queue(simulation)\n\nReturns the simulation's intervention event queue.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.fire_custom_loggers!-Tuple{Simulation}","page":"Simulation","title":"GEMS.fire_custom_loggers!","text":"fire_custom_loggers!(sim::Simulation)\n\nExecutes all custom functions that are stored in the CustomLogger on the Simulation object and stores them in the internal dataframe.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.fraction-Tuple{InfectedFraction}","page":"Simulation","title":"GEMS.fraction","text":"fraction(infectedFraction)\n\nReturns fraction of individuals that shall be infected at the beginning in this start condition.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.hospitalization_triggers-Tuple{Simulation}","page":"Simulation","title":"GEMS.hospitalization_triggers","text":"hospitalization_triggers(simulation)\n\nReturns the list of HospitalizationTriggers registered in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.incidence","page":"Simulation","title":"GEMS.incidence","text":"incidence(simulation::Simulation, pathogen::Pathogen, base_size::Int = 100_000, duration::Int16 = Int16(7))\n\nReturns the incidence at a particular pathogen and a point in time (current simulation tick). The duration defines a time-span for which the incidence is measured (default: 7 ticks). The base_size provides the population size reference (default: 100_000 individuals)\n\nParameters\n\nsimulation::Simulation: Simulation object\npathogen::Pathogen: Pathogen for which the incidence shall be calculated\nbase_size::Int = 100_000 (optional): Reference popuation size for incidence calculation\nduration::Int16 = Int16(7) (optional): Reference duration (in ticks) for the incidence calculation\n\nReturns\n\nFloat64: Incidence\n\n\n\n\n\nincidence(simulation::Simulation, base_size::Int = 100_000, duration::Int16 = Int16(7))\n\nReturns the incidence at a particular point in time (current simulation tick). NOTE: This will only work for the single-pathogen version.  The duration defines a time-span for which the incidence is measured (default: 7 ticks). The base_size provides the population size reference (default: 100_000 individuals)\n\nParameters\n\nsimulation::Simulation: Simulation object\nbase_size::Int = 100_000 (optional): Reference popuation size for incidence calculation\nduration::Int16 = Int16(7) (optional): Reference duration (in ticks) for the incidence calculation\n\nReturns\n\nFloat64: Incidence\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.increment!-Tuple{Simulation}","page":"Simulation","title":"GEMS.increment!","text":"increment!(simulation)\n\nIncrements the current simulation's tick counter by 1.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.infections-Tuple{Simulation}","page":"Simulation","title":"GEMS.infections","text":"infections(simulation::Simulation)\n\nCalls the dataframe() function on the internal simulation's InfectionLogger.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.info-Tuple{Simulation}","page":"Simulation","title":"GEMS.info","text":"info(sim::Simulation)\n\nSummary output for Simulation object configuration.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.interval","page":"Simulation","title":"GEMS.interval","text":"interval(trigger::TickTrigger)\n\nReturns the interval associated with a TickTrigger.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.label-Tuple{Simulation}","page":"Simulation","title":"GEMS.label","text":"label(simulation::Simulation)\n\nReturns simulation object's string label.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.limit","page":"Simulation","title":"GEMS.limit","text":"limit(timesUp)\n\nReturns time limit of a timesUp stop criterion.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.parameters","page":"Simulation","title":"GEMS.parameters","text":"parameters(d::Distribution)\n\nReturns a dictionary containing the string() of the distribution, the mean and the std.\n\n\n\n\n\nparameters(dps::DiseaseProgressionStrat)::Dict\n\nObtains a dictionary containing the parameters of the DiseaseProgressionStrat.\n\n\n\n\n\nparameters(transfunc::TransmissionFunction)\n\nFallback function for transmission functions that returns the type of  the transmission function as an entry in a dictionary\n\n\n\n\n\nparameters(transfunc::AgeDependentTransmissionRate)\n\nReturns the parameters of the AgeDependentTransmissionRate as a dictionary.\n\n\n\n\n\nparameters(transfunc::ConstantTransmissionRate)\n\nReturns the parameters of the ConstantTransmissionRate as a dictionary.\n\n\n\n\n\nparameters(pathogen::Pathogen):::Dict\n\nObtains a dictionary containing the parameters of the Pathogen. Distributions and the disease progression are formatted using their parameters function.\n\n\n\n\n\nparameters(v::Vaccine)::Dict\n\nReturns a dictionary containing the parameters of the vaccine.\n\n\n\n\n\nparameters(s::StartCondition)\n\nReturns an empty dictionary.\n\n\n\n\n\nparameters(inffrac::InfectedFraction)\n\nReturns a dictionary containing the parameters of the infected fraction start condition.\n\n\n\n\n\nparameters(p0::PatientZero)\n\nReturns a dictionary containing the parameters of the patient zero  start condition.\n\n\n\n\n\nparameters(p0::PatientZero)\n\nReturns a dictionary containing the parameters of the patient zero  start condition.\n\n\n\n\n\nparameters(criterion::NoneInfected)\n\nFallback parameters function for the StopCriterion.\n\n\n\n\n\nparameters(criterion::TimesUp)\n\nReturns a dictionary with the type and limit of the criterion.\n\n\n\n\n\nparameters(criterion::NoneInfected)\n\nReturns a dictionary with the type of the NoneInfected stop criterion.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.pathogen!-Tuple{Simulation, Pathogen}","page":"Simulation","title":"GEMS.pathogen!","text":"pathogen!(simulation, pathogen)\n\nSets the pathogen of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.pathogen","page":"Simulation","title":"GEMS.pathogen","text":"pathogen(simulation)\n\nRetursn the pathogen of the simulation.\n\n\n\n\n\npathogen(patientZero)\n\nReturns pathogen used to infect individuals at the beginning in this start condition.\n\n\n\n\n\npathogen(patientZeros)\n\nReturns pathogen used to infect individuals at the beginning in this start condition.\n\n\n\n\n\npathogen(infectedFraction)\n\nReturns pathogen used to infect individuals at the beginning in this start condition.\n\n\n\n\n\npathogen(tt::TestType)\n\nReturns the TestType's associated pathogen.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.pooltests","page":"Simulation","title":"GEMS.pooltests","text":"pooltests(simulation::Simulation)\n\nCalls the dataframe() function on the internal simulation's PoolTestLogger.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.pooltestlogger","page":"Simulation","title":"GEMS.pooltestlogger","text":"pooltestlogger(simulation)\n\nReturns the PoolTestLogger of the simulation.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.population-Tuple{Simulation}","page":"Simulation","title":"GEMS.population","text":"population(simulation)\n\nReturns the population associated with the simulation run.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.populationDF-Tuple{Simulation}","page":"Simulation","title":"GEMS.populationDF","text":"populationDF(simulation::Simulation)\n\nCalls the dataframe() function on the simulation's Population object.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.populationfile-Tuple{Simulation}","page":"Simulation","title":"GEMS.populationfile","text":"populationfile(simulation)\n\nReturns populationfile that was used to initialize simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.quarantinelogger-Tuple{Simulation}","page":"Simulation","title":"GEMS.quarantinelogger","text":"quarantinelogger(simulation)\n\nReturns the QuarantineLogger of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.quarantines","page":"Simulation","title":"GEMS.quarantines","text":"quarantines(simulation::Simulation)\n\nCalls the dataframe() function on the internal simulation's QuarantineLogger.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.remove_empty_settings!-Tuple{Simulation}","page":"Simulation","title":"GEMS.remove_empty_settings!","text":"remove_empty_settings!(sim::Simulation)\n\nRemoves all settings that have no individuals associated with them. In the end update all ids to ensure that they are still correspond to the entry in the settings container.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.reset!-Tuple{Simulation}","page":"Simulation","title":"GEMS.reset!","text":"reset!(simulation)\n\nResets the current simulation's tick counter to 0.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.region_info-Tuple{Simulation}","page":"Simulation","title":"GEMS.region_info","text":"region_info(sim::Simulation)\n\nReturns a DataFrame containing information about the  Municipalitys in the model with the following columns:\n\nName Type Description\nags AGS Amtlicher Gemeindeschlüssel (Community Identification Code)\npop_size Int64 Number of individuals in that municipality\narea Float64 Area size of this municipality in km²\n\nNote: This function will download the Germany shapefile, if it's not available locally, and return missing values for pop_size and area if the download cannot be completed.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.run!-Tuple{Simulation}","page":"Simulation","title":"GEMS.run!","text":"run!(simulation::Simulation; with_progressbar::Bool = true)\n\nTakes and initializes Simulation object and calls the stepping function (step!) until the stop criterion is met.\n\nReturns\n\nSimulation: Simulation object\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.settings-Tuple{Simulation}","page":"Simulation","title":"GEMS.settings","text":"settings(simulation::Simulation)\n\nReturns a dictionary containing all settings, separated by setting type (key).\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.settings-Tuple{Simulation, DataType}","page":"Simulation","title":"GEMS.settings","text":"settings(simulation::Simulation, settingtype::DataType)\n\nReturns all settings of settingtype of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.should_fire","page":"Simulation","title":"GEMS.should_fire","text":"should_fire(trigger::TickTrigger, tick::Int16)\n\nEvaluates whether a trigger should be fired at a given tick. Considers switch_tick and interval.\n\nReturns\n\nBool: True, if the trigger should fire at this tick. False otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.start_condition","page":"Simulation","title":"GEMS.start_condition","text":"start_condition(simulation)\n\nReturns start condition associated with the simulation run.\n\n\n\n\n\nstart_condition(rd::ResultData)\n\nReturns the StartCondition object the simulation was initialized with. Returns an empty dictionary if the data is not available in the input ResultData object.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.step!","page":"Simulation","title":"GEMS.step!","text":"step!(simulation::Simulation)\n\nIncrements the simulation status by one tick and executes all events that shall be handled during this tick.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.stepmod","page":"Simulation","title":"GEMS.stepmod","text":"stepmod(simulation::Simulation)\n\nReturns the defined step mod.\n\n\n\n\n\n","category":"function"},{"location":"api_simulation/#GEMS.stop_criterion-Tuple{Simulation}","page":"Simulation","title":"GEMS.stop_criterion","text":"stop_criterion(simulation)\n\nReturns stop criterion associated with the simulation run.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.strategies-Tuple{Simulation}","page":"Simulation","title":"GEMS.strategies","text":"strategy(simulation)\n\nReturns the intervention Strategys registered in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.symptom_triggers-Tuple{Simulation}","page":"Simulation","title":"GEMS.symptom_triggers","text":"symptom_triggers(simulation)\n\nReturns the list of SymptomTriggers registered in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.testlogger-Tuple{Simulation}","page":"Simulation","title":"GEMS.testlogger","text":"testlogger(simulation)\n\nReturns the TestLogger of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.tests-Tuple{Simulation}","page":"Simulation","title":"GEMS.tests","text":"tests(simulation::Simulation)\n\nCalls the dataframe() function on the internal simulation's TestLogger.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.testtypes-Tuple{Simulation}","page":"Simulation","title":"GEMS.testtypes","text":"testtypes(simulation)\n\nReturns the test types registered in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.tick-Tuple{Simulation}","page":"Simulation","title":"GEMS.tick","text":"tick(simulation)\n\nReturns current tick of the simulation run.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.tick_triggers-Tuple{Simulation}","page":"Simulation","title":"GEMS.tick_triggers","text":"tick_triggers(simulation)\n\nReturns the list of TickTriggers registered in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_simulation/#GEMS.tickunit-Tuple{Simulation}","page":"Simulation","title":"GEMS.tickunit","text":"tickunit(simulation)\n\nReturns the unit of the ticks as a char like in date formats, i.e. 'd' means days, 'h' mean hours, etc.\n\n\n\n\n\n","category":"method"},{"location":"api_population/#Population","page":"Population","title":"Population","text":"","category":"section"},{"location":"api_population/#Overview-Structs","page":"Population","title":"Overview Structs","text":"","category":"section"},{"location":"api_population/","page":"Population","title":"Population","text":"Pages   = [\"api_population.md\"]\nOrder   = [:type]","category":"page"},{"location":"api_population/#Overview-Functions","page":"Population","title":"Overview Functions","text":"","category":"section"},{"location":"api_population/","page":"Population","title":"Population","text":"Pages   = [\"api_population.md\"]\nOrder   = [:function]","category":"page"},{"location":"api_population/#Constructors","page":"Population","title":"Constructors","text":"","category":"section"},{"location":"api_population/#GEMS.Population","page":"Population","title":"GEMS.Population","text":"Population\n\nA Type for a simple population. Acts as a container for a collection of individuals.\n\nFields\n\nindividuals::Vector{Individual}: List of associated individuals\nmaxage: Age of the oldest individual\nminid: smallest id of any individual\n\n\n\n\n\n","category":"type"},{"location":"api_population/#GEMS.Population-Tuple{Vector{Individual}}","page":"Population","title":"GEMS.Population","text":"Population(individuals::Vector{Individual})\n\nCreates a Population object from a vector of Individuals.\n\n\n\n\n\n","category":"method"},{"location":"api_population/#GEMS.Population-Tuple{DataFrame}","page":"Population","title":"GEMS.Population","text":"Population(df::DataFrame)\n\nCreates a Population object from a DataFrame where each row corresponds to one individual. The dataframe column names must correspond to the fieldnames of the Individual struct. id (Int32), age (Int8), and sex (Int8) are required columns. Everything else is optional. \n\n\n\n\n\n","category":"method"},{"location":"api_population/#GEMS.Population-Tuple{String}","page":"Population","title":"GEMS.Population","text":"Population(path::String)\n\nCreates a Population object from a CSV- or JLD2 file (path).\n\n\n\n\n\n","category":"method"},{"location":"api_population/#GEMS.Population-Tuple{}","page":"Population","title":"GEMS.Population","text":"Population(; n::Int64 = 100_000, avg_household_size::Int64 = 3, avg_office_size::Int64 = 5, avg_school_size::Int64 = 100)\n\nCreates a Population object without an explicit data source and randomly generates the individuals.\n\nParameters\n\nn::Int64 = 100_000 (optional): Number of individuals in the population (default = 100_000)\navg_household_size::Int64 = 3 (optional): Average size of households (default = 3)\navg_office_size::Int64 = 5 (optional): Average size of offices (default = 5)\navg_school_size::Int64 = 100 (optional): Average size of schools (default = 100)\nempty::Bool = false (optional): If true, overrides all other arguments and returns a completely empty population object\n\n\n\n\n\n","category":"method"},{"location":"api_population/#Functions","page":"Population","title":"Functions","text":"","category":"section"},{"location":"api_population/#GEMS.add!-Tuple{Population, Individual}","page":"Population","title":"GEMS.add!","text":"add!(population::Population, individual::Individual)\n\nAppends specified individual to a population.\n\n\n\n\n\n","category":"method"},{"location":"api_population/#Base.count-Tuple{Any, Population}","page":"Population","title":"Base.count","text":"count(f, population::Population)\n\nCounts the occurences where the boolean expression f returns true when applied to an individual in the population.\n\nExample\n\ncount(x -> age(x) < 20, pop) returns the number of individuals in the population model pop who are younger than 20 years.\n\n\n\n\n\n","category":"method"},{"location":"api_population/#GEMS.dataframe-Tuple{Population}","page":"Population","title":"GEMS.dataframe","text":"dataframe(population::Population)\n\nReturns a DataFrame representing the given population.\n\nReturns\n\nDataFrame with the following columns:\n\nName Type Description\nid Int32 Individual id\nsex Int8 Individual sex\nage Int8 Individual age\neducation Int8 Individual education level\noccupation Int16 Individual occupation group\nhousehold Int32 Individual associated household\noffice Int32 Individual associated office\nschool Int32 Individual associated school\n\n\n\n\n\n","category":"method"},{"location":"api_population/#GEMS.each!","page":"Population","title":"GEMS.each!","text":"each!(f, population::Population)\n\nApplies function f to all individuals in the population.\n\nExample\n\neach!(i -> i.age = i.age + 1, pop) lets all individuals in the populaiton pop age by one year.\n\n\n\n\n\n","category":"function"},{"location":"api_population/#Base.first-Tuple{Population}","page":"Population","title":"Base.first","text":"first(population::Population)\n\nReturns the first individual of the internal vector.\n\n\n\n\n\n","category":"method"},{"location":"api_population/#GEMS.get_individual_by_id-Tuple{Population, Int32}","page":"Population","title":"GEMS.get_individual_by_id","text":"get_individual_by_id(population::Population, ind::Int32)\n\nReturns an individual contained in the Population selected by its id.\n\n\n\n\n\n","category":"method"},{"location":"api_population/#GEMS.individuals-Tuple{Population}","page":"Population","title":"GEMS.individuals","text":"individuals(population::Population)\n\nReturn the individuals associated with the population.\n\n\n\n\n\n","category":"method"},{"location":"api_population/#Base.issubset-Tuple{Vector{Individual}, Vector{Individual}}","page":"Population","title":"Base.issubset","text":"issubset(individuals_a::Vector{Individual}, individuals_b::Vector{Individual})\n\nChecks whether a vector of individuals A is a subset of individuals B based on the individual's IDs. Does only work if all individuals have unique IDs.\n\n\n\n\n\n","category":"method"},{"location":"api_population/#GEMS.maxage-Tuple{Population}","page":"Population","title":"GEMS.maxage","text":"maxage(population::Population)\n\nReturns the maximum age of any individual in the population\n\n\n\n\n\n","category":"method"},{"location":"api_population/#GEMS.num_of_infected-Tuple{Population}","page":"Population","title":"GEMS.num_of_infected","text":"num_of_infected(population::Population)\n\nReturns the number of infected individuals in a given population.\n\n\n\n\n\n","category":"method"},{"location":"api_population/#GEMS.params-Tuple{Population}","page":"Population","title":"GEMS.params","text":"params(population::Population)\n\nReturns the parameters that were used to generate this population.\n\n\n\n\n\n","category":"method"},{"location":"api_population/#GEMS.populationfile-Tuple{Population}","page":"Population","title":"GEMS.populationfile","text":"populationfile(population::Population)\n\nReturns the population file that was used to generate this population.\n\n\n\n\n\n","category":"method"},{"location":"api_population/#GEMS.remove!-Tuple{Population, Individual}","page":"Population","title":"GEMS.remove!","text":"remove!(population::Population, individual::Individual)\n\nRemove a specified individual from a population.\n\n\n\n\n\n","category":"method"},{"location":"api_population/#GEMS.save-Tuple{Population, AbstractString}","page":"Population","title":"GEMS.save","text":"save(population::Population, path::AbstractString)\n\nSaves the given population as a CSV-file at path.\n\n\n\n\n\n","category":"method"},{"location":"api_population/#Base.size-Tuple{Population}","page":"Population","title":"Base.size","text":"size(population::Population)\n\nReturns the number of individuals in a given population.\n\n\n\n\n\n","category":"method"}]
}
